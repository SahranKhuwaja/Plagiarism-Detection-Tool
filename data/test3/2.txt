2 U GRANT INSERT (A) ON R TO V
3 U REVOKE INSERT ON R FROM V RESTRICT
When U revokes INSERT from V, the INSERT (A) privilege remains. The 
grant diagrams after steps (2) and (3) are shown in Fig. 10.4.
Notice that after step (2) there are two separate nodes for the two similar 
but distinct privileges that user V has. Also observe that the RESTRICT option 
in step (3) does not prevent the revocation, because V had not granted the
10.1. SECU RITY AND USER AUTHORIZATION IN SQL 435
(a) After step (2) (b) After step (3)
Figure 10.4: Revoking a general privilege leaves a more specific privilege
option to any other user. In fact, V could not have granted either privilege, 
because V obtained them without grant option. □
E xam ple 10.7: Now, let us consider a similar example where U grants V
a privilege p* that includes the grant option and then revokes only the grant 
option. Assume the grant by U was based on its privilege q*. In this case, we 
must replace the arc from the U/q* node to V/p* by an arc from U/q* to V/p,
i.e., the same privilege without the grant option. If there was no such node 
V/p, it must be created. In normal circumstances, the node V/p* becomes 
unreachable, and any grants of p made by V will also be unreachable. However, 
it may be that V was granted p* by some other user besides U, in which case 
the V /p* node remains accessible.
Here is a typical sequence of steps:
Step By Action
1 U GRANT p TO V WITH GRANT OPTION
2 V GRANT p TO W
3 U REVOKE GRANT OPTION FOR p FROM V CASCADE
In step (1), U grants the privilege p to V with the grant option. In step (2), 
V uses the grant option to grant p to W . The diagram is then as shown in 
Fig. 10.5(a).
Then in step (3), U revokes the grant option for privilege p from V, but 
does not revoke the privilege itself. Since there is no node V/p, we create one. 
The arc from U /p** to V/P* is removed and replaced by one from U/p * * to 
V/p.
Now, the nodes V/p* and W /p are not reachable from any ** node. Thus, 
these nodes are deleted from the diagram. The resulting grant diagram is shown 
in Fig. 10.5(b). □
436 CHAPTER 10. ADVANCED TOPICS IN RELATIONAL DATABASES
(a) After step (2) (b) After step (3)
Figure 10.5: Revoking a grant option leaves the underlying privilege
10.1.7 Exercises for Section 10.1
E xercise 10.1.1: Indicate what privileges are needed to execute the following 
queries. In each case, mention the most specific privileges as well as general 
privileges that are sufficient.
a) The query of Fig. 6.5.
b) The query of Fig. 6.7.
c) The insertion of Fig. 6.15.
d) The deletion of Example 6.37.
e) The update of Example 6.39.
f) The tuple-based check of Fig. 7.3.
g) The assertion of Example 7.11.
E xercise 10.1.2: Show the grant diagrams after steps (4) through (6) of the 
sequence of actions listed in Fig. 10.6. Assume A is the owner of the relation 
to which privilege p refers.
Step By Action___________________________________
1 A GRANT p TO B WITH GRANT OPTION
2 A GRANT p TO C
3 B GRANT p TO D WITH GRANT OPTION
4 D GRANT p TO B , C , E WITH GRANT OPTION
5 B REVOKE p FROM D CASCADE
6 A REVOKE p FROM C CASCADE
Figure 10.6: Sequence of actions for Exercise 10.1.2
Exercise 10.1.3: Show the grant diagrams after steps (5) and (6) of the sequence of actions listed in Fig. 10.7. Assume A is the owner of the relation to 
which privilege p refers.
Step By Action
10.2. RECURSION IN SQL 437
1 A GRANT p TO B , E WITH GRANT OPTION
2 B GRANT p TO C WITH GRANT OPTION
3 C GRANT p TO D WITH GRANT OPTION
4 E GRANT p TO C
5 E GRANT p TO D WITH GRANT OPTION
6 A REVOKE GRANT OPTION FOR p FROM B CASCADE
Figure 10.7: Sequence of actions for Exercise 10.1.3
Exercise 10.1.4: Show the final grant diagram after the following steps, assuming A is the owner of the relation to which privilege p refers.
Step By Action
1 A GRANT p TO B WITH GRANT OPTION
2 B GRANT p TO B WITH GRANT OPTION
3 A REVOKE p FROM B CASCADE
10.2 Recursion in SQL
The SQL-99 standard includes provision for recursive definitions of queries. 
Although this feature is not part of the “core” SQL-99 standard that every 
DBMS is expected to implement, at least one major system — IBM’s DB2 — 
does implement the SQL-99 proposal, which we describe in this section.
10.2.1 Defining Recursive Relations in SQL
The WITH statement in SQL allows us to define temporary relations, recursive 
or not. To define a recursive relation, the relation can be used within the WITH 
statement itself. A simple form of the WITH statement is:
WITH R AS <definition of R> <query involving R>
That is, one defines a temporary relation named R, and then uses R in some 
query. The temporary relation is not available outside the query that is part of 
the WITH statement.
More generally, one can define several relations after the WITH, separating 
their definitions by commas. Any of these definitions may be recursive. Several defined relations may be mutually recursive; that is, each may be defined 
in terms of some of the other relations, optionally including itself. However, 
any relation that is involved in a recursion must be preceded by the keyword 
RECURSIVE. Thus, a more general form of WITH statement is shown in Fig. 10.8.
E xam ple 10.8: Many examples of the use of recursion can be found in a study 
of paths in a graph. Figure 10.9 shows a graph representing some flights of two
438 CHAPTER 10. ADVANCED TOPICS IN RELATIONAL DATABASES
WITH
[RECURSIVE] R i AS <definition of R i> ,
[RECURSIVE] R 2 AS <definition of R 2> ,
[RECURSIVE] R n AS <definition of R n>
< query involving R i, R2, ... ,R n >
Figure 10.8: Form of a WITH statement defining several temporary relations
hypothetical airlines — Untried Airlines (UA), and Arcane Airlines (AA) — 
among the cities San Francisco, Denver, Dallas, Chicago, and New York. The 
data of the graph can be represented by a relation
F lig h ts ( a ir lin e , frm, to , d e p a rts, a rriv e s ) 
and the particular tuples in this table are shown in Fig. 10.9.
AA 1900-2200
Figure 10.9: A map of some airline flights
airline from to departs arrives
UA SF DEN 930 1230
AA SF DAL 900 1430
UA DEN CHI 1500 1800
UA DEN DAL 1400 1700
AA DAL CHI 1530 1730
AA DAL NY 1500 1930
AA CHI NY 1900 2200
UA CHI NY 1830 2130
Figure 10.10: Tuples in the relation F lig h ts
The simplest recursive question we can ask is “For what pairs of cities (x , y)
is it possible to get from city x to city y by taking one or more flights?” Before
10.2. RECURSION IN SQL 439
writing this query in recursive SQL, it is useful to express the recursion in 
the Datalog notation of Section 5.3. Since many concepts involving recursion 
are easier to express in Datalog than in SQL, you may wish to review the 
terminology of that section before proceeding. The following two Datalog rules 
describe a relation R eaches(x,y) that contains exactly these pairs of cities.
1. R eaches(x.y) «— F lig h ts ( a ,x ,y ,d ,r )
2. R eaches(x,y) •<— R eaches(x,z) AND R eaches(z,y)
The first rule says that Reaches contains those pairs of cities for which there 
is a direct flight from the first to the second; the airline a, departure time d,
and arrival time r are arbitrary in this rule. The second rule says that if you 
can reach from city x to city z and you can reach from z to city y, then you 
can reach from x to y.
Evaluating a recursive relation requires that we apply the Datalog rules 
repeatedly, starting by assuming there are no tuples in Reaches. We begin 
by using Rule (1) to get the following pairs in Reaches: (SF, DEN), (SF, DAL), 
(DEN, CHI), (DEN, DAL), (DAL, CHI), (DAL, NY), and (CHI, NY). These are the seven 
pairs represented by arcs in Fig. 10.9.
In the next round, we apply the recursive Rule (2) to put together pairs 
of arcs such that the head of one is the tail of the next. That gives us the 
additional pairs (SF, CHI), (DEN, NY), and (SF, NY). The third round combines 
all one- and two-arc pairs together to form paths of length up to four arcs. 
In this particular diagram, we get no new pairs. The relation Reaches thus 
consists of the ten pairs (a;, y) such that y is reachable from x in the diagram 
of Fig. 10.9. Because of the way we drew the diagram, these pairs happen to 
be exactly those (x ,y ) such that y is to the right of x in Fig 10.9.
From the two Datalog rules for Reaches in Example 10.8, we can develop 
a SQL query that produces the relation Reaches. This SQL query places the 
Datalog rules for Reaches in a WITH statement, and follows it by a query. In 
our example, the desired result was the entire Reaches relation, but we could 
also ask some query about Reaches, for instance the set of cities reachable from 
Denver.
1) WITH RECURSIVE Reaches(frm, to ) AS
2) (SELECT frm, to FROM F lig h ts)
3) UNION
4) (SELECT R I.frm , R2.to
5) FROM Reaches RI, Reaches R2
6) WHERE R I.to = R2.frm)
7) SELECT * FROM Reaches;
Figure 10.11: Recursive SQL query for pairs of reachable cities
Figure 10.11 shows how to express Reaches as a SQL query. Line (1) introduces the definition of Reaches, while the actual definition of this relation is in
440 CHAPTER 10. ADVANCED TOPICS IN RELATIONAL DATABASES
Mutual Recursion
There is a graph-theoretic way to check whether two relations or predicates are mutually recursive. Construct a dependency graph whose nodes 
correspond to the relations (or predicates if we are using Datalog rules). 
Draw an arc from relation A to relation B if the definition of B depends 
directly on the definition of A. That is, if Datalog is being used, then A
appears in the body of a rule with B at the head. In SQL, A would appear 
in a FROM clause, somewhere in the definition of B, possibly in a subquery. 
If there is a cycle involving nodes R and S, then R and 5 are mutually
recursive. The most common case will be a loop from R to R, indicating 
that R depends recursively upon itself.
lines (2) through (6).
That definition is a union of two queries, corresponding to the two Datalog 
rules by which Reaches was defined. Line (2) is the first term of the union and 
corresponds to the first, or basis rule. It says that for every tuple in the F lig h ts 
relation, the second and third components (the f rm and to components) are a 
tuple in Reaches.
Lines (4) through (6) correspond to Rule (2), the recursive rule, in the 
definition of Reaches. The two Reaches subgoals in Rule (2) are represented in 
the FROM clause by two aliases RI and R2 for Reaches. The first component of 
RI corresponds to x in Rule (2), and the second component of R2 corresponds 
to y. Variable z is represented by both the second component of RI and the 
first component of R2; note that these components are equated in line (6).
Finally, line (7) describes the relation produced by the entire query. It is a 
copy of the Reaches relation. As an alternative, we could replace line (7) by a 
more complex query. For instance,
7) SELECT to FROM Reaches WHERE frm = ’DEN’ ; 
would produce all those cities reachable from Denver. □
10.2.2 Problematic Expressions in Recursive SQL
The SQL standard for recursion does not allow an arbitrary collection of mutually recursive relations to be written in a WITH clause. There is a small matter 
that the standard requires only that linear recursion be supported. A linear 
recursion, in Datalog terms, is one in which no rule has more than one subgoal 
that is mutually recursive with the head. Notice that Rule (2) in Example 10.8 
has two subgoals with predicate Reaches that are mutually recursive with the 
head (a predicate is always mutually recursive with itself; see the box on Mutual
10.2. RECURSION IN SQL 441
Recursion). Thus, technically, a DBMS might refuse to execute Fig. 10.11 and 
yet conform to the standard.1
But there is a more important restriction on SQL recursions, one that, if 
violated leads to recursions that cannot be executed by the query processor in 
any meaningful way. To be a legal SQL recursion, the definition of a recursive 
relation R may involve only the use of a mutually recursive relation S (including 
R itself) if that use is “monotone” in S. A use of S is monotone if adding an 
arbitrary tuple to S might add one or more tuples to R, or it might leave 
R unchanged, but it can never cause any tuple to be deleted from R. The 
following example suggests what can happen if the monotonicity requirement 
is not respected.
E xam ple 10.9: Suppose relation R is a unary (one-attribute) relation, and its 
only tuple is (0). R is used as an EDB relation in the following Datalog rules:
1. P(x) <- R(x) AND NOT Q(x)
2. Q(x) «- R(x) AND NOT P(x)
Informally, the two rules tell us that an element x in R is either in P or in Q
but not both. Notice that P and Q are mutually recursive.
If we start out, assuming that both P and Q are empty, and apply the 
rules once, we find that P — {(0)} and Q = {(0)}; that is, (0) is in both IDB 
relations. On the next round, we apply the rules to the new values for P and 
Q again, and we find that now both are empty. This cycle repeats as long as 
we like, but we never converge to a solution.
In fact, there are two “solutions” to the Datalog rules:
a) P = {(0)} Q = 0
b) p = 0 Q = {(0)}
However, there is no reason to assume one over the other, and the simple 
iteration we suggested as a way to compute recursive relations never converges 
to either. Thus, we cannot answer a simple question such as “Is P(0) true?”
The problem is not restricted to Datalog. The two Datalog rules of this 
example can be expressed in recursive SQL. Figure 10.12 shows one way of 
doing so. This SQL does not adhere to the standard, and no DBMS should 
execute it. □
The problem in Example 10.9 is that the definitions of P and Q in Fig. 10.12 
are not monotone. Look at the definition of P in lines (2) through (5) for 
instance. P depends on Q, with which it is mutually recursive, but adding a 
tuple to Q can delete a tuple from P. Notice that if R — {(0)} and Q is empty, 
then P = {(0)}. But if we add (0) to Q, then we delete (0) from P. Thus, the 
definition of P is not monotone in Q, and the SQL code of Fig. 10.12 does not 
meet the standard.
1N ote, however, th a t we can replace eith er one of th e uses of R eaches in line (5) of F ig. 10.11 
by F lig h ts , an d th u s m ake th e recursion linear. N onlinear recursions can frequently — 
although n o t alw ays — be m ade lin ear in th is fashion.
442 CHAPTER 10. ADVANCED TOPICS IN RELATIONAL DATABASES
1) WITH
2) RECURSIVE P(x) AS
3) (SELECT *
4) EXCEPT
5) (SELECT *
6) RECURSIVE Q(x) AS
7) (SELECT *
8) EXCEPT
9) (SELECT *
10) SELECT * FROM P;
Figure 10.12: Query with nonmonotonic behavior, illegal in SQL
E xam ple 1 0 .1 0 : Aggregation can also lead to nonmonotonicity. Suppose we 
have unary (one-attribute) relations P and Q defined by the following two 
conditions:
1. P is the union of Q and an EDB relation R.
2. Q has one tuple that is the sum of the members of P.
We can express these conditions by a WITH statement, although this statement 
violates the monotonicity requirement of SQL. The query shown in Fig. 10.13 
asks for the value of P.
1) WITH
2) RECURSIVE P(x) AS
3) (SELECT * FROM R)
4) UNION
5) (SELECT * FROM Q),
6) RECURSIVE Q(x) AS
7) SELECT SUM(x) FROM P
8) SELECT * FROM P;
Figure 10.13: Nonmonotone query involving aggregation, illegal in SQL
Suppose that R consists of the tuples (12) and (34), and initially P and Q
are both empty. Figure 10.14 summarizes the values computed in the first six 
rounds. Note that both relations are computed, in one round, from the values 
of the relations at the previous round. Thus, P is computed in the first round
10.2. RECURSION IN SQL 443
Round P Q
1) {(12), (34)} {NULL}
2) {(12), (34),NULL} {(46)}
3) {(12), (34), (46)} {(46)}
4) {(12), (34), (46)} {(92)}
5) {(12), (34), (92)} {(92)}
6) {(12), (34), (92)} {(138)}
Figure 10.14: Iterative calculation for a nonmonotone aggregation
to be the same as R, and Q is {NULL}, since the old, empty value of P is used 
in line (7).
At the second round, the union of lines (3) through (5) is the set
R U {NULL} = {(12), (34), NULL}
so that set becomes the new value of P. The old value of P was {(12), (34)}, 
so on the second round Q = {(46)}. That is, 46 is the sum of 12 and 34.
At the third round, we get P = {(12), (34), (46)} at lines (2) through (5). 
Using the old value of P, {(12), (34), NULL}, Q is defined by lines (6) and (7) to 
be {(46)} again. Remember that NULL is ignored in a sum.
At the fourth round, P has the same value, {(12), (34), (46)}, but Q gets 
the value {(92)}, since 12+34+46=92. Notice that Q has lost the tuple (46), 
although it gained the tuple (92). That is, adding the tuple (46) to P has 
caused a tuple (by coincidence the same tuple) to be deleted from Q. That 
behavior is the nonmonotonicity that SQL prohibits in recursive definitions, 
confirming that the query of Fig. 10.13 is illegal. In general, at the 2*th round, 
P will consist of the tuples (12), (34), and (46* — 46), while Q consists only of 
the tuple (46*). □
10.2.3 Exercises for Section 10.2
Exercise 10.2.1: The relation
Flights(airline, frm, to, departs, arrives)
from Example 10.8 has arrival- and departure-time information that we did not 
consider. Suppose we are interested not only in whether it is possible to reach 
one city from another, but whether the journey has reasonable connections. 
That is, when using more than one flight, each flight must arrive at least an 
hour before the next flight departs. You may assume that no journey takes 
place over more than one day, so it is not necessary to worry about arrival close 
to midnight followed by a departure early in the morning.
a) Write this recursion in Datalog.
444 CHAPTER 10. ADVANCED TOPICS IN RELATIONAL DATABASES
b) Write the recursion in SQL.
! Exercise 10.2.2: In Example 10.8 we used frm as an attribute name. Why 
did we not use the more obvious name from?
Exercise 10.2.3: Suppose we have a relation
SequelOf(movie, sequel)
that gives the immediate sequels of a movie, of which there can be more than 
one. We want to define a recursive relation FollowOn whose pairs (x, y) are 
movies such that y was either a sequel of x, a sequel of a sequel, or so on.
a) Write the definition of FollowOn as recursive Datalog rules.
b) Write the definition of FollowOn as a SQL recursion.
c) Write a recursive SQL query that returns the set of pairs (x , y) such that 
movie y is a follow-on to movie x, but is not a sequel of x.
d) Write a recursive SQL query that returns the set of pairs (a;, y) meaning 
that y is a follow-on of x, but is neither a sequel nor a sequel of a sequel.
! e) Write a recursive SQL query that returns the set of movies x that have 
at least two follow-ons. Note that both could be sequels, rather than one 
being a sequel and the other a sequel of a sequel.
! f) Write a recursive SQL query that returns the set of pairs (x , y) such that 
movie y is a follow-on of x but y has at most one follow-on.[14] contains much information on data structures, including techniques for 
selecting hash functions and designing hash tables, as well as a number of ideas 
concerning B-tree variants. The B+ tree formulation (without key values at 
interior nodes) appeared in the 1973 edition of [14].
Secondary indexes and other techniques for retrieval of documents are covered by [23]. Also, [10] and [1] are surveys of index methods for text documents.
The kd-tice is from [4]. Modifications suitable for secondary storage appeared in [5] and [21]. Partitioned hashing and its use in partial-match retieval 
is from [20] and [7]. However, the design idea from Exercise 14.5.6 is from [22],
Grid files first appeared in [16] and the quad tree in [11]. The R-tree is from 
[13], and two extensions [24] and [3] are well known.
The bitmap index has an interesting history. There was a company called 
Nucleus, founded by Ted Glaser, that patented the idea and developed a DBMS 
in which the bitmap index was both the index structure and the data representation. The company failed in the late 1980’s, but the idea has recently 
been incorporated into several major commercial database systems. The first 
published work on the subject was [17]. [18] is a recent expansion of the idea.
There are a number of surveys of multidimensional storage structures. One 
of the earliest is [6]. More recent surveys are found in [25] and [12]. The former 
also includes surveys of several other important database topics.
1. R. Baeza-Yates, “Integrating contents and structure in text retrieval,” 
SIGMOD Record 25:1 (1996), pp. 67-79.
2. R. Bayer and E. M. McCreight, “Organization and maintenance of large 
ordered indexes,” Acta Informatica 1:3 (1972), pp. 173-189.
3. N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger, “The R*-tree: 
an efficient and robust access method for points and rectangles,” Proc.
ACM SIGMOD Intl. Conf. on Management of Data (1990), pp. 322-331.
4. J. L. Bentley, “Multidimensional binary search trees used for associative 
searching,” Comm. ACM 18:9 (1975), pp. 509-517.
5. J. L. Bentley, “Multidimensional binary search trees in database applications,” IEEE Trans, on Software Engineering SE-5:4 (1979), pp. 333-340.
6. J. L. Bentley and J. H. Friedman, “Data structures for range searching,” 
Computing Surveys 13:3 (1979), pp. 397-409.
7. W. A. Burkhard, “Hashing and trie algorithms for partial match retrieval,” ACM Trans, on Database Systems 1:2 (1976), pp. 175-187.
8. D. Comer, “The ubiquitous B-tree,” Computing Surveys 11:2 (1979), 
pp. 121-137.
14.9. REFERENCES FOR CHAPTER 14 699
9. R. Fagin, J. Nievergelt, N. Pippenger, and H. R. Strong, “Extendible hashing — a fast access method for dynamic files,” ACM Trans, on Database
Systems 4:3 (1979), pp. 315-344.
10. C. Faloutsos, “Access methods for text,” Computing Surveys 17:1 (1985), 
pp. 49-74.
11. R. A. Finkel and J. L. Bentley, “Quad trees, a data structure for retrieval 
on composite keys,” Acta Informatica 4:1 (1974), pp. 1-9.
12. V. Gaede and 0 . Gunther, “Multidimensional access methods,” Computing Surveys 30:2 (1998), pp. 170-231.
13. A. Guttman, “R-trees: a dynamic index structure for spatial searching,” 
Proc. ACM SIGMOD Intl. Conf. on Management of Data (1984), pp. 47- 
57.
14. D. E. Knuth, The Art of Computer Programming, Vol. Ill, Sorting and
Searching, Second Edition, Addison-Wesley, Reading MA, 1998.
15. W. Litwin, “Linear hashing: a new tool for file and table addressing,” 
Intl. Conf. on Very Large Databases, pp. 212-223, 1980.
16. J. Nievergelt, H. Hinterberger, and K. Sevcik, “The grid file: an adaptable, 
symmetric, multikey file structure,” ACM Trans, on Database Systems 9:1 
(1984), pp. 38-71.
17. P. O’Neil, “Model 204 architecture and performance,” Proc. Second Intl.
Workshop on High Performance Transaction Systems, Springer-Verlag, 
Berlin, 1987.
18. P. O’Neil and D. Quass, “Improved query performance with variant indexes,” Proc. ACM SIGMOD Intl. Conf. on Management of Data (1997), 
pp. 38-49.
19. W. W. Peterson, “Addressing for random access storage,” IBM J. Research and Development 1:2 (1957), pp. 130-146.
20. R. L. Rivest, “Partial match retrieval algorithms,” SIAM J. Computing
5:1 (1976), pp. 19-50.
21. J. T. Robinson, “The K-D-B-tree: a search structure for laxge multidimensional dynamic indexes,” Proc. ACM SIGMOD Intl. Conf. on Mamagement of Data (1981), pp. 10-18.
22. J. B. Rothnie Jr. and T. Lozano, “Attribute based file organization in a 
paged memory environment, Comm. ACM 17:2 (1974), pp. 63-69.
23. G. Salton, Introduction to Modern Information Retrieval, McGraw-Hill, 
New York, 1983.
700 CHAPTER 14. INDEX STRUCTURES
24. T. K. Sellis, N. Roussopoulos, and C. Faloutsos, “The R+-tree: a dynamic 
index for multidimensional objects,” Intl. Conf. on Very Large Databases,
pp. 507-518, 1987.
25. C. Zaniolo, S. Ceri, C. Faloutsos, R. T. Snodgrass, V. S. Subrahmanian, 
and R. Zicari, Advanced Database Systems, Morgan-Kaufmann, San Francisco, 1997.
Chapter 15
Query Execution
The broad topic of query processing will be covered in this chapter and Chapter 16. The query processor is the group of components of a DBMS that turns 
user queries and data-modification commands into a sequence of database operations and executes those operations. Since SQL lets us express queries at a 
very high level, the query processor must supply much detail regarding how the 
query is to be executed. Moreover, a naive execution strategy for a query may 
take far more time than necessary.
Figure 15.1 suggests the division of topics between Chapters 15 and 16. 
In this chapter, we concentrate on query execution, that is, the algorithms 
that manipulate the data of the database. We focus on the operations of the 
extended relational algebra, described in Section 5.2. Because SQL uses a bag 
model, we also assume that relations are bags, and thus use the bag versions of 
the operators from Section 5.1.
We shall cover the principal methods for execution of the operations of relational algebra. These methods differ in their basic strategy; scanning, hashing, 
sorting, and indexing are the major approaches. The methods also differ on 
their assumption as to the amount of available main memory. Some algorithms 
assume that enough main memory is available to hold at least one of the relations involved in an operation. Others assume that the arguments of the 
operation are too big to fit in memory, and these algorithms have significantly 
different costs and structures.
P review o f Q uery C om pilation
To set the context for query execution, we offer a very brief outline of the 
content of the next chapter. Query compilation is divided into the three major 
steps shown in Fig. 15.2.
a) Parsing. A parse tree for the query is constructed.
b) Query Rewrite. The parse tree is converted to an initial query plan, which 
is usually an algebraic representation of the query. This initial plan is then
701
702 CHAPTER 15. QUERY EXECUTION
query
m etadata
Query 
com pilation 
(Chapter 16)
Query 
execution 
(Chapter 15)
query plan
data
Figure 15.1: The major parts of the query processor
transformed into an equivalent plan that is expected to require less time 
to execute.
c) Physical Plan Generation. The abstract query plan from (b), often called 
a logical query plan, is turned into a physical query plan by selecting 
algorithms to implement each of the operators of the logical plan, and by 
selecting an order of execution for these operators. The physical plan, like 
the result of parsing and the logical plan, is represented by an expression 
tree. The physical plan also includes details such as how the queried 
relations are accessed, and when and if a relation should be sorted.
Parts (b) and (c) are often called the query optimizer, and these are the hard 
parts of query compilation. To select the best query plan we need to decide:
1. Which of the algebraically equivalent forms of a query leads to the most 
efficient algorithm for answering the query?
2. For each operation of the selected form, what algorithm should we use to 
implement that operation?
3. How should the operations pass data from one to the other, e.g., in a 
pipelined fashion, in main-memory buffers, or via the disk?
Each of these choices depends on the metadata about the database. Typical 
metadata that is available to the query optimizer includes: the size of each 
relation; statistics such as the approximate number and frequency of different 
values for an attribute; the existence of certain indexes; and the layout of data 
on disk.
15.1. INTRODUCTION TO PHYSICAL-QUERY-PLAN OPERATORS 703
SQL query
Query
optim ization
Execute plan
Figure 15.2: Outline of query compilation
15.1 Introduction to Physical-Query-Plan
Operators
Physical query plans are built from operators, each of which implements one 
step of the plan. Often, the physical operators are particular implementations 
for one of the operations of relational algebra. However, we also need physical 
operators for other tasks that do not involve an operation of relational algebra. 
For example, we often need to “scan” a table, that is, bring into main memory 
each tuple of some relation. The relation is typically an operand of some other 
operation.
In this section, we shall introduce the basic building blocks of physical query 
plans. Later sections cover the more complex algorithms that implement operators of relational algebra efficiently; these algorithms also form an essential 
part of physical query plans. We also introduce here the “iterator” concept, 
which is an important method by which the operators comprising a physical 
query plan can pass requests for tuples and answers among themselves.
15.1.1 Scanning Tables
Perhaps the most basic thing we can do in a physical query plan is to read the 
entire contents of a relation R. A variation of this operator involves a simple 
predicate, where we read only those tuples of the relation R that satisfy the
704 CHAPTER 15. QUERY EXECUTION
predicate. There are two basic approaches to locating the tuples of a relation 
R.
1. In many cases, the relation R is stored in an area of secondary memory, 
with its tuples arranged in blocks. The blocks containing the tuples of R
are known to the system, and it is possible to get the blocks one by one. 
This operation is called table-scan.
2. If there is an index on any attribute of R, we may be able to use this index 
to get all the tuples of R. For example, a sparse index on R, as discussed 
in Section 14.1.3, can be used to lead us to all the blocks holding R, even if 
we don’t know otherwise which blocks these are. This operation is called 
index-scan.
We shall take up index-scan again in Section 15.6.2, when we talk about 
implementing selection. However, the important observation for now is that we 
can use the index not only to get all the tuples of the relation it indexes, but 
to get only those tuples that have a particular value (or sometimes a particular 
range of values) in the attribute or attributes that form the search key for the 
index.

DATABASE SYSTEMS
The Complete Book

DATABASE SYSTEMS
The Complete Book
Second Edition
Hector Garcia-Molina
Jeffrey D. Ullman
Jennifer Widom
Department of Computer Science
Stanford University
Upper Saddle River, New Jersey 07458
CD• 'l NOTICE
n This work is protected by U.S. copyright laws and is provided solely
for the use of college instructors in reviewing course materials for
classroom use. Dissemination or sale of this work, or any part
• (including on the World Wide Web), is not permitted.
Editorial Director, Computer Science and Engineering: Marcia J. Horton
Executive Editor Tracy Dunkelberger
Editorial Assistant: Melinda Haggerty
Director of Marketing: Margaret Waples
Marketing Manager: Christopher Kelly
Senior Managing Editor: Scott Disanno
Production Editor: Irwin Zucker
Art Director: Jayne Conte
Cover Designer: Margaret Kenselaar
Cover Art: Tamara L Newman
Manufacturing Buyer: Lisa McDowell
Manufacturing Manager: Alan Fischer
© 2009,2002 by Pearson Education Inc. 
Pearson Prentice Hall 
Pearson Education, Inc.
Upper Saddle River, NJ 07458
PEARSON
P re n tic o
H a ll
All rights reserved. No part of this book may be reproduced, in any form or by any means, without 
permission in writing from the publisher.
Pearson Prentice Hall™ is a trademark of Pearson Education, Inc.
The author and publisher of this book have used their best efforts in preparing this book. These efforts 
include the development, research, and testing of the theories and programs to determine their 
effectiveness. The author and publisher make no warranty of any kind, expressed or implied, with regard 
to these programs or the documentation contained in this book. The author and publisher shall not be 
liable in any event for incidental or consequential damages in connection with, or arising out of, the 
furnishing, performance, or use of these programs.
Printed in the United States of America 
10 987654321
ISBN D-13-bQb?Dl-fl
178-0-13-b0b?01-b
Pearson Education Ltd., London
Pearson Education Australia Pty. Ltd., Sydney
Pearson Education Singapore, Pte. Ltd.
Pearson Education North Asia Ltd., Hong Kong
Pearson Education Canada, Inc., Toronto
Pearson Educaci6n de Mexico, S.A. de C.V.
Pearson Education—Japan, Tokyo
Pearson Education Malaysia, Pte. Ltd.
Pearson Education, Inc., Upper Saddle River, New Jersey
Preface
This book covers the core of the material taught in the database sequence 
at Stanford. The introductory course, CS145, uses the first twelve chapters, 
and is designed for all students — those who want to use database systems 
as well as those who want to get involved in database implementation. The 
second course, CS245 on database implementation, covers most of the rest of 
the book. However, some material is covered in more detail in special topics 
courses. These include CS346 (implementation project), which concentrates on 
query optimization as in Chapters 15 and 16. Also, CS345A, on data mining 
and Web mining, covers the material in the last two chapters.
W hat’s N ew in the Second Edition
After a brief introduction in Chapter 1, we cover relational modeling in Chapters 
2-4. Chapter 4 is devoted to high-level modeling. There, in addition to the 
E /R model, we now cover UML (Unified Modeling Language). We also have 
moved to Chapter 4 a shorter version of the material on ODL, treating it as a 
design language for relational database schemas.
The material on functional and multivalued dependencies has been modified and remains in Chapter 3. We have changed our viewpoint, so that a 
functional dependency is assumed to have a set of attributes on the right. We 
have also given explicitly certain algorithms, including the “chase,” that allow 
us to manipulate dependencies. We have augmented our discussion of third 
normal form to include the 3NF synthesis algorithm and to make clear what 
the tradeoff between 3NF and BCNF is.
Chapter 5 contains the coverage of relational algebra from the previous 
edition, and is joined by (part of) the treatment of Datalog from the old Chapter 10. The discussion of recursion in Datalog is either moved to the book’s 
Web site or combined with the treatment of recursive SQL in Chapter 10 of 
this edition.
Chapters 6-10 are devoted to aspects of SQL programming, and they represent a reorganization and augmentation of the earlier book’s Chapters 6, 7, 8, 
and parts of 10. The material on views and indexes has been moved to its own 
chapter, number 8, and this material has been augmented with a discussion of
vi PREFACE
important new topics, including materialized views, and automatic selection of 
indexes.
The new Chapter 9 is based on the old Chapter 8 (embedded SQL). It is 
introduced by a new section on 3-tier architecture. It also includes an expanded 
discussion of JDBC and new coverage of PHP.
Chapter 10 collects a number of advanced SQL topics. The discussion of 
authorization from the old Chapter 8 has been moved here, as has the discussion 
of recursive SQL from the old Chapter 10. Data cubes, from the old Chapter 20, 
are now covered here. The rest of the chapter is devoted to the nested-relation 
model (from the old Chapter 4) and object-relational features of SQL (from the 
old Chapter 9).
Then, Chapters 11 and 12 cover XML and systems based on XML. Except for material at the end of the old Chapter 4, which has been moved to 
Chapter 11, this material is all new. Chapter 11 covers modeling; it includes 
expanded coverage of DTD’s, along with new material on XML Schema. Chapter 12 is devoted to programming, and it includes sections on XPath, XQuery, 
and XSLT.
Chapter 13 begins the study of database implementation. It covers disk 
storage and the file structures that are built on disks. This chapter is a condensation of material that, in the first edition, occupied Chapters 11 and 12.
Chapter 14 covers index structures, including B-trees, hashing, and structures for multidimensional indexes. This material also condenses two chapters, 
13 and 14, from the first edition.
Chapters 15 and 16 cover query execution and query optimization, respectively. They are similar to the old chapters of the same numbers. Chapter 17 
covers logging, and Chapter 18 covers concurrency control; these chapters are 
also similar to the old chapters with the same numbers. Chapter 19 contains 
additional topics on concurrency: recovery, deadlocks, and long transactions. 
This material is a subset of the old Chapter 19.
Chapter 20 is on parallel and distributed databases. In addition to material 
on parallel query execution from the old Chapter 15 and material on distributed 
locking and commitment from the old Chapter 19, there are several new sections on distributed query execution: the map-reduce framework for parallel 
computation, peer-to-peer databases and their implementation of distributed 
hash tables.
Chapter 21 covers information integration. In addition to material on this 
subject from the old Chapter 20, we have added a section on local-as-view mediators and a section on entity resolution (finding records from several databases 
that refer to the same entity, e.g., a person).
Chapter 22 is on data mining. Although there was some material on the 
subject in the old Chapter 20, almost all of this chapter is new. It covers association rules and frequent itemset mining, including both the famous A-Priori 
Algorithm and certain efficiency improvements. Chapter 22 includes the key 
techniques of shingling, minhashing, and locality-sensitive hashing for finding 
similar items in massive databases, e.g., Web pages that quote substantially
PREFACE vii
from other Web pages. The chapter concludes with a study of clustering, especially for massive datasets.
Chapter 23, all new, addresses two important ways in which the Internet 
has impacted database technology. First is search engines, where we discuss 
algorithms for crawling the Web, the well-known PageRank algorithm for evaluating the importance of Web pages, and its extensions. This chapter also 
covers data-stream-management systems. We discuss the stream data model 
and SQL language extensions, and conclude with several interesting algorithms 
for executing queries on streams.
Prerequisites
We have used the book at the “mezzanine” level, in a sequence of courses 
taken both by undergraduates and by beginning graduate students. The formal 
prerequisites for the course are Sophomore-level treatments of:
1. Data structures, algorithms, and discrete math, and
2. Software systems, software engineering, and programming languages.
Of this material, it is important that students have at least a rudimentary understanding of such topics as: algebraic expressions and laws, logic, basic data 
structures, object-oriented programming concepts, and programming environments. However, we believe that adequate background is acquired by the Junior 
year of a typical computer science program.
Exercises
The book contains extensive exercises, with some for almost every section. We 
indicate harder exercises or parts of exercises with an exclamation point. The 
hardest exercises have a double exclamation point.
Support on the World W ide Web
The book’s home page is
http://infolab.Stanford.edu/~ullman/dscb.html
You will find errata as we learn of them, and backup materials, including homeworks, projects, and exams. We shall also make available there the sections from 
the first edition that have been removed from the second.
In addition, there is an accompanying set of on-line homeworks and programming labs using a technology developed by Gradiance Corp. See the section following the Preface for details about the GOAL system. GOAL service
viii PREFACE
can be purchased at http://w w w .prenliall.com /goal. Instructors who want 
to use the system in their classes should contact their Prentice-Hall representative or request instructor authorization through the above Web site.
There is a solutions manual for instructors available at
h t t p ://www.p re n h a ll. com/ullman 
This page also gives you access to GOAL and all book materials.
Acknowledgements
We would like to thank Donald Kossmann for helpful discussions, especially concerning XML and its associated programming systems. Also, Bobbie Cochrane 
assisted us in understanding trigger semantics for a earlier edition.
A large number of people have helped us, either with the development of this 
book or its predecessors, or by contacting us with errata in the books and/or 
other Web-based materials. It is our pleasure to acknowledge them all here.
Marc Abromowitz, Joseph H. Adamski, Brad Adelberg, Gleb Ashimov, Donald Aingworth, Teresa Almeida, Brian Babcock, Bruce Baker, Yunfan Bao, 
Jonathan Becker, Margaret Benitez, Eberhard Bertsch, Larry Bonham, Phillip 
Bonnet, David Brokaw, Ed Burns, Alex Butler, Karen Butler, Mike Carey, 
Christopher Chan, Sudarshan Chawathe.
Also Per Christensen, Ed Chang, Surajit Chaudhuri, Ken Chen, Rada 
Chirkova, Nitin Chopra, Lewis Church, Jr., Bobbie Cochrane, Michael Cole, 
Alissa Cooper, Arturo Crespo, Linda DeMichiel, Matthew F. Dennis, Tom 
Dienstbier, Pearl D’Souza, Oliver Duschka, Xavier Faz, Greg Fichtenholtz, Bart 
Fisher, Simon Frettloeh, Jarl Friis.
Also John Fry, Chiping Fu, Tracy Fujieda, Prasanna Ganesan, Suzanne 
Garcia, Mark Gjol, Manish Godara, Seth Goldberg, Jeff Goldblat, Meredith 
Goldsmith, Luis Gravano, Gerard Guillemette, Himanshu Gupta, Petri Gynther, Zoltan Gyongyi, Jon Heggland, Rafael Hernandez, Masanori Higashihara, 
Antti Hjelt, Ben Holtzman, Steve Huntsberry.
Also Sajid Hussain, Leonard Jacobson, Thulasiraman Jeyaraman, Dwight 
Joe, Brian Jorgensen, Mathew P. Johnson, Sameh Kamel, Jawed Karim, Seth 
Katz, Pedram Keyani, Victor Kimeli, Ed Knorr, Yeong-Ping Koh, David Koller, 
Gyorgy Kovacs, Phillip Koza, Brian Kulman, Bill Labiosa, Sang Ho Lee, Younghan Lee, Miguel Licona.
Also Olivier Lobry, Chao-Jun Lu, Waynn Lue, John Manz, Arun Marathe, 
Philip Minami, Le-Wei Mo, Fabian Modoux, Peter Mork, Mark Mortensen, 
Ramprakash Narayanaswami, Hankyung Na, Mor Naaman, Mayur Naik, Marie 
Nilsson, Torbjorn Norbye, Chang-Min Oh, Mehul Patel, Soren Peen, Jian Pei.
Also Xiaobo Peng, Bert Porter, Limbek Reka, Prahash Ramanan, Nisheeth 
Ranjan, Suzanne Rivoire, Ken Ross, Tim Roughgarten, Mema Roussopoulos, Richard Scherl, Loren Shevitz, Shrikrishna Shrin, June Yoshiko Sison,
PREFACE ix
Man Cho A. So, Elizabeth Stinson, Qi Su, Ed Swierk, Catherine Tornabene, 
Anders Uhl, Jonathan Ullman, Mayank Upadhyay.
Also Anatoly Varakin, Vassilis Vassalos, Krishna Venuturimilli, Vikram Vijayaraghavan, Terje Viken, Qiang Wang, Steven Whang, Mike Wiacek, Kristian 
Widjaja, Janet Wu, Sundar Yamunachari, Takeshi Yokukawa, Bing Yu, Min-Sig 
Yun, Torben Zahle, Sandy Zhang.
The remaining errors are ours, of course.
H. G.-M.
J. D. U.
J. W.
Stanford, CA 
March, 2008
X
GOAL
Gradiance Online Accelerated Learning (GOAL) is Pearson’s premier online 
homework and assessment system. GOAL is designed to minimize student frustration while providing an interactive teaching experience outside the classroom. 
(Visit www.prenhall.com/goal for a demonstration and additional information.)
With GOAL’s immediate feedback and book-specific hints and pointers, 
students will have a more efficient and effective learning experience. GOAL 
delivers immediate assessment and feedback via two kinds of assignments: multiple choice homework exercises and interactive lab projects.
The homework consists of a set of multiple choice questions designed to test 
student knowledge of a solved problem. When answers are graded as incorrect, 
students are given a hint and directed back to a specific section in the course 
textbook for helpful information. Note: Students that are not enrolled in a 
class may want to enroll in a “Self-Study Course” that allows them to complete 
the homework exercises on their own.
Unlike syntax checkers and compilers, GOAL’s lab projects check for both 
syntactic and semantic errors. GOAL determines if the student’s program runs 
but more importantly, when checked against a hidden data set, verifies that it 
returns the correct result. By testing the code and providing immediate feedback, GOAL lets you know exactly which concepts the students have grasped 
and which ones need to be revisited.
In addition, the GOAL package specific to this book includes programming 
exercises in SQL and XQuery. Submitted queries are tested for correctness and 
incorrect results lead to examples of where the query goes wrong. Students can 
try as many times as they like but writing queries that respond correctly to the 
examples is not sufficient to get credit for the problem.
Instructors should contact their local Pearson Sales Representative for sales 
and ordering information for the GOAL Student Access Code and textbook 
value package.
About the Authors
HECTOR GARCIA-MOLINA is the L. Bosack and S. Lerner Professor of Computer Science and Electrical Engineering at Stanford University. His research 
interests include digital libraries, information integration, and database application on the Internet. He was a recipient of the SIGMOD Innovations Award and 
a member of PITAC (President’s Information-Technology Advisory Council). 
He currently serves on the Board of Directors of Oracle Corp.
JEFFREY D. ULLMAN is the Stanford W. Ascherman Professor of Computer 
Science (emeritus) at Stanford University. He is the author or co-author of 
16 books, including Elements of ML Programming (Prentice Hall 1998). His 
research interests include data mining, information integration, and electronic 
education. He is a member of the National Academy of Engineering, and recipient of a Guggenheim Fellowship, the Karl V. Karlstrom Outstanding Educator 
Award, the SIGMOD Contributions and Edgar F. Codd Innovations Awards, 
and the Knuth Prize.
JENNIFER WIDOM is Professor of Computer Science and Electrical Engineering at Stanford University. Her research interests span many aspects of 
nontraditional data management. She is an ACM Fellow and a member of the 
National Academy of Engineering, she received the ACM SIGMOD Edgar F. 
Codd Innovations Award in 2007 and was a Guggenheim Fellow in 2000, and she 
has served on a variety of program committees, advisory boards, and editorial 
boards.

Table of Contents
1 T h e W orlds o f D atabase S ystem s 1
1.1 The Evolution of Database Systems ............................................... 1
1.1.1 Early Database Management S y ste m s............................... 2
1.1.2 Relational Database S y ste m s............................................... 3
1.1.3 Smaller and Smaller S y ste m s............................................... 3
1.1.4 Bigger and Bigger S y s te m s ................................................... 4
1.1.5 Information In te g ra tio n ......................................................... 4
1.2 Overview of a Database Management S y s te m ................................ 5
1.2.1 Data-Definition Language Commands ................................ 5
1.2.2 Overview of Query Processing............................................... 5
1.2.3 Storage and Buffer M an ag em en t......................................... 7
1.2.4 Transaction Processing............................................................ 8
1.2.5 The Query Processor............................................................... 9
1.3 Outline of Database-System S tu d ie s ............................................... 10
1.4 References for Chapter 1 ..................................................................... 12
1 Relational Database Modeling 15
2 T he R elation al M od el o f D ata 17
2.1 An Overview of Data M o d e ls............................................................ 17
2.1.1 What is a Data M o d e l? ......................................................... 17
2.1.2 Important Data M o d els......................................................... 18
2.1.3 The Relational Model in B rief............................................... 18
2.1.4 The Semistructured Model in B rief...................................... 19
2.1.5 Other Data M odels.................................................................. 20
2.1.6 Comparison of Modeling Approaches................................... 21
2.2 Basics of the Relational Model .........................................................21
2.2.1 A ttributes.................................................................................. 22
2.2.2 Schem as..................................................................................... 22
2.2.3 T u p les........................................................................................ 22
2.2.4 Domains..................................................................................... 23
2.2.5 Equivalent Representations of a Relation ......................... 23
xiii
2.2.6 Relation In stan c e s................................................................. 24
2.2.7 Keys of Relations.................................................................... 25
2.2.8 An Example Database S ch em a ........................................... 26
2.2.9 Exercises for Section 2 .2 ........................................................ 28
2.3 Defining a Relation Schema in SQ L.................................................. 29
2.3.1 Relations in S Q L .................................................................... 29
2.3.2 Data T y p e s.............................................................................. 30
2.3.3 Simple Table Declarations..................................................... 31
2.3.4 Modifying Relation Schemas ............................................... 33
2.3.5 Default V a lu e s....................................................................... 34
2.3.6 Declaring K e y s ....................................................................... 34
2.3.7 Exercises for Section 2 .3 ........................................................ 36
2.4 An Algebraic Query Language ........................................................ 38
2.4.1 Why Do We Need a Special Query Language?...................38
2.4.2 What is an A lgebra?.............................................................. 38
2.4.3 Overview of Relational A lgebra........................................... 39
2.4.4 Set Operations on Relations.................................................. 39
2.4.5 Projection.................................................................................41
2.4.6 Selection .................................................................................42
2.4.7 Cartesian P r o d u c t................................................................. 43
2.4.8 Natural J o in s.......................................................................... 43
2.4.9 Theta-Joins..............................................................................45
2.4.10 Combining Operations to Form Q u e ries............................47
2.4.11 Naming and Renaming...........................................................49
2.4.12 Relationships Among O perations........................................ 50
2.4.13 A Linear Notation for Algebraic E x p ressio n s...................51
2.4.14 Exercises for Section 2 .4 ........................................................ 52
2.5 Constraints on R elations.................................................................... 58
2.5.1 Relational Algebra as a Constraint L anguage...................59
2.5.2 Referential Integrity C o n strain ts........................................ 59
2.5.3 Key Constraints .................................................................... 60
2.5.4 Additional Constraint E x am p les........................................ 61
2.5.5 Exercises for Section 2 .5 ........................................................ 62
2.6 Summary of Chapter 2 ....................................................................... 63
2.7 References for Chapter 2 .................................................................... 65
3 Design T heory for R elational D atabases 67
3.1 Functional Dependencies.................................................................... 67
3.1.1 Definition of Functional Dependency.................................. 68
3.1.2 Keys of Relations.................................................................... 70
3.1.3 Superkeys................................................................................. 71
3.1.4 Exercises for Section 3 .1 ........................................................ 71
3.2 Rules About Functional D ependencies........................................... 72
3.2.1 Reasoning About Functional D ependencies...................... 72
3.2.2 The Splitting/Combining R u l e ............................................ 73
xiv TABLE OF CONTENTS
TABLE OF CONTENTS xv
3.2.3 Trivial Functional Dependencies ......................................... 74
3.2.4 Computing the Closure of A ttributes................................... 75
3.2.5 Why the Closure Algorithm W orks...................................... 77
3.2.6 The Transitive R u l e ............................................................... 79
3.2.7 Closing Sets of Functional Dependencies............................ 80
3.2.8 Projecting Functional D ependencies...................................81
3.2.9 Exercises for Section 3 .2 .........................................................83
3.3 Design of Relational Database Schemas .........................................85
3.3.1 Anomalies..................................................................................86
3.3.2 Decomposing Relations .........................................................86
3.3.3 Boyce-Codd Normal F o rm ......................................................88
3.3.4 Decomposition into BCN F......................................................89
3.3.5 Exercises for Section 3 .3 .........................................................92
3.4 Decomposition: The Good, Bad, and U gly......................................93
3.4.1 Recovering Information from a Decomposition ................94
3.4.2 The Chase Test for Lossless J o i n .........................................96
3.4.3 Why the Chase W orks............................................................99
3.4.4 Dependency P reserv atio n ......................................................100
3.4.5 Exercises for Section 3 .4 .........................................................102
3.5 Third Normal Form ............................................................................102
3.5.1 Definition of Third Normal F o rm .........................................102
3.5.2 The Synthesis Algorithm for 3NF Schemas ......................103
3.5.3 Why the 3NF Synthesis Algorithm W o rk s......................... 104
3.5.4 Exercises for Section 3 .5 .........................................................105
3.6 Multivalued Dependencies..................................................................105
3.6.1 Attribute Independence and Its Consequent Redundancy 106
3.6.2 Definition of Multivalued D ependencies............................ 107
3.6.3 Reasoning About Multivalued Dependencies......................108
3.6.4 Fourth Normal F o rm ...............................................................110
3.6.5 Decomposition into Fourth Normal Form .........................I l l
3.6.6 Relationships Among Normal F o rm s...................................113
3.6.7 Exercises for Section 3 .6 .........................................................113
3.7 An Algorithm for Discovering MVD’s ............................................115
3.7.1 The Closure and the C h a s e .................................................. 115
3.7.2 Extending the Chase to MVD’s ............................................116
3.7.3 Why the Chase Works for MVD’s ......................................118
3.7.4 Projecting MVD’s .................................................................. 119
3.7.5 Exercises for Section 3 .7 .........................................................120
3.8 Summary of Chapter 3 ........................................................................ 121
3.9 References for Chapter 3 ..................................................................... 122
4 H igh-Level D atabase M odels 125
4.1 The Entity/Relationship M odel.........................................................126
4.1.1 Entity S e t s .............................................................................. 126
4.1.2 A ttributes..................................................................................126
4.1.3 R elationships........................................................................... 127
4.1.4 Entity-Relationship Diagram s............................................... 127
4.1.5 Instances of an E /R D iagram ............................................... 128
4.1.6 Multiplicity of Binary E /R R elationships......................... 129
4.1.7 Multiway R elationships........................................................ 130
4.1.8 Roles in R elationships............................................................131
4.1.9 Attributes on R elationships.................................................. 134
4.1.10 Converting Multiway Relationships to B in ary ...................134
4.1.11 Subclasses in the E /R M o d e l...............................................135
4.1.12 Exercises for Section 4 .1 ........................................................ 138
4.2 Design Principles..................................................................................140
4.2.1 Faithfulness.............................................................................. 140
4.2.2 Avoiding R edundancy............................................................141
4.2.3 Simplicity Counts ..................................................................142
4.2.4 Choosing the Right Relationships.........................................142
4.2.5 Picking the Right Kind of E lem ent......................................144
4.2.6 Exercises for Section 4 .2 ........................................................ 145
4.3 Constraints in the E /R M odel............................................................148
4.3.1 Keys in the E /R M o d e l........................................................ 148
4.3.2 Representing Keys in the E /R Model ............................... 149
4.3.3 Referential In te g rity .................................................. ■ ■ • • 150
4.3.4 Degree C onstraints..................................................................151
4.3.5 Exercises for Section 4 .3 ........................................................ 151
4.4 Weak Entity S e ts ..................................................................................152
4.4.1 Causes of Weak Entity S e ts .................................................. 152
4.4.2 Requirements for Weak Entity S ets......................................153
4.4.3 Weak Entity Set N otation..................................................... 155
4.4.4 Exercises for Section 4 .4 ........................................................ 156
4.5 From E /R Diagrams to Relational Designs......................................157
4.5.1 From Entity Sets to Relations...............................................157
4.5.2 From E /R Relationships to Relations ............................... 158
4.5.3 Combining R elations...............................................................160
4.5.4 Handling Weak Entity S e t s .................................................. 161
4.5.5 Exercises for Section 4 .5 .........................................................163
4.6 Converting Subclass Structures to R elations.................................. 165
4.6.1 E/R-Style C onversion............................................................166
4.6.2 An Object-Oriented A p p ro a c h ............................................167
4.6.3 Using Null Values to Combine R elations............................ 168
4.6.4 Comparison of A p p ro ach es.................................................. 169
4.6.5 Exercises for Section 4 .6 ........................................................ 171
4.7 Unified Modeling L anguage...............................................................171
xvi TABLE OF CONTENTS
4.7.1 UML C la sses........................................................................... 172
4.7.2 Keys for UML c la s s e s ............................................................173
4.7.3 Associations...............................................................................173
4.7.4 Self-Associations..................................................................... 175
4.7.5 Association Classes.................................................................. 175
4.7.6 Subclasses in U M L .................................................................. 176
4.7.7 Aggregations and Compositions............................................ 177
4.7.8 Exercises for Section 4 .7 .........................................................179
4.8 From UML Diagrams to R e la tio n s.................................................. 179
4.8.1 UML-to-Relations Basics ..................................................... 179
4.8.2 From UML Subclasses to R elations......................................180
4.8.3 From Aggregations and Compositions to Relations .... 181
4.8.4 The UML Analog of Weak Entity S e ts............................... 181
4.8.5 Exercises for Section 4 .8 .........................................................183
4.9 Object Definition L anguage...............................................................183
4.9.1 Class D eclarations..................................................................184
4.9.2 Attributes in O D L ..................................................................184
4.9.3 Relationships in O D L ............................................................185
4.9.4 Inverse Relationships...............................................................186
4.9.5 Multiplicity of Relationships ............................................... 186
4.9.6 Types in ODL ........................................................................ 188
4.9.7 Subclasses in O D L ..................................................................190
4.9.8 Declaring Keys in O D L .........................................................191
4.9.9 Exercises for Section 4 .9 .........................................................192
4.10 From ODL Designs to Relational D e sig n s......................................193
4.10.1 From ODL Classes to Relations............................................193
4.10.2 Complex Attributes in C la s s e s ............................................194
4.10.3 Representing Set-Valued Attributes ...................................195
4.10.4 Representing Other Type Constructors............................... 196
4.10.5 Representing ODL R elationships.........................................198
4.10.6 Exercises for Section 4 .1 0 ..................................................... 198
4.11 Summary of Chapter 4 ........................................................................ 200
4.12 References for Chapter 4 ..................................................................... 202
II Relational Database Programming 203
5 A lgebraic and Logical Q uery Languages 205
5.1 Relational Operations on B a g s .........................................................205
5.1.1 Why B a g s ? ...............................................................................206
5.1.2 Union, Intersection, and Difference of B a g s...................... 207
5.1.3 Projection of B a g s ..................................................................208
5.1.4 Selection on B ags..................................................................... 209
5.1.5 Product of Bags ..................................................................... 210
5.1.6 Joins of B a g s........................................................................... 210
TABLE OF CONTENTS xvii
TABLE OF CONTENTS
5.1.7 Exercises for Section 5 .1 ........................................................ 212
5.2 Extended Operators of Relational A lgebra......................................213
5.2.1 Duplicate E lim ination............................................................214
5.2.2 Aggregation O perators............................................................214
5.2.3 G ro u p in g ..................................................................................215
5.2.4 The Grouping O p e ra to r........................................................ 216
5.2.5 Extending the Projection O perator......................................217
5.2.6 The Sorting O p e ra to r............................................................219
5.2.7 Outerjoins................................................................................. 219
5.2.8 Exercises for Section 5 .2 ........................................................ 222
5.3 A Logic for Relations........................................................................... 222
5.3.1 Predicates and A to m s ............................................................223
5.3.2 Arithmetic A to m s ..................................................................223
5.3.3 Datalog Rules and Q u e rie s .................................................. 224
5.3.4 Meaning of Datalog R u les..................................................... 225
5.3.5 Extensional and Intensional Predicates............................... 228
5.3.6 Datalog Rules Applied to B a g s ............................................228
5.3.7 Exercises for Section 5 .3 ........................................................ 230
5.4 Relational Algebra and D atalog.........................................................230
5.4.1 Boolean Operations ...............................................................231
5.4.2 Projection................................................................................. 232
5.4.3 Selection ................................................................................. 232
5.4.4 P ro d u c t.................................................................................... 235
5.4.5 Jo in s...........................................................................................235
5.4.6 Simulating Multiple Operations with D atalo g ...................236
5.4.7 Comparison Between Datalog and Relational Algebra . . 238
5.4.8 Exercises for Section 5 .4 ........................................................ 238
5.5 Summary of Chapter 5 ........................................................................ 240
5.6 References for Chapter 5 .....................................................................241
T he D atabase Language SQL 243
6.1 Simple Queries in S Q L ........................................................................244
6.1.1 Projection in S Q L ..................................................................246
6.1.2 Selection in S Q L .....................................................................248
6.1.3 Comparison of S trin g s............................................................250
6.1.4 Pattern Matching in S Q L ..................................................... 250
6.1.5 Dates and T im e s.....................................................................251
6.1.6 Null Values and Comparisons Involving NULL...................252
6.1.7 The Truth-Value UNKNOWN..................................................... 253
6.1.8 Ordering the O u tp u t.................................. ............................255
6.1.9 Exercises for Section 6 .1 ........................................................ 256
6.2 Queries Involving More Than One R e la tio n ...................................258
6.2.1 Products and Joins in S Q L .................................................. 259
6.2.2 Disambiguating Attributes .................................................. 260
6.2.3 Tuple Variables........................................................................261
6.2.4 Interpreting Multirelation Q u e rie s ......................................262
6.2.5 Union, Intersection, and Difference of Q ueries...................265
6.2.6 Exercises for Section 6 .2 ........................................................ 267
6.3 Subqueries.............................................................................................. 268
6.3.1 Subqueries that Produce Scalar Values............................... 269
6.3.2 Conditions Involving R ela tio n s............................................270
6.3.3 Conditions Involving T uples.................................................. 271
6.3.4 Correlated Subqueries............................................................273
6.3.5 Subqueries in FROM C la u se s.................................................. 274
6.3.6 SQL Join Expressions............................................................275
6.3.7 Natural J o in s ........................................................................... 276
6.3.8 Outerjoins..................................................................................277
6.3.9 Exercises for Section 6 .3 ........................................................ 279
6.4 Full-Relation O perations.....................................................................281
6.4.1 Eliminating Duplicates............................................................281
6.4.2 Duplicates in Unions, Intersections, and Differences . . . 282
6.4.3 Grouping and Aggregation in S Q L ......................................283
6.4.4 Aggregation O perators............................................................284
6.4.5 G ro u p in g ..................................................................................285
6.4.6 Grouping, Aggregation, and Nulls ......................................287
6.4.7 HAVING C lauses........................................................................ 288
6.4.8 Exercises for Section 6 .4 ........................................................ 289
6.5 Database Modifications .....................................................................291
6.5.1 Insertion.....................................................................................291
6.5.2 D eletion.....................................................................................292
6.5.3 U p d ates.....................................................................................294
6.5.4 Exercises for Section 6 .5 ........................................................ 295
6.6 Transactions in S Q L ........................................................................... 296
6.6.1 Serializability........................................................................... 296
6.6.2 A tom icity..................................................................................298
6.6.3 Transactions ........................................................................... 299
6.6.4 Read-Only Transactions........................................................ 300
6.6.5 Dirty R ead s.............................................................................. 302
6.6.6 Other Isolation L ev els............................................................304
6.6.7 Exercises for Section 6 .6 ........................................................ 306
6.7 Summary of Chapter 6 ........................................................................ 307
6.8 References for Chapter 6 .....................................................................308
7 C on strain ts and Triggers 311
7.1 Keys and Foreign K eys........................................................................ 311
7.1.1 Declaring Foreign-Key C onstraints......................................312
7.1.2 Maintaining Referential In teg rity .........................................313
7.1.3 Deferred Checking of C onstraints.........................................315
7.1.4 Exercises for Section 7 .1 ........................................................ 318
7.2 Constraints on Attributes and Tuples...............................................319
TABLE OF CONTENTS xix
TABLE OF CONTENTS
7.2.1 Not-Null Constraints..............................................................319
7.2.2 Attribute-Based CHECK C onstraints..................................... 320
7.2.3 Tuple-Based CHECK C onstraints........................................... 321
7.2.4 Comparison of Tuple- and Attribute-Based Constraints . 323
7.2.5 Exercises for Section 7 .2 ........................................................323
7.3 Modification of C o n strain ts................................................. ... 325
7.3.1 Giving Names to C onstraints.............................................. 325
7.3.2 Altering Constraints on T a b le s........................................... 326
7.3.3 Exercises for Section 7 .3 ........................................................327
7.4 A ssertions.............................................................................................328
7.4.1 Creating Assertions ..............................................................328
7.4.2 Using A ssertions....................................................................329
7.4.3 Exercises for Section 7 .4 ........................................................330
7.5 T riggers................................................................................................332
7.5.1 Triggers in SQ L.......................................................................332
7.5.2 The Options for Trigger D esign........................................... 334
7.5.3 Exercises for Section 7 .5 ........................................................337
7.6 Summary of Chapter 7 .......................................................................339
7.7 References for Chapter 7 ....................................................................339
Views and Indexes 341
8.1 Virtual V iew s.......................................................................................341
8.1.1 Declaring Views .................................................................... 341
8.1.2 Querying Views.......................................................................343
8.1.3 Renaming A ttributes..............................................................343
8.1.4 Exercises for Section 8 .1 ........................................................344
8.2 Modifying V ie w s................................................................................ 344
8.2.1 View Removal ....................................................................... 345
8.2.2 Updatable V iew s.................................................................... 345
8.2.3 Instead-Of Triggers on V iew s.............................................. 347
8.2.4 Exercises for Section 8 .2 ........................................................349
8.3 Indexes in S Q L ................................................................................... 350
8.3.1 Motivation for Indexes...........................................................350
8.3.2 Declaring Indexes.................................................................... 351
8.3.3 Exercises for Section 8 .3 ........................................................352
8.4 Selection of Indexes .......................................................................... 352
8.4.1 A Simple Cost Model ...........................................................352
8.4.2 Some Useful Indexes..............................................................353
8.4.3 Calculating the Best Indexes to C reate...............................355
8.4.4 Automatic Selection of Indexes to C r e a te .........................357
8.4.5 Exercises for Section 8 .4 ........................................................359
8.5 Materialized V iew s............................................................................. 359
8.5.1 Maintaining a Materialized V ie w ........................................ 360
8.5.2 Periodic Maintenance of Materialized Views......................362
8.5.3 Rewriting Queries to Use Materialized V ie w s...................362
8.5.4 Automatic Creation of Materialized V iew s......................... 364
8.5.5 Exercises for Section 8 .5 .........................................................365
8.6 Summary of Chapter 8 .........................................................................366
8.7 References for Chapter 8 ..................................................................... 367
9 SQL in a Server E nvironm ent 369
9.1 The Three-Tier Architecture ............................................................369
9.1.1 The Web-Server T ie r............................................................... 370
9.1.2 The Application T ier............................................................... 371
9.1.3 The Database T i e r .................................................................. 372
9.2 The SQL Environm ent.........................................................................372
9.2.1 Environments............................................................................373
9.2.2 Schem as..................................................................................... 374
9.2.3 Catalogs..................................................................................... 375
9.2.4 Clients and Servers in the SQL E n v iro n m en t...................375
9.2.5 Connections...............................................................................376
9.2.6 Sessions..................................................................................... 377
9.2.7 M odules..................................................................................... 378
9.3 The SQL/Host-Language In terface...................................................378
9.3.1 The Impedance Mismatch Problem ......................................380
9.3.2 Connecting SQL to the Host Language................................380
9.3.3 The DECLARE Section............................................................... 381
9.3.4 Using Shared Variables .........................................................382
9.3.5 Single-Row Select S tatem ents............................................... 383
9.3.6 C u rs o rs ..................................................................................... 383
9.3.7 Modifications by C u rso r.........................................................386
9.3.8 Protecting Against Concurrent U p d a te s............................ 387
9.3.9 Dynamic SQ L ............................................................................388
9.3.10 Exercises for Section 9 .3 .........................................................390
9.4 Stored P ro c e d u re s...............................................................................391
9.4.1 Creating PSM Functions and Procedures ......................... 391
9.4.2 Some Simple Statement Forms in P S M ................................392
9.4.3 Branching S ta tem en ts............................................................394
9.4.4 Queries in P S M .........................................................................395
9.4.5 Loops in PSM .........................................................................396
9.4.6 For-Loops.................................................................................. 398
9.4.7 Exceptions in P S M .................................................................. 400
9.4.8 Using PSM Functions and P ro ced u res................................402
9.4.9 Exercises for Section 9 .4 .........................................................402
9.5 Using a Call-Level In terface............................................................... 404
9.5.1 Introduction to S Q L /C L I......................................................405
9.5.2 Processing S tatem ents............................................................ 407
9.5.3 Fetching Data From a Query R e s u lt...................................408
9.5.4 Passing Parameters to Q u e rie s ............................................ 410
9.5.5 Exercises for Section 9 .5 .........................................................412
TABLE OF CONTENTS xxi
9.6 J D B C .................................................................................................... 412
9.6.1 Introduction to J D B C ............................................................412
9.6.2 Creating Statements in JD B C...............................................413
9.6.3 Cursor Operations in JD B C ..................................................415
9.6.4 Parameter P assin g ........................................................ ... 416
9.6.5 Exercises for Section 9 .6 ........................................................ 416
9.7 P H P ....................................................................................................... 416
9.7.1 PHP B asics.............................................................................. 417
9.7.2 A rrays........................................................................................418
9.7.3 The PEAR DB L ib ra r y ........................................................ 419
9.7.4 Creating a Database Connection Using D B ......................419
9.7.5 Executing SQL S ta te m e n ts.................................................. 419
9.7.6 Cursor Operations in PHP .................................................. 420
9.7.7 Dynamic SQL in P H P ............................................................421
9.7.8 Exercises for Section 9 .7 .........................................................422
9.8 Summary of Chapter 9 ........................................................................ 422
9.9 References for Chapter 9 .....................................................................423
10 A dvanced Topics in R elational D atabases 425
10.1 Security and User Authorization in S Q L .........................................425
10.1.1 Privileges..................................................................................426
10.1.2 Creating Privileges..................................................................427
10.1.3 The Privilege-Checking Process............................................428
10.1.4 Granting Privileges..................................................................430
10.1.5 Grant Diagrams .....................................................................431
10.1.6 Revoking Privileges ...............................................................433
10.1.7 Exercises for Section 1 0 .1 ..................................................... 436
10.2 Recursion in S Q L ..................................................................................437
10.2.1 Defining Recursive Relations in S Q L ...................................437
10.2.2 Problematic Expressions in Recursive SQL ......................440
10.2.3 Exercises for Section 1 0 .2 ..................................................... 443
10.3 The Object-Relational M o d e l............................................................445
10.3.1 From Relations to Object-Relations .................................. 445
10.3.2 Nested R elatio n s.....................................................................446
10.3.3 References..................................................................................447
10.3.4 Object-Oriented Versus Object-Relational.........................449
10.3.5 Exercises for Section 1 0 .3 ..................................................... 450
10.4 User-Defined Types in S Q L ...............................................................451
10.4.1 Defining Types in SQ L ............................................................451
10.4.2 Method Declarations in UDT’s ............................................452
10.4.3 Method Definitions..................................................................453
10.4.4 Declaring Relations with a U D T .........................................454
10.4.5 References..................................................................................454
10.4.6 Creating Object ID’s for T ables............................................455
10.4.7 Exercises for Section 1 0 .4 ..................................................... 457
xxii TABLE OF CONTENTS
TABLE OF CONTENTS xxiii
10.5 Operations on Object-Relational D a t a ............................................ 457
10.5.1 Following References...............................................................457
10.5.2 Accessing Components of Tuples with a U D T ...................458
10.5.3 Generator and Mutator F u n c tio n s......................................460
10.5.4 Ordering Relationships on UDT’s .........................................461
10.5.5 Exercises for Section 1 0 .5 ......................................................463
10.6 On-Line Analytic Processing ............................................................464
10.6.1 OLAP and Data W arehouses............................................... 465
10.6.2 OLAP Applications ...............................................................465
10.6.3 A Multidimensional View of OLAP D a t a ......................... 466
10.6.4 Star Schem as........................................................................... 467
10.6.5 Slicing and D ic in g .................................................................. 469
10.6.6 Exercises for Section 1 0 .6 ..................................................... 472
10.7 Data C u b e s ........................................................................................... 473
10.7.1 The Cube O p e ra to r...............................................................473
10.7.2 The Cube Operator in S Q L .................................................. 475
10.7.3 Exercises for Section 1 0 .7 ......................................................477
10.8 Summary of Chapter 1 0 ..................................................................... 478
10.9 References for Chapter 1 0 .................................................................. 480
III Modeling and Programming for Semistructured
Data 481
11 T he S em istru ctu red -D ata M odel 483
11.1 Semistructured D a ta ............................................................................483
11.1.1 Motivation for the Semistructured-Data M o d e l................483
11.1.2 Semistructured Data R epresentation...................................484
11.1.3 Information Integration Via Semistructured D a ta .............486
11.1.4 Exercises for Section 1 1 .1 ......................................................487
11.2 X M L ........................................................................................................488
11.2.1 Semantic T a g s ........................................................................ 488
11.2.2 XML With and Without a Schem a......................................489
11.2.3 Well-Formed X M L .................................................................. 489
11.2.4 A ttributes..................................................................................490
11.2.5 Attributes That Connect Elem ents......................................491
11.2.6 Namespaces...............................................................................493
11.2.7 XML and D atabases...............................................................493
11.2.8 Exercises for Section 1 1 .2 ......................................................495
11.3 Document Type D efinitions...............................................................495
11.3.1 The Form of a D T D ...............................................................495
11.3.2 Using a D T D ........................................................................... 499
11.3.3 Attribute L i s t s ........................................................................ 499
11.3.4 Identifiers and References......................................................500
11.3.5 Exercises for Section 1 1 .3 ......................................................502
xxiv TABLE OF CONTENTS
11A XML S chem a.......................................................................................502
11.4.1 The Form of an XML Schema.............................................. 502
11.4.2 E le m e n ts................................................................................ 503
11.4.3 Complex T ypes....................................................................... 504
11.4.4 A ttributes................................................................................ 506
11.4.5 Restricted Simple T ypes........................................................507
11.4.6 Keys in XML S ch em a...........................................................509
11.4.7 Foreign Keys in XML Schema.............................................. 510
11.4.8 Exercises for Section 1 1 .4 .....................................................512
11.5 Summary of Chapter 1 1 ....................................................................514
11.6 References for Chapter 1 1 .................................................................515
12 P rogram m ing Languages for XML 517
12.1 X P a th ...................................................................................................517
12.1.1 The XPath Data M o d el........................................................518
12.1.2 Document N odes....................................................................519
12.1.3 Path Expressions....................................................................519
12.1.4 Relative Path Expressions.....................................................521
12.1.5 Attributes in Path Expressions........................................... 521
12.1.6 A xes..........................................................................................521
12.1.7 Context of Expressions...........................................................522
12.1.8 W ildcards................................................................................ 523
12.1.9 Conditions in Path Expressions........................................... 523
12.1.10Exercises for Section 1 2 .1 .....................................................526
12.2 X Q u e ry ................................................................................................528
12.2.1 XQuery B a sic s.......................................................................530
12.2.2 FLWR Expressions.................................................................530
12.2.3 Replacement of Variables by Their V alues.........................534
12.2.4 Joins in X Q u e ry ....................................................................536
12.2.5 XQuery Comparison O perators........................................... 537
12.2.6 Elimination of D uplicates.....................................................538
12.2.7 Quantification in X Q u ery .....................................................539
12.2.8 Aggregations.......................................................................... 540
12.2.9 Branching in XQuery Expressions ..................................... 540
12.2.10 Ordering the Result of a Q uery........................................... 541
12.2.11 Exercises for Section 1 2 .2 .....................................................543
12.3 Extensible Stylesheet Language....................................................... 544
12.3.1 XSLT B a s ic s ..........................................................................544
12.3.2 Tem plates................................................................................ 544
12.3.3 Obtaining Values From XML D a ta ..................................... 545
12.3.4 Recursive Use of Tem plates..................................................546
12.3.5 Iteration in XSLT .................................................................549
12.3.6 Conditionals in X S L T ...........................................................551
12.3.7 Exercises for Section 1 2 .3 .....................................................551
12.4 Summary of Chapter 1 2 ....................................................................553
TABLE OF CONTENTS xxv
12.5 References for Chapter 1 2 .................................................................. 554
IV Database System Implementation 555
13 Secondary S torage M anagem ent 557
13.1 The Memory Hierarchy ..................................................................... 557
13.1.1 The Memory H ie ra rc h y .........................................................557
13.1.2 Transfer of Data Between L e v e ls.........................................560
13.1.3 Volatile and Nonvolatile S to r a g e .........................................560
13.1.4 Virtual Memory ..................................................................... 560
13.1.5 Exercises for Section 1 3 .1 ......................................................561
13.2 D isks........................................................................................................562
13.2.1 Mechanics of D isk s.................................................................. 562
13.2.2 The Disk C o n tro lle r...............................................................564
13.2.3 Disk Access C haracteristics.................................................. 564
13.2.4 Exercises for Section 1 3 .2 ............................... ......................567
13.3 Accelerating Access to Secondary S to ra g e ......................................568
13.3.1 The I/O Model of Computation .........................................568
13.3.2 Organizing Data by Cylinders............................................... 569
13.3.3 Using Multiple D isks...............................................................570
13.3.4 Mirroring D isks........................................................................ 571
13.3.5 Disk Scheduling and the Elevator Algorithm ...................571
13.3.6 Prefetching and Large-Scale B uffering............................... 573
13.3.7 Exercises for Section 1 3 .3 ..................................................... 573
13.4 Disk F a ilu re s............................................... ........................................ 575
13.4.1 Intermittent F ailures...............................................................576
13.4.2 C hecksum s...............................................................................576
13.4.3 Stable S to r a g e ........................................................................ 577
13.4.4 Error-Handling Capabilities of Stable S torage...................578
13.4.5 Recovery from Disk Crashes.................................................. 578
13.4.6 Mirroring as a Redundancy Technique............................... 579
13.4.7 Parity B lo ck s............................................................................580
13.4.8 An Improvement: RAID 5 ......................................................583
13.4.9 Coping With Multiple Disk C ra s h e s ...................................584
13.4.10Exercises for Section 1 3 .4 ......................................................587
13.5 Arranging Data on D is k ..................................................................... 590
13.5.1 Fixed-Length R ec o rd s............................................................590
13.5.2 Packing Fixed-Length Records into Blocks......................... 592
13.5.3 Exercises for Section 1 3 .5 ..................................................... 593
13.6 Representing Block and Record A ddresses......................................593
13.6.1 Addresses in Client-Server System s......................................593
13.6.2 Logical and Structured Addresses.........................................595
13.6.3 Pointer Swizzling..................................................................... 596
13.6.4 Returning Blocks to D i s k ......................................................600
xxvi TABLE OF CONTENTS
13.6.5 Pinned Records and B lo ck s..................................................600
13.6.6 Exercises for Section 1 3 .6 .....................................................602
13.7 Variable-Length Data and R eco rd s..................................................603
13.7.1 Records With Variable-Length Fields ............................... 604
13.7.2 Records With Repeating F ield s............................................605
13.7.3 Variable-Format Records .....................................................607
13.7.4 Records That Do Not Fit in a B lo c k .................................. 608
13.7.5 BLOBs ....................................................................................608
13.7.6 Column S to r e s....................................................................... 609
13.7.7 Exercises for Section 1 3 .7 .....................................................610
13.8 Record Modifications...........................................................................612
13.8.1 Insertion....................................................................................612
13.8.2 D eletion....................................................................................614
13.8.3 Update ....................................................................................615
13.8.4 Exercises for Section 1 3 .8 .....................................................615
13.9 Summary of Chapter 1 3 .................................................................... 615
13.10References for Chapter 1 3 ................................................................. 617
14 Index S tru ctu res 619
14.1 Index-Structure B asics........................................................................620
14.1.1 Sequential F iles........................................................................621
14.1.2 Dense Indexes...........................................................................621
14.1.3 Sparse In d e x e s....................................................................... 622
14.1.4 Multiple Levels of In d e x ........................................................623
14.1.5 Secondary In d e x es................................................................. 624
14.1.6 Applications of Secondary In d e x es..................................... 625
14.1.7 Indirection in Secondary In d ex es........................................ 626
14.1.8 Document Retrieval and Inverted In d ex es.........................628
14.1.9 Exercises for Section 1 4 .1 .....................................................631
14.2 B -T re e s................................................................................................ 633
14.2.1 The Structure of B -trees........................................................634
14.2.2 Applications of B-trees...........................................................637
14.2.3 Lookup in B -T rees................................................................. 639
14.2.4 Range Q u e rie s ....................................................................... 639
14.2.5 Insertion Into B -T rees...........................................................640
14.2.6 Deletion From B-Trees...........................................................642
14.2.7 Efficiency of B -Trees.............................................................. 645
14.2.8 Exercises for Section 1 4 .2 .....................................................646
14.3 Hash Tables..........................................................................................648
14.3.1 Secondary-Storage Hash T ables........................................... 649
14.3.2 Insertion Into a Hash T a b le ..................................................649
14.3.3 Hash-Table D eletio n .............................................................. 650
14.3.4 Efficiency of Hash Table In d e x e s........................................ 651
14.3.5 Extensible Hash Tables ........................................................652
14.3.6 Insertion Into Extensible Hash T a b le s............................... 653
TABLE OF CONTENTS xxvii
14.3.7 Linear Hash Tables..................................................................655
14.3.8 Insertion Into Linear Hash Tables ......................................657
14.3.9 Exercises for Section 1 4 .3 ......................................................659
14.4 Multidimensional In d e x e s .................................................................. 661
14.4.1 Applications of Multidimensional In d e x e s......................... 661
14.4.2 Executing Range Queries Using Conventional Indexes . . 663
14.4.3 Executing Nearest-Neighbor Queries Using Conventional 
In d e x e s .....................................................................................664
14.4.4 Overview of Multidimensional Index S tructures................664
14.5 Hash Structures for Multidimensional D a t a ...................................665
14.5.1 Grid F ile s ..................................................................................665
14.5.2 Lookup in a Grid F i l e ............................................................666
14.5.3 Insertion Into Grid F iles.........................................................667
14.5.4 Performance of Grid F ile s ..................................................... 669
14.5.5 Partitioned Hash F unctions.................................................. 671
14.5.6 Comparison of Grid Files and Partitioned Hashing .... 673
14.5.7 Exercises for Section 1 4 .5 ......................................................673
14.6 Tree Structures for Multidimensional D a ta ......................................675
14.6.1 Multiple-Key Indexes ............................................................675
14.6.2 Performance of Multiple-Key Indexes...................................676
14.6.3 kd-T rees.....................................................................................677
14.6.4 Operations on fed-Trees.........................................................679
14.6.5 Adapting fed-Trees to Secondary Storage............................ 681
14.6.6 Quad T re e s ...............................................................................681
14.6.7 R -T re e s.....................................................................................683
14.6.8 Operations on R -Trees............................................................684
14.6.9 Exercises for Section 1 4 .6 ......................................................686
14.7 Bitmap Indexes.....................................................................................688
14.7.1 Motivation for Bitmap In d e x e s............................................ 689
14.7.2 Compressed B itm aps...............................................................691
14.7.3 Operating on Run-Length-Encoded Bit-Vectors................693
14.7.4 Managing Bitmap Indexes......................................................693
14.7.5 Exercises for Section 1 4 .7 ......................................................695
14.8 Summary of Chapter 1 4 ..................................................................... 695
14.9 References for Chapter 1 4 .................................................................. 697
15 Q uery E xecution 701
15.1 Introduction to Physical-Query-Plan O p erato rs............................ 703
15.1.1 Scanning Tables ..................................................................... 703
15.1.2 Sorting While Scanning T a b le s............................................ 704
15.1.3 The Computation Model for Physical O p e ra to rs .............704
15.1.4 Parameters for Measuring Costs .........................................705
15.1.5 I/O Cost for Scan O p e ra to rs ............................................... 706
15.1.6 Iterators for Implementation of Physical Operators .... 707
15.2 One-Pass Algorithms........................................................................... 709
xxviii TABLE OF CONTENTS
15.2.1 One-Pass Algorithms for Tuple-at-a-Time Operations . . 711
15.2.2 One-Pass Algorithms for Unary, Full-Relation Operations 712
15.2.3 One-Pass Algorithms for Binary O perations......................715
15.2.4 Exercises for Section 1 5 .2 ..................................................... 718
15.3 Nested-Loop J o i n s .............................................................................. 718
15.3.1 Tuple-Based Nested-Loop J o i n ............................................719
15.3.2 An Iterator for Tuple-Based Nested-Loop Join ................719
15.3.3 Block-Based Nested-Loop Join A lgorithm ......................... 719
15.3.4 Analysis of Nested-Loop J o i n ...............................................721
15.3.5 Summary of Algorithms so F a r ............................................722
15.3.6 Exercises for Section 1 5 .3 ..................................................... 722
15.4 Two-Pass Algorithms Based on Sorting .........................................723
15.4.1 Two-Phase, Multiway Merge-Sort.........................................723
15.4.2 Duplicate Elimination Using S o rtin g .................................. 725
15.4.3 Grouping and Aggregation Using S o r tin g .........................726
15.4.4 A Sort-Based Union A lgorithm ............................................726
15.4.5 Sort-Based Intersection and Difference............................... 727
15.4.6 A Simple Sort-Based Join A lgorithm.................................. 728
15.4.7 Analysis of Simple Sort-Join ...............................................729
15.4.8 A More Efficient Sort-Based J o in .........................................729
15.4.9 Summary of Sort-Based A lg o rith m s.................................. 730
15.4.10Exercises for Section 1 5 .4 ..................................................... 730
15.5 Two-Pass Algorithms Based on H ash in g .........................................732
15.5.1 Partitioning Relations by H a sh in g ..................................... 732
15.5.2 A Hash-Based Algorithm for Duplicate Elimination . . . 732
15.5.3 Hash-Based Grouping and Aggregation ............................ 733
15.5.4 Hash-Based Union, Intersection, and Difference................734
15.5.5 The Hash-Join A lgorithm ..................................................... 734
15.5.6 Saving Some Disk I/O ’s ........................................................ 735
15.5.7 Summary of Hash-Based A lgorithm s.................................. 737
15.5.8 Exercises for Section 1 5 .5 .....................................................738
15.6 Index-Based A lgorithm s.....................................................................739
15.6.1 Clustering and Nonclustering Indexes ............................... 739
15.6.2 Index-Based S electio n........................................................... 740
15.6.3 Joining by Using an Index..................................................... 742
15.6.4 Joins Using a Sorted I n d e x ..................................................743
15.6.5 Exercises for Section 1 5 .6 ..................................................... 745
15.7 Buffer Management.............................................................................. 746
15.7.1 Buffer Management A rchitecture.........................................746
15.7.2 Buffer Management Strategies ............................................747
15.7.3 The Relationship Between Physical Operator Selection
and Buffer M anagem ent........................................................ 750
15.7.4 Exercises for Section 1 5 .7 ..................................................... 751
15.8 Algorithms Using More Than Two P a s s e s ......................................752
15.8.1 Multipass Sort-Based Algorithms.........................................752
TABLE OF CONTENTS xxix
15.8.2 Performance of Multipass, Sort-Based Algorithms .... 753
15.8.3 Multipass Hash-Based A lg o rith m s......................................754
15.8.4 Performance of Multipass Hash-Based Algorithms .... 754
15.8.5 Exercises for Section 1 5 .8 ..................................................... 755
15.9 Summary of Chapter 1 5 ..................................................................... 756
15.10References for Chapter 1 5 ..................................................................757
16 T h e Q uery C om piler 759
16.1 Parsing and Preprocessing..................................................................760
16.1.1 Syntax Analysis and Parse T re e s .........................................760
16.1.2 A Grammar for a Simple Subset of S Q L ............................ 761
16.1.3 The Preprocessor..................................................................... 764
16.1.4 Preprocessing Queries Involving V iew s............................... 765
16.1.5 Exercises for Section 1 6 .1 ..................................................... 767
16.2 Algebraic Laws for Improving Query Plans ...................................768
16.2.1 Commutative and Associative L a w s ...................................768
16.2.2 Laws Involving Selection.........................................................770
16.2.3 Pushing Selections..................................................................772
16.2.4 Laws Involving P rojection..................................................... 774
16.2.5 Laws About Joins and P r o d u c ts .........................................776
16.2.6 Laws Involving Duplicate E lim in atio n ............................... 777
16.2.7 Laws Involving Grouping and Aggregation......................... 777
16.2.8 Exercises for Section 16.2 ......................................................780
16.3 From Parse Trees to Logical Query P l a n s ......................................781
16.3.1 Conversion to Relational A lgebra.........................................782
16.3.2 Removing Subqueries From Conditions............................... 783
16.3.3 Improving the Logical Query P l a n ......................................788
16.3.4 Grouping Associative/Commutative O p e ra to rs................790
16.3.5 Exercises for Section 1 6 .3 ..................................................... 791
16.4 Estimating the Cost of O p eratio n s..................................................792
16.4.1 Estimating Sizes of Intermediate Relations ......................793
16.4.2 Estimating the Size of a Projection......................................794
16.4.3 Estimating the Size of a Selection.........................................794
16.4.4 Estimating the Size of a J o i n ............................................... 797
16.4.5 Natural Joins With Multiple Join A ttrib u te s...................799
16.4.6 Joins of Many R elations.........................................................800
16.4.7 Estimating Sizes for Other O perations............................... 801
16.4.8 Exercises for Section 1 6 .4 ..................................................... 802
16.5 Introduction to Cost-Based Plan Selection......................................803
16.5.1 Obtaining Estimates for Size Param eters............................ 804
16.5.2 Computation of S ta tistic s..................................................... 807
16.5.3 Heuristics for Reducing the Cost of Logical Query Plans . 808
16.5.4 Approaches to Enumerating Physical P la n s......................810
16.5.5 Exercises for Section 1 6 .5 ..................................................... 813
16.6 Choosing an Order for Jo in s...............................................................814
X X X TABLE OF CONTENTS
16.6.1 Significance of Left and Right Join A rg u m e n ts................815
16.6.2 Join T rees................................................................................. 815
16.6.3 Left-Deep Join T rees.............................................................. 816
16.6.4 Dynamic Programming to Select a Join Order and Grouping819
16.6.5 Dynamic Programming With More Detailed Cost Functions823
16.6.6 A Greedy Algorithm for Selecting a Join O rd e r................824
16.6.7 Exercises for Section 1 6 .6 ..................................................... 825
16.7 Completing the Physical-Query-Plan...............................................826
16.7.1 Choosing a Selection M e th o d ...............................................827
16.7.2 Choosing a Join M ethod........................................................ 829
16.7.3 Pipelining Versus M aterialization.........................................830
16.7.4 Pipelining Unary O p eratio n s...............................................830
16.7.5 Pipelining Binary O perations...............................................830
16.7.6 Notation for Physical Query P la n s ......................................834
16.7.7 Ordering of Physical O p e ratio n s.........................................837
16.7.8 Exercises for Section 1 6 .7 ..................................................... 838
16.8 Summary of Chapter 1 6 .....................................................................839
16.9 References for Chapter 1 6 ..................................................................841
17 C oping W ith System Failures 843
17.1 Issues and Models for Resilient O p eratio n ......................................843
17.1.1 Failure M odes...........................................................................844
17.1.2 More About T ransactions..................................................... 845
17.1.3 Correct Execution of T ransactions..................................... 846
17.1.4 The Primitive Operations of T ransactions.........................848
17.1.5 Exercises for Section 1 7 .1 ..................................................... 851
17.2 Undo Logging....................................................................................... 851
17.2.1 Log Records.............................................................................. 851
17.2.2 The Undo-Logging Rules ..................................................... 853
17.2.3 Recovery Using Undo Logging ............................................855
17.2.4 Checkpointing ........................................................................857
17.2.5 Nonquiescent Checkpointing..................................................858
17.2.6 Exercises for Section 1 7 .2 ..................................................... 862
17.3 Redo Logging....................................................................................... 863
17.3.1 The Redo-Logging R u l e ........................................................ 863
17.3.2 Recovery With Redo Logging...............................................864
17.3.3 Checkpointing a Redo Log..................................................... 866
17.3.4 Recovery With a Checkpointed Redo L o g .........................867
17.3.5 Exercises for Section 1 7 .3 ..................................................... 868
17.4 Undo/Redo L og g in g ...........................................................................869
17.4.1 The Undo/Redo R u les........................................................... 870
17.4.2 Recovery With Undo/Redo L o g g in g.................................. 870
17.4.3 Checkpointing an Undo/Redo L o g ......................................872
17.4.4 Exercises for Section 1 7 .4 ..................................................... 874
17.5 Protecting Against Media F a ilu re s..................................................875
TABLE OF CONTENTS xxxi
17.5.1 The Archive...............................................................................875
17.5.2 Nonquiescent A rchiving.........................................................875
17.5.3 Recovery Using an Archive and L o g ...................................878
17.5.4 Exercises for Section 1 7 .5 ......................................................879
17.6 Summary of Chapter 1 7 ..................................................................... 879
17.7 References for Chapter 1 7 .................................................................. 881
18 C oncurrency C ontrol 883
18.1 Serial and Serializable S ch ed u les......................................................884
18.1.1 S chedules..................................................................................884
18.1.2 Serial Schedules........................................................................ 885
18.1.3 Serializable S chedules............................................................886
18.1.4 The Effect of Transaction S em antics...................................887
18.1.5 A Notation for Transactions and S ch ed u les......................889
18.1.6 Exercises for Section 1 8 .1 ......................................................889
18.2 Conflict-Serializability........................................................................ 890
18.2.1 Conflicts.....................................................................................890
18.2.2 Precedence Graphs and a Test for Conflict-Serializability 892
18.2.3 Why the Precedence-Graph Test W o rk s............................ 894
18.2.4 Exercises for Section 1 8 .2 ......................................................895
18.3 Enforcing Serializability by Locks . ...................................................897
18.3.1 L o c k s ........................................................................................898
18.3.2 The Locking Scheduler............................................................900
18.3.3 Two-Phase Locking ...............................................................900
18.3.4 Why Two-Phase Locking W o r k s .........................................901
18.3.5 Exercises for Section 1 8 .3 ..................................................... 903
18.4 Locking Systems With Several Lock M o d e s ...................................905
18.4.1 Shared and Exclusive L ocks.................................................. 905
18.4.2 Compatibility Matrices .........................................................907
18.4.3 Upgrading L o ck s..................................................................... 908
18.4.4 Update Locks............................................................................909
18.4.5 Increment L o c k s ..................................................................... 911
18.4.6 Exercises for Section 1 8 .4 ......................................................913
18.5 An Architecture for a Locking Scheduler.........................................915
18.5.1 A Scheduler That Inserts Lock Actions ............................ 915
18.5.2 The Lock T able........................................................................ 918
18.5.3 Exercises for Section 1 8 .5 ......................................................921
18.6 Hierarchies of Database Elem ents......................................................921
18.6.1 Locks With Multiple G ranularity.........................................921
18.6.2 Warning L o c k s........................................................................ 922
18.6.3 Phantoms and Handling Insertions C o rre c tly ...................926
18.6.4 Exercises for Section 1 8 .6 ......................................................927
18.7 The Tree P ro to c o l...............................................................................927
18.7.1 Motivation for Tree-Based Locking......................................927
18.7.2 Rules for Access to Tree-Structured D a t a ......................... 928
xxxii TABLE OF CONTENTS
18.7.3 Why the Tree Protocol W orks...............................................929
18.7.4 Exercises for Section 1 8 .7 ..................................................... 932
18.8 Concurrency Control by Tim estam ps...............................................933
18.8.1 Timestamps..............................................................................934
18.8.2 Physically Unrealizable Behaviors ......................................934
18.8.3 Problems With Dirty D a t a .................................................. 935
18.8.4 The Rules for Timestamp-Based Scheduling......................937
18.8.5 Multiversion T im estam ps..................................................... 939
18.8.6 Timestamps Versus Locking..................................................941
18.8.7 Exercises for Section 1 8 .8 ..................................................... 942
18.9 Concurrency Control by Validation..................................................942
18.9.1 Architecture of a Validation-Based S cheduler...................942
18.9.2 The Validation Rules.............................................................. 943
18.9.3 Comparison of Three Concurrency-Control Mechanisms . 946
18.9.4 Exercises for Section 1 8 .9 ..................................................... 948
18.10Summary of Chapter 1 8 .....................................................................948
18.11 References for Chapter 1 8 ..................................................................950
19 M ore A bout T ransaction M anagem ent 953
19.1 Serializability and Recoverability..................................................... 953
19.1.1 The Dirty-Data Problem........................................................ 954
19.1.2 Cascading Rollback .............................................................. 955
19.1.3 Recoverable Schedules........................................................... 956
19.1.4 Schedules That Avoid Cascading Rollback.........................957
19.1.5 Managing Rollbacks Using Locking..................................... 957
19.1.6 Group C o m m it........................................................................959
19.1.7 Logical Logging........................................................................960
19.1.8 Recovery From Logical Logs..................................................963
19.1.9 Exercises for Section 1 9 .1 ..................................................... 965
19.2 D eadlocks..............................................................................................966
19.2.1 Deadlock Detection by Timeout .........................................967
19.2.2 The Waits-For G r a p h ........................................................... 967
19.2.3 Deadlock Prevention by Ordering E lem en ts......................970
19.2.4 Detecting Deadlocks by T im estam ps.................................. 970
19.2.5 Comparison of Deadlock-Management M ethods................972
19.2.6 Exercises for Section 1 9 .2 ..................................................... 974
19.3 Long-Duration Transactions.............................................................. 975
19.3.1 Problems of Long Transactions............................................976
19.3.2 Sagas ....................................................................................... 978
19.3.3 Compensating Transactions..................................................979
19.3.4 Why Compensating Transactions W o r k ............................ 980
19.3.5 Exercises for Section 1 9 .3 ..................................................... 981
19.4 Summary of Chapter 1 9 .....................................................................982
19.5 References for Chapter 1 9 ..................................................................983
TABLE OF CONTENTS xxxiii
20 P arallel and D istrib u ted D atabases 985
20.1 Parallel Algorithms on R e la tio n s......................................................985
20.1.1 Models of Parallelism ............................................................986
20.1.2 Tuple-at-a-Time Operations in Parallel............................... 989
20.1.3 Parallel Algorithms for Full-Relation O p e ratio n s.............989
20.1.4 Performance of Parallel Algorithms......................................990
20.1.5 Exercises for Section 20.1 ...................................................... 993
20.2 The Map-Reduce Parallelism Framework.........................................993
20.2.1 The Storage M odel.................................................................. 993
20.2.2 The Map F u n ctio n .................................................................. 994
20.2.3 The Reduce Function ............................................................995
20.2.4 Exercises for Section 20.2 ...................................................... 996
20.3 Distributed D atab ases........................................................................ 997
20.3.1 Distribution of D a t a ...............................................................997
20.3.2 Distributed Transactions.........................................................998
20.3.3 Data R eplication..................................................................... 999
20.3.4 Exercises for Section 20.3 ...................................................... 1000
20.4 Distributed Query Processing............................................................1000
20.4.1 The Distributed Join Problem ............................................1000
20.4.2 Semijoin R eductions...............................................................1001
20.4.3 Joins of Many R elations.........................................................1002
20.4.4 Acyclic H ypergraphs...............................................................1003
20.4.5 Full Reducers for Acyclic Hypergraphs................................1005
20.4.6 Why the Full-Reducer Algorithm W o rk s............................ 1006
20.4.7 Exercises for Section 20.4 ...................................................... 1007
20.5 Distributed C o m m it........................................................................... 1008
20.5.1 Supporting Distributed Atomicity ......................................1008
20.5.2 Two-Phase C o m m it...............................................................1009
20.5.3 Recovery of Distributed Transactions...................................1011
20.5.4 Exercises for Section 2 0 .5 ......................................................1013
20.6 Distributed L o c k in g ............................................................................1014
20.6.1 Centralized Lock S y stem s..................................................... 1015
20.6.2 A Cost Model for Distributed Locking Algorithms .... 1015
20.6.3 Locking Replicated E lem en ts............................................... 1016
20.6.4 Primary-Copy Locking............................................................1017
20.6.5 Global Locks From Local Locks............................................1017
20.6.6 Exercises for Section 2 0 .6 ......................................................1019
20.7 Peer-to-Peer Distributed Search.........................................................1020
20.7.1 Peer-to-Peer N etw orks............................................................1020
20.7.2 The Distributed-Hashing P ro b le m ......................................1021
20.7.3 Centralized Solutions for Distributed H ashing...................1022
20.7.4 Chord C ircles............................................................................1022
20.7.5 Links in Chord C ircles............................................................1024
20.7.6 Search Using Finger T a b le s.................................................. 1024
20.7.7 Adding New N odes.................................................................. 1027
xxxiv TABLE OF CONTENTS
20.7.8 When a Peer Leaves the N etw ork.........................................1030
20.7.9 When a Peer F a i l s ..................................................................1030
20.7.10Exercises for Section 20.7 ..................................................... 1031
20.8 Summary of Chapter 20 ..................................................................... 1031
20.9 References for Chapter 20 .................................................................. 1033
V Other Issues in Management of Massive Data 1035
21 Info rm atio n In teg ratio n 1037
21.1 Introduction to Information In te g ra tio n .........................................1037
21.1.1 Why Information Integration? ............................................ 1038
21.1.2 The Heterogeneity P ro b lem .................................................. 1040
21.2 Modes of Information Integration..................................................... 1041
21.2.1 Federated Database Systems ............................................... 1042
21.2.2 Data Warehouses..................................................................... 1043
21.2.3 M ediators..................................................................................1046
21.2.4 Exercises for Section 2 1 .2 ......................................................1048
21.3 Wrappers in Mediator-Based Systems ............................................1049
21.3.1 Templates for Query P attern s............................................... 1050
21.3.2 Wrapper G enerators...............................................................1051
21.3.3 F ilte rs ........................................................................................1052
21.3.4 Other Operations at the Wrapper ......................................1053
21.3.5 Exercises for Section 2 1 .3 ......................................................1054
21.4 Capability-Based O ptim ization.........................................................1056
21.4.1 The Problem of Limited Source Capabilities......................1056
21.4.2 A Notation for Describing Source Capabilities...................1057
21.4.3 Capability-Based Query-Plan Selection............................... 1058
21.4.4 Adding Cost-Based O ptim ization.........................................1060
21.4.5 Exercises for Section 2 1 .4 ......................................................1060
21.5 Optimizing Mediator Q u e rie s............................................................1061
21.5.1 Simplified Adornment N otation ............................................1061
21.5.2 Obtaining Answers for Subgoals .........................................1062
21.5.3 The Chain A lg o rith m ............................................................1063
21.5.4 Incorporating Union Views at the M ed iato r......................1067
21.5.5 Exercises for Section 2 1 .5 ..................................................... 1068
21.6 Local-as-View M ediators.....................................................................1069
21.6.1 Motivation for LAV M e d ia to rs............................................1069
21.6.2 Terminology for LAV Mediation .........................................1070
21.6.3 Expanding Solutions...............................................................1071
21.6.4 Containment of Conjunctive Q ueries...................................1073
21.6.5 Why the Containment-Mapping Test W orks...................... 1075
21.6.6 Finding Solutions to a Mediator Q uery............................... 1076
21.6.7 Why the LMSS Theorem H olds............................................1077
21.6.8 Exercises for Section 2 1 .6 ......................................................1078
TABLE OF CONTENTS X X X V
21.7 Entity Resolution..................................................................................1078
21.7.1 Deciding Whether Records Represent a Common Entity . 1079
21.7.2 Merging Similar Records.........................................................1081
21.7.3 Useful Properties of Similarity and Merge Functions . . .1082
21.7.4 The R-Swoosh Algorithm for ICAR Records......................1083
21.7.5 Why R-Swoosh W o rk s............................................................1086
21.7.6 Other Approaches to Entity R e so lu tio n ............................ 1086
21.7.7 Exercises for Section 2 1 .7 ..................................................... 1087
21.8 Summary of Chapter 2 1 ..................................................................... 1089
21.9 References for Chapter 2 1 ..................................................................1091
22 D a ta M ining 1093
22.1 Frequent-Itemset M ining..................................................................... 1093
22.1.1 The Market-Basket M odel......................................................1094
22.1.2 Basic D efinitions..................................................................... 1095
22.1.3 Association R ules..................................................................... 1097
22.1.4 The Computation Model for Frequent Ite m se ts................1098
22.1.5 Exercises for Section 22.1 ...................................................... 1099
22.2 Algorithms for Finding Frequent Ite m s e ts ......................................1100
22.2.1 The Distribution of Frequent Item sets................................1100
22.2.2 The Naive Algorithm for Finding Frequent Itemsets . . . 1101
22.2.3 The A-Priori A lgorithm .........................................................1102
22.2.4 Implementation of the A-Priori Algorithm......................... 1104
22.2.5 Making Better Use of Main M em ory...................................1105
22.2.6 When to Use the PCY Algorithm.........................................1106
22.2.7 The Multistage Algorithm ......................................................1107
22.2.8 Exercises for Section 2 2 .2 ............................................... ... . 1109
22.3 Finding Similar I t e m s ........................................................................ 1110
22.3.1 The Jaccard Measure of S im ilarity......................................1110
22.3.2 Applications of Jaccard S im ilarity ......................................1110
22.3.3 M inhashing...............................................................................1112
22.3.4 Minhashing and Jaccard Distance ......................................1113
22.3.5 Why Minhashing W o rk s.........................................................1113
22.3.6 Implementing M inhashing......................................................1114
22.3.7 Exercises for Section 2 2 .3 ......................................................1115
22.4 Locality-Sensitive H ashing.................................................................. 1116
22.4.1 Entity Resolution as an Example of LSH ......................... 1117
22.4.2 Locality-Sensitive Hashing of S ignatures............................ 1118
22.4.3 Combining Minhashing and Locality-Sensitive Hashing . . 1121
22.4.4 Exercises for Section 2 2 .4 ......................................................1122
22.5 Clustering of Large-Scale D a t a .........................................................1123
22.5.1 Applications of Clustering......................................................1123
22.5.2 Distance M easures.................................................................. 1125
22.5.3 Agglomerative C lu sterin g ......................................................1128
22.5.4 fc-Means A lgorithm s...............................................................1130
xxxvi TABLE OF CONTENTS
22.5.5 &-Means for Large-Scale D a ta ...............................................1132
22.5.6 Processing a Memory Load of P o in ts.................................. 1133
22.5.7 Exercises for Section 2 2 .5 .....................................................1136
22.6 Summary of Chapter 2 2 .................................................................... 1137
22.7 References for Chapter 2 2 ................................................................. 1139
23 D atabase System s and th e Internet 1141
23.1 The Architecture of a Search E n g in e...............................................1141
23.1.1 Components of a Search Engine............................................1142
23.1.2 Web Crawlers...........................................................................1143
23.1.3 Query Processing in Search E n g in e s.................................. 1146
23.1.4 Ranking P a g e s ........................................................................1146
23.2 PageRank for Identifying Important Pages..................................... 1147
23.2.1 The Intuition Behind PageRank ........................................ 1147
23.2.2 Recursive Formulation of PageRank — First T r y ............ 1148
23.2.3 Spider Traps and Dead E n d s ...............................................1150
23.2.4 PageRank Accounting for Spider Traps and Dead Ends . 1153
23.2.5 Exercises for Section 2 3 .2 .....................................................1154
23.3 Topic-Specific PageR ank.................................................................... 1156
23.3.1 Teleport S e t s ...........................................................................1156
23.3.2 Calculating A Topic-Specific P a g e R a n k ............................1158
23.3.3 Link Spam ..............................................................................1159
23.3.4 Topic-Specific PageRank and Link Spam ............................1160
23.3.5 Exercises for Section 2 3 .3 .....................................................1161
23.4 Data S tream s....................................................................................... 1161
23.4.1 Data-Stream-Management System s..................................... 1162
23.4.2 Stream A pplications.............................................................. 1163
23.4.3 A Data-Stream Data M odel..................................................1164
23.4.4 Converting Streams Into R elations..................................... 1165
23.4.5 Converting Relations Into S trea m s..................................... 1166
23.4.6 Exercises for Section 2 3 .4 .....................................................1168
23.5 Data Mining of S tre a m s.................................................................... 1169
23.5.1 Motivation ..............................................................................1169
23.5.2 Counting B its...........................................................................1171
23.5.3 Counting the Number of Distinct E lem en ts......................1175
23.5.4 Exercises for Section 2 3 .5 .....................................................1176
23.6 Summary of Chapter 2 3 .................................................................... 1177
23.7 References for Chapter 2 3 ................................................................. 1179
Index 1183
DATABASE SYSTEMS
The Complete Book
Chapter 1
The Worlds of Database
Systems
Databases today are essential to every business. Whenever you visit a major 
Web site — Google, Yahoo!, Amazon.com, or thousands of smaller sites that 
provide information — there is a database behind the scenes serving up the 
information you request. Corporations maintain all their important records in 
databases. Databases are likewise found at the core of many scientific investigations. They represent the data gathered by astronomers, by investigators of 
the human genome, and by biochemists exploring properties of proteins, among 
many other scientific activities.
The power of databases comes from a body of knowledge and technology 
that has developed over several decades and is embodied in specialized software called a database management system, or DBMS, or more colloquially a 
“database system.” A DBMS is a powerful tool for creating and managing large 
amounts of data efficiently and allowing it to persist over long periods of time, 
safely. These systems are among the most complex types of software available. 
In this book, we shall learn how to design databases, how to write programs 
in the various languages associated with a DBMS, and how to implement the 
DBMS itself.
1.1 The Evolution of Database System s
What is a database? In essence a database is nothing more than a collection of 
information that exists over a long period of time, often many years. In common 
parlance, the term database refers to a collection of data that is managed by a 
DBMS. The DBMS is expected to:
1. Allow users to create new databases and specify their schemas (logical 
structure of the data), using a specialized data-definition language.
1
2 CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
2. Give users the ability to query the data (a “query” is database lingo for 
a question about the data) and modify the data, using an appropriate 
language, often called a query language or data-manipulation language.
3. Support the storage of very large amounts of data — many terabytes or 
more — over a long period of time, allowing efficient access to the data 
for queries and database modifications.
4. Enable durability, the recovery of the database in the face of failures, 
errors of many kinds, or intentional misuse.
5. Control access to data from many users at once, without allowing unexpected interactions among users (called isolation) and without actions on 
the data to be performed partially but not completely (called atomicity).
1.1.1 Early Database Management Systems
The first commercial database management systems appeared in the late 1960’s. 
These systems evolved from file systems, which provide some of item (3) above; 
file systems store data over a long period of time, and they allow the storage of 
large amounts of data. However, file systems do not generally guarantee that 
data cannot be lost if it is not backed up, and they don’t support efficient access 
to data items whose location in a particular file is not known.
Further, file systems do not directly support item (2), a query language for 
the data in files. Their support for (1) — a schema for the data — is limited to 
the creation of directory structures for files. Item (4) is not always supported 
by file systems; you can lose data that has not been backed up. Finally, file 
systems do not satisfy (5). While they allow concurrent access to files by several 
users or processes, a file system generally will not prevent situations such as 
two users modifying the same file at about the same time, so the changes made 
by one user fail to appear in the file.
The first important applications of DBMS’s were ones where data was composed of many small items, and many queries or modifications were made. 
Examples of these applications are:
1. Banking systems: maintaining accounts and making sure that system 
failures do not cause money to disappear.
2. Airline reservation systems: these, like banking systems, require assurance 
that data will not be lost, and they must accept very large volumes of 
small actions by customers.
3. Corporate record keeping: employment and tax records, inventories, sales 
records, and a great variety of other types of information, much of it 
critical.
The early DBMS’s required the programmer to visualize data much as it 
was stored. These database systems used several different data models for
1.1. THE EVOLUTION OF DATABASE SYSTEM S 3
describing the structure of the information in a database, chief among them 
the “hierarchical” or tree-based model and the graph-based “network” model. 
The latter was standardized in the late 1960’s through a report of CODASYL 
(Committee on Data Systems and Languages).1
A problem with these early models and systems was that they did not support high-level query languages. For example, the CODASYL query language 
had statements that allowed the user to jump from data element to data element, through a graph of pointers among these elements. There was considerable effort needed to write such programs, even for very simple queries.
1.1.2 Relational Database Systems
Following a famous paper written by Ted Codd in 1970,2 database systems 
changed significantly. Codd proposed that database systems should present 
the user with a view of data organized as tables called relations. Behind the 
scenes, there might be a complex data structure that allowed rapid response 
to a variety of queries. But, unlike the programmers for earlier database systems, the programmer of a relational system would not be concerned with the 
storage structure. Queries could be expressed in a very high-level language, 
which greatly increased the efficiency of database programmers. We shall cover 
the relational model of database systems throughout most of this book. SQL 
(“Structured Query Language”), the most important query language based on 
the relational model, is covered extensively.
By 1990, relational database systems were the norm. Yet the database field 
continues to evolve, and new issues and approaches to the management of data 
surface regularly. Object-oriented features have infilrated the relational model. 
Some of the largest databases are organized rather differently from those using 
relational methodology. In the balance of this section, we shall consider some 
of the modern trends in database systems.
1.1.3 Smaller and Smaller Systems
Originally, DBMS’s were large, expensive software systems running on large 
computers. The size was necessary, because to store a gigabyte of data required 
a large computer system. Today, hundreds of gigabytes fit on a single disk, 
and it is quite feasible to run a DBMS on a personal computer. Thus, database 
systems based on the relational model have become available for even very small 
machines, and they are beginning to appear as a common tool for computer 
applications, much as spreadsheets and word processors did before them.
Another important trend is the use of documents, often tagged using XML 
(extensible Modeling Language). Large collections of small documents can
1 C O D A S Y L D ata B ase Task Group A p ril 1971 Report, A CM , New York.
2C odd, E . F ., “A relational m odel for large shared d a ta banks,” C om m . A C M , 13:6, 
pp. 377-387, 1970.
4 CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
serve as a database, and the methods of querying and manipulating them are 
different from those used in relational systems.
1.1.4 Bigger and Bigger Systems
On the other hand, a gigabyte is not that much data any more. Corporate 
databases routinely store terabytes (1012 bytes). Yet there are many databases 
that store petabytes (101S bytes) of data and serve it all to users. Some important examples:
1. Google holds petabytes of data gleaned from its crawl of the Web. This 
data is not held in a traditional DBMS, but in specialized structures 
optimized for search-engine queries.
2. Satellites send down petabytes of information for storage in specialized 
systems.
3. A picture is actually worth way more than a thousand words. You can 
store 1000 words in five or six thousand bytes. Storing a picture typically takes much more space. Repositories such as Flickr store millions 
of pictures and support search of those pictures. Even a database like 
Amazon’s has millions of pictures of products to serve.
4. And if still pictures consume space, movies consume much more. An hour 
of video requires at least a gigabyte. Sites such as YouTube hold hundreds 
of thousands, or millions, of movies and make them available easily.
5. Peer-to-peer file-sharing systems use large networks of conventional computers to store and distribute data of various kinds. Although each node 
in the network may only store a few hundred gigabytes, together the 
database they embody is enormous.
1.1.5 Information Integration
To a great extent, the old problem of building and maintaining databases has 
become one of information integration: joining the information contained in 
many related databases into a whole. For example, a large company has many 
divisions. Each division may have built its own database of products or employee records independently of other divisions. Perhaps some of these divisions 
used to be independent companies, which naturally had their own way of doing 
things. These divisions may use different DBMS’s and different structures for 
information. They may use different terms to mean the same thing or the same 
term to mean different things. To make matters worse, the existence of legacy 
applications using each of these databases makes it almost impossible to scrap 
them, ever.
As a result, it has become necessary with increasing frequency to build structures on top of existing databases, with the goal of integrating the information
1.2. OVERVIEW OF A DATABASE MANAGEMENT SYSTEM 5
distributed among them. One popular approach is the creation of data warehouses, where information from many legacy databases is copied periodically, 
with the appropriate translation, to a central database. Another approach is 
the implementation of a mediator, or “middleware,” whose function is to support an integrated model of the data of the various databases, while translating 
between this model and the actual models used by each database.
1.2 Overview of a Database Management
System
In Fig. 1.1 we see an outline of a complete DBMS. Single boxes represent system 
components, while double boxes represent in-memory data structures. The solid 
lines indicate control and data flow, while dashed lines indicate data flow only. 
Since the diagram is complicated, we shall consider the details in several stages. 
First, at the top, we suggest that there are two distinct sources of commands 
to the DBMS:
1. Conventional users and application programs that ask for data or modify 
data.
2. A database administrator: a person or persons responsible for the structure or schema of the database.
1.2.1 Data-Definition Language Commands
The second kind of command is the simpler to process, and we show its trail 
beginning at the upper right side of Fig. 1.1. For example, the database administrator, or DBA, for a university registrar’s database might decide that there 
should be a table or relation with columns for a student, a course the student 
has taken, and a grade for that student in that course. The DBA might also 
decide that the only allowable grades are A, B, C, D, and F. This structure 
and constraint information is all part of the schema of the database. It is 
shown in Fig. 1.1 as entered by the DBA, who needs special authority to execute schema-altering commands, since these can have profound effects on the 
database. These schema-altering data-definition language (DDL) commands 
are parsed by a DDL processor and passed to the execution engine, which then 
goes through the index/file/record manager to alter the metadata, that is, the 
schema information for the database.
1.2.2 Overview of Query Processing
The great majority of interactions with the DBMS follow the path on the left 
side of Fig. 1.1. A user or an application program initiates some action, using 
the data-manipulation language (DML). This command does not affect the 
schema of the database, but may affect the content of the database (if the
CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
D^t^bdsc
User/application administrator
Figure 1.1: Database management system components
OVERVIEW OF A DATABASE MANAGEM ENT SYSTEM 7
action is a modification command) or will extract data from the database (if the 
action is a query). DML statements are handled by two separate subsystems, 
as follows.
A nsw ering th e Q uery
The query is parsed and optimized by a query compiler. The resulting query
plan, or sequence of actions the DBMS will perform to answer the query, is 
passed to the execution engine. The execution engine issues a sequence of 
requests for small pieces of data, typically records or tuples of a relation, to a 
resource manager that knows about data files (holding relations), the format 
and size of records in those files, and index files, which help find elements of 
data files quickly.
The requests for data are passed to the buffer manager. The buffer manager’s task is to bring appropriate portions of the data from secondary storage 
(disk) where it is kept permanently, to the main-memory buffers. Normally, the 
page or “disk block” is the unit of transfer between buffers and disk.
The buffer manager communicates with a storage manager to get data from 
disk. The storage manager might involve operating-system commands, but 
more typically, the DBMS issues commands directly to the disk controller.
T ransaction P rocessin g
Queries and other DML actions are grouped into transactions, which are units 
that must be executed atomically and in isolation from one another. Any query 
or modification action can be a transaction by itself. In addition, the execution of transactions must be durable, meaning that the effect of any completed 
transaction must be preserved even if the system fails in some way right after 
completion of the transaction. We divide the transaction processor into two 
major parts:
1. A concurrency-control manager, or scheduler, responsible for assuring 
atomicity and isolation of transactions, and
2. A logging and recovery manager, responsible for the durability of transactions.
1.2.3 Storage and Buffer Management
The data of a database normally resides in secondary storage; in today’s computer systems “secondary storage” generally means magnetic disk. However, to 
perform any useful operation on data, that data must be in main memory. It 
is the job of the storage manager to control the placement of data on disk and 
its movement between disk and main memory.
In a simple database system, the storage manager might be nothing more 
than the file system of the underlying operating system. However, for efficiency
8 CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
purposes, DBMS’s normally control storage on the disk directly, at least under 
some circumstances. The storage manager keeps track of the location of files 
on the disk and obtains the block or blocks containing a file on request from 
the buffer manager.
The buffer manager is responsible for partitioning the available main memory into buffers, which are page-sized regions into which disk blocks can be 
transferred. Thus, all DBMS components that need information from the disk 
will interact with the buffers and the buffer manager, either directly or through 
the execution engine. The kinds of information that various components may 
need include:
1. Data: the contents of the database itself.
2. Metadata: the database schema that describes the structure of, and constraints on, the database.
3. Log Records: information about recent changes to the database; these 
support durability of the database.
4. Statistics: information gathered and stored by the DBMS about data 
properties such as the sizes of, and values in, various relations or other 
components of the database.
5. Indexes: data structures that support efficient access to the data.
1.2.4 Transaction Processing
It is normal to group one or more database operations into a transaction, which 
is a unit of work that must be executed atomically and in apparent isolation 
from other transactions. In addition, a DBMS offers the guarantee of durability: 
that the work of a completed transaction will never be lost. The transaction
manager therefore accepts transaction commands from an application, which 
tell the transaction manager when transactions begin and end, as well as information about the expectations of the application (some may not wish to require 
atomicity, for example). The transaction processor performs the following tasks:
1. Logging: In order to assure durability, every change in the database is 
logged separately on disk. The log manager follows one of several policies 
designed to assure that no matter when a system failure or “crash” occurs, 
a recovery manager will be able to examine the log of changes and restore 
the database to some consistent state. The log manager initially writes 
the log in buffers and negotiates with the buffer manager to make sure that 
buffers are written to disk (where data can survive a crash) at appropriate 
times.
2. Concurrency control: Transactions must appear to execute in isolation. 
But in most systems, there will in truth be many transactions executing
OVERVIEW OF A DATABASE M ANAGEM ENT SYSTEM 9
The ACID Properties of Transactions
Properly implemented transactions are commonly said to meet the “ACID 
test,” where:
• “A” stands for “atomicity,” the all-or-nothing execution of transactions.
• “I” stands for “isolation,” the fact that each transaction must appear 
to be executed as if no other transaction is executing at the same 
time.
• “D” stands for “durability,” the condition that the effect on the 
database of a transaction must never be lost, once the transaction 
has completed.
The remaining letter, “C,” stands for “consistency.” That is, all databases 
have consistency constraints, or expectations about relationships among 
data elements (e.g., account balances may not be negative after a transaction finishes). Transactions are expected to preserve the consistency of 
the database.
at once. Thus, the scheduler (concurrency-control manager) must assure 
that the individual actions of multiple transactions are executed in such 
an order that the net effect is the same as if the transactions had in 
fact executed in their entirety, one-at-a-time. A typical scheduler does 
its work by maintaining locks on certain pieces of the database. These 
locks prevent two transactions from accessing the same piece of data in 
ways that interact badly. Locks are generally stored in a main-memory 
lock table, as suggested by Fig. 1.1. The scheduler affects the execution of 
queries and other database operations by forbidding the execution engine 
from accessing locked parts of the database.
3. Deadlock resolution: As transactions compete for resources through the 
locks that the scheduler grants, they can get into a situation where none 
can proceed because each needs something another transaction has. The 
transaction manager has the responsibility to intervene and cancel (“rollback” or “abort”) one or more transactions to let the others proceed.
1.2.5 The Query Processor
The portion of the DBMS that most affects the performance that the user sees 
is the query processor. In Fig. 1.1 the query processor is represented by two 
components:
1 0 CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
1. The query compiler, which translates the query into an internal form called 
a query plan. The latter is a sequence of operations to be performed on 
the data. Often the operations in a query plan are implementations of 
“relational algebra” operations, which are discussed in Section 2.4. The 
query compiler consists of three major units:
(a) A query parser, which builds a tree structure from the textual form 
of the query.
(b) A query preprocessor, which performs semantic checks on the query 
(e.g., making sure all relations mentioned by the query actually exist), and performing some tree transformations to turn the parse tree 
into a tree of algebraic operators representing the initial query plan.
(c) A query optimizer, which transforms the initial query plan into the 
best available sequence of operations on the actual data.
The query compiler uses metadata and statistics about the data to decide 
which sequence of operations is likely to be the fastest. For example, the 
existence of an index, which is a specialized data structure that facilitates 
access to data, given values for one or more components of that data, can 
make one plan much faster than another.
2. The execution engine, which has the responsibility for executing each of 
the steps in the chosen query plan. The execution engine interacts with 
most of the other components of the DBMS, either directly or through 
the buffers. It must get the data from the database into buffers in order 
to manipulate that data. It needs to interact with the scheduler to avoid 
accessing data that is locked, and with the log manager to make sure that 
all database changes are properly logged.
1.3 Outline of Database-System Studies
We divide the study of databases into five parts. This section is an outline of 
what to expect in each of these units.
Part I: R elational D atabase M odeling
The relational model is essential for a study of database systems. After examining the basic concepts, we delve into the theory of relational databases. 
That study includes functional dependencies, a formal way of stating that one 
kind of data is uniquely determined by another. It also includes normalization,
the process whereby functional dependencies and other formal dependencies are 
used to improve the design of a relational database.
We also consider high-level design notations. These mechanisms include the 
Entity-Relationship (E/R) model, Unified Modeling Language (UML), and Object Definition Language (ODL). Their purpose is to allow informal exploration 
of design issues before we implement the design using a relational DBMS.
1.3. OUTLINE OF DATABASE-SYSTEM STUDIES 11
Part II: R elation al D atabase P rogram m ing
We then take up the m atter of how relational databases are queried and modified. After an introduction to abstract programming languages based on algebra 
and logic (Relational Algebra and Datalog, respectively), we turn our attention to the standard language for relational databases: SQL. We study both 
the basics and important special topics, including constraint specifications and 
triggers (active database elements), indexes and other structures to enhance 
performance, forming SQL into transactions, and security and privacy of data 
in SQL.
We also discuss how SQL is used in complete systems. It is typical to 
combine SQL with a conventional or host language and to pass data between 
the database and the conventional program via SQL calls. We discuss a number 
of ways to make this connection, including embedded SQL, Persistent Stored 
Modules (PSM), Call-Level Interface (CLI), Java Database Interconnectivity 
(JDBC), and PHP.
Part III: S em istructured D ata M od elin g and P rogram m ing
The pervasiveness of the Web has put a premium on the management of hierarchically structured data, because the standards for the Web are based on nested, 
tagged elements (semistructured data). We introduce XML and its schemadefining notations: Document Type Definitions (DTD) and XML Schema. We 
also examine three query languages for XML: XPATH, XQuery, and Extensible 
Stylesheet Language Transform (XSLT).
Part IV: D atabase S ystem Im p lem en tation
We begin with a study of storage management: how disk-based storage can be 
organized to allow efficient access to data. We explain the commonly used Btree, a balanced tree of disk blocks and other specialized schemes for managing 
multidimensional data.
We then turn our attention to query processing. There are two parts to 
this study. First, we need to learn query execution: the algorithms used to 
implement the operations from which queries are built. Since data is typically 
on disk, the algorithms are somewhat different from what one would expect 
were they to study the same problems but assuming that data were in main 
memory. The second step is query compiling. Here, we study how to select an 
efficient query plan from among all the possible ways in which a given query 
can be executed.
Then, we study transaction processing. There are several threads to follow. 
One concerns logging: maintaining reliable records of what the DBMS is doing, 
in order to allow recovery in the event of a crash. Another thread is scheduling:
controlling the order of events in transactions to assure the ACID properties. 
We also consider how to deal with deadlocks, and the modifications to our algorithms that are needed when a transaction is distributed over many independent
1 2 CHAPTER 1. THE WORLDS OF DATABASE SYSTEM S
sites.
Part V: M odern D atabase S ystem Issues
In this part, we take up a number of the ways in which database-system technology is relevant beyond the realm of conventional, relational DBMS’s. We 
consider how search engines work, and the specialized data structures that make 
their operation possible. We look at information integration, and methodologies for making databases share their data seamlessly. Data mining is a study 
that includes a number of interesting and important algorithms for processing 
large amounts of data in complex ways. Data-stream systems deal with data 
that arrives at the system continuously, and whose queries are answered continuously and in a timely fashion. Peer-to-peer systems present many challenges 
for management of distributed data held by independent hosts.
1.4 References for Chapter 1
Today, on-line searchable bibliographies cover essentially all recent papers concerning database systems. Thus, in this book, we shall not try to be exhaustive 
in our citations, but rather shall mention only the papers of historical importance and major secondary sources or useful surveys. A searchable index of 
database research papers was constructed by Michael Ley [5], and has recently 
been expanded to include references from many fields. Alf-Christian Achilles 
maintains a searchable directory of many indexes relevant to the database field 
[3],
While many prototype implementations of database systems contributed to 
the technology of the field, two of the most widely known are the System R 
project at IBM Almaden Research Center [4] and the INGRES project at Berkeley [7]. Each was an early relational system and helped establish this type of 
system as the dominant database technology. Many of the research papers that 
shaped the database field are found in [6].
The 2003 “Lowell report” [1] is the most recent in a series of reports on 
database-system research and directions. It also has references to earlier reports 
of this type.
You can find more about the theory of database systems than is covered 
here from [2] and [8].
1. S. Abiteboul et al., “The Lowell database research self-assessment,” Comm.
AC M 48:5 (2005), pp. 111-118. http://research.microsoft.com/~gray 
/lowell/LowellDatabaseResearchSelfAssessment.htm
2. S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases, AddisonWesley, Reading, MA, 1995.
3. http://liinwww.ira.uka.de/bibliography/Database.
1.4. REFERENCES FOR CHAPTER 1 13
4. M. M. Astrahan et al., “System R: a relational approach to database 
management,” ACM Trans, on Database Systems 1:2, pp. 97-137, 1976.
5. h ttp ://w w w .in fo rm a tik .u n i-trie r.d e /~ le y /d b /in d e x .h tm l. A mirror site is found at http://w w w .acm .org/sigm od/dblp/db/index.htm l.
6. M. Stonebraker and J. M. Hellerstein (eds.), Readings in Database Systems, Morgan-Kaufmann, San Francisco, 1998.
7. M. Stonebraker, E. Wong, P. Kreps, and G. Held, “The design and implementation of INGRES,” ACM Trans, on Database Systems 1:3, pp. 189- 
222, 1976.
8. J. D. Ullman, Principles of Database and Knowledge-Base Systems, Volumes I and II, Computer Science Press, New York, 1988, 1989.

Part I
Relational Database
Modeling
15

Chapter 2
The Relational M odel of
Data
This chapter introduces the most important model of data: the two-dimensional 
table, or “relation.” We begin with an overview of data models in general. We 
give the basic terminology for relations and show how the model can be used to 
represent typical forms of data. We then introduce a portion of the language 
SQL — that part used to declare relations and their structure. The chapter 
closes with an introduction to relational algebra. We see how this notation 
serves as both a query language — the aspect of a data model that enables us 
to ask questions about the data — and as a constraint language — the aspect 
of a data model that lets us restrict the data in the database in various ways.
2.1 An Overview of Data M odels
The notion of a “data model” is one of the most fundamental in the study of 
database systems. In this brief summary of the concept, we define some basic 
terminology and mention the most important data models.
2.1.1 W hat is a Data Model?
A data model is a notation for describing data or information. The description 
generally consists of three parts:
1. Structure of the data. You may be familiar with tools in programming 
languages such as C or Java for describing the structure of the data used by 
a program: arrays and structures (“structs”) or objects, for example. The 
data structures used to implement data in the computer are sometimes 
referred to, in discussions of database systems, as a physical data model,
although in fact they are far removed from the gates and electrons that 
truly serve as the physical implementation of the data. In the database
17
18 CHAPTER 2. THE RELATIONAL MODEL OF DATA
world, data models are at a somewhat higher level than data structures, 
and are sometimes referred to as a conceptual model to emphasize the 
difference in level. We shall see examples shortly.
2. Operations on the data. In programming languages, operations on the 
data are generally anything that can be programmed. In database data 
models, there is usually a limited set of operations that can be performed. 
We are generally allowed to perform a limited set of queries (operations 
that retrieve information) and modifications (operations that change the 
database). This limitation is not a weakness, but a strength. By limiting 
operations, it is possible for programmers to describe database operations 
at a very high level, yet have the database management system implement 
the operations efficiently. In comparison, it is generally impossible to 
optimize programs in conventional languages like C, to the extent that an 
inefficient algorithm (e.g., bubblesort) is replaced by a more efficient one 
(e.g., quicksort).
3. Constraints on the data. Database data models usually have a way to 
describe limitations on what the data can be. These constraints can range 
from the simple (e.g., “a day of the week is an integer between 1 and 7” 
or “a movie has at most one title”) to some very complex limitations that 
we shall discuss in Sections 7.4 and 7.5.
2.1.2 Important Data Models
Today, the two data models of preeminent importance for database systems are:
1. The relational model, including object-relational extensions.
2. The semistructured-data model, including XML and related standards.
The first, which is present in all commercial database management systems, 
is the subject of this chapter. The semistructured model, of which XML is 
the primary manifestation, is an added feature of most relational DBMS’s, and 
appears in a number of other contexts as well. We turn to this data model 
starting in Chapter 11.
2.1.3 The Relational Model in Brief
The relational model is based on tables, of which Fig. 2.1 is an example. We 
shall discuss this model beginning in Section 2.2. This relation, or table, describes movies: their title, the year in which they were made, their length in 
minutes, and the genre of the movie. We show three particular movies, but you 
should imagine that there are many more rows to this table — one row for each 
movie ever made, perhaps.
The structure portion of the relational model might appear to resemble an 
array of structs in C, where the column headers are the field names, and each
2.1. A N OVERVIEW OF DATA MODELS 19
title year length genre
Gone With the Wind 1939 231 drama
Stair Wars 1977 124 sciFi
Wayne’s World 1992 95 comedy
Figure 2.1: An example relation
of the rows represent the values of one struct in the array. However, it must be 
emphasized that this physical implementation is only one possible way the table 
could be implemented in physical data structures. In fact, it is not the normal 
way to represent relations, and a large portion of the study of database systems 
addresses the right ways to implement such tables. Much of the distinction 
comes from the scale of relations — they are not normally implemented as 
main-memory structures, and their proper physical implementation must take 
into account the need to access relations of very large size that are resident on 
disk.
The operations normally associated with the relational model form the “relational algebra,” which we discuss beginning in Section 2.4. These operations 
are table-oriented. As an example, we can ask for all those rows of a relation 
that have a certain value in a certain column. For example, we can ask of the 
table in Fig. 2.1 for all the rows where the genre is “comedy.”
The constraint portion of the relational data model will be touched upon 
briefly in Section 2.5 and covered in more detail in Chapter 7. However, as a 
brief sample of what kinds of constraints are generally used, we could decide 
that there is a fixed list of genres for movies, and that the last column of every 
row must have a value that is on this list. Or we might decide (incorrectly, 
it turns out) that there could never be two movies with the same title, and 
constrain the table so that no two rows could have the same string in the first 
component.
2.1.4 The Semistructured Model in Brief
Semistructured data resembles trees or graphs, rather than tables or arrays. 
The principal manifestation of this viewpoint today is XML, a way to represent 
data by hierarchically nested tagged elements. The tags, similar to those used 
in HTML, define the role played by different pieces of data, much as the column 
headers do in the relational model. For example, the same data as in Fig. 2.1 
might appear in an XML “document” as in Fig. 2.2.
The operations on semistructured data usually involve following paths in 
the implied tree from an element to one or more of its nested subelements, then 
to subelements nested within those, and so on. For example, starting at the 
outer <Movies> element (the entire document in Fig. 2.2), we might move to 
each of its nested <Movie> elements, each delimited by the tag <Movie> and 
matching </Movie> tag, and from each <Movie> element to its nested <Genre>
2 0 CHAPTER 2. THE RELATIONAL MODEL OF DATA
<Movies>
<Movie title="Gone With the Wind">
<Year>1939</Year>
<Length>231</Length>
<Genre>drama</Genre>
</Movie>
<Movie title="Star Wars">
<Year>1977</Year>
<Length>124</Length>
<Genre>sciFi</Genre>
</Movie>
<Movie title="Wayne’s World">
<Year>1992</Year>
<Length>95</Length>
<Genre> comedy</Genre>
</Movie>
</Movies>
Figure 2.2: Movie data as XML
element, to see which movies belong to the “comedy” genre.
Constraints on the structure of data in this model often involve the data 
type of values associated with a tag. For instance, are the values associated 
with the <Length> tag integers or can they be arbitrary character strings? 
Other constraints determine which tags can appear nested within which other 
tags. For example, must each <Movie> element have a <Length> element nested 
within it? What other tags, besides those shown in Fig. 2.2 might be used within 
a <Movie> element? Can there be more than one genre for a movie? These and 
other matters will be taken up in Section 11.2.
2.1.5 Other Data Models
There are many other models that are, or have been, associated with DBMS’s. 
A modern trend is to add object-oriented features to the relational model. There 
are two effects of object-orientation on relations:
1. Values can have structure, rather than being elementary types such as 
integer or strings, as they were in Fig. 2.1.
2. Relations can have associated methods.
In a sense, these extensions, called the object-relational model, are analogous to 
the way structs in C were extended to objects in C ++. We shall introduce the 
object-relational model in Section 10.3.
2.2. BASICS OF THE RELATIONAL MODEL 2 1
There are even database models of the purely object-oriented kind. In these, 
the relation is no longer the principal data-structuring concept, but becomes 
only one option among many structures. We discuss an object-oriented database 
model in Section 4.9.
There are several other models that were used in some of the earlier DBMS’s, 
but that have now fallen out of use. The hierarchical model was, like semistructured data, a tree-oriented model. Its drawback was that unlike more modern 
models, it really operated at the physical level, which made it impossible for 
programmers to write code at a conveniently high level. Another such model 
was the network model, which was a graph-oriented, physical-level model. In 
truth, both the hierarchical model and today’s semistructured models, allow 
full graph structures, and do not limit us strictly to trees. However, the generality of graphs was built directly into the network model, rather than favoring 
trees as these other models do.
2.1.6 Comparison of Modeling Approaches
Even from our brief example, it appears that semistructured models have more 
flexibility than relations. This difference becomes even more apparent when 
we discuss, as we shall, how full graph structures are embedded into tree-like, 
semistructured models. Nevertheless, the relational model is still preferred in 
DBMS’s, and we should understand why. A brief argument follows.
Because databases are large, efficiency of access to data and efficiency of 
modifications to that data are of great importance. Also very important is ease 
of use — the productivity of programmers who use the data. Surprisingly, both 
goals can be achieved with a model, particularly the relational model, that:
1. Provides a simple, limited approach to structuring data, yet is reasonably 
versatile, so anything can be modeled.
2. Provides a limited, yet useful, collection of operations on data.
Together, these limitations turn into features. They allow us to implement 
languages, such as SQL, that enable the programmer to express their wishes at 
a very high level. A few lines of SQL can do the work of thousands of lines of 
C, or hundreds of lines of the code that had to be written to access data under 
earlier models such as network or hierarchical. Yet the short SQL programs, 
because they use a strongly limited sets of operations, can be optimized to run 
as fast, or faster than the code written in alternative languages.
2.2 Basics of the Relational M odel
The relational model gives us a single way to represent data: as a two-dimensional table called a relation. Figure 2.1, which we copy here as Fig. 2.3, is an 
example of a relation, which we shall call Movies. The rows each represent a
2 2 CHAPTER 2. THE RELATIONAL MODEL OF DATA
movie, and the columns each represent a property of movies. In this section, 
we shall introduce the most important terminology regarding relations, and 
illustrate them with the Movies relation.
title year length genre
Gone With the Wind 1939 231 drama
Star Wars 1977 124 sciFi
Wayne’s World 1992 95 comedy
Figure 2.3: The relation Movies
2.2.1 Attributes
The columns of a relation are named by attributes-, in Fig. 2.3 the attributes are 
t i t l e , year, length, and genre. Attributes appear at the tops of the columns. 
Usually, an attribute describes the meaning of entries in the column below. For 
instance, the column with attribute length holds the length, in minutes, of 
each movie.
2.2.2 Schemas
The name of a relation and the set of attributes for a relation is called the 
schema for that relation. We show the schema for the relation with the relation 
name followed by a parenthesized list of its attributes. Thus, the schema for 
relation Movies of Fig. 2.3 is
M o v ie s(title , y ear, len g th , genre)
The attributes in a relation schema are a set, not a list. However, in order to 
talk about relations we often must specify a “standard” order for the attributes. 
Thus, whenever we introduce a relation schema with a list of attributes, as 
above, we shall take this ordering to be the standard order whenever we display 
the relation or any of its rows.
In the relational model, a database consists of one or more relations. The 
set of schemas for the relations of a database is called a relational database
schema, or just a database schema.
2.2.3 Tuples
The rows of a relation, other than the header row containing the attribute 
names, are called tuples. A tuple has one component for each attribute of 
the relation. For instance, the first of the three tuples in Fig. 2.3 has the 
four components Gone With th e Wind, 1939, 231, and drama for attributes 
t i t l e , year, length, and genre, respectively. When we wish to write a tuple
2.2. BASICS OF THE RELATIONAL MODEL 23
Conventions for Relations and Attributes
We shall generally follow the convention that relation names begin with a 
capital letter, and attribute names begin with a lower-case letter. However, 
later in this book we shall talk of relations in the abstract, where the names 
of attributes do not matter. In that case, we shall use single capital letters 
for both relations and attributes, e.g., R(A,B,C) for a generic relation 
with three attributes.
in isolation, not as part of a relation, we normally use commas to separate 
components, and we use parentheses to surround the tuple. For example,
(Gone With the Wind, 1939, 231, drama)
is the first tuple of Fig. 2.3. Notice that when a tuple appears in isolation, the 
attributes do not appear, so some indication of the relation to which the tuple 
belongs must be given. We shall always use the order in which the attributes 
were listed in the relation schema.
2.2.4 Domains
The relational model requires that each component of each tuple be atomic; 
that is, it must be of some elementary type such as integer or string. It is not 
permitted for a value to be a record structure, set, list, array, or any other type 
that reasonably can have its values broken into smaller components.
It is further assumed that associated with each attribute of a relation is a 
domain, that is, a particular elementary type. The components of any tuple of 
the relation must have, in each component, a value that belongs to the domain of 
the corresponding column. For example, tuples of the Movies relation of Fig. 2.3 
must have a first component that is a string, second and third components that 
are integers, and a fourth component whose value is a string.
It is possible to include the domain, or data type, for each attribute in 
a relation schema. We shall do so by appending a colon and a type after 
attributes. For example, we could represent the schema for the Movies relation 
as:
Movies(title:string, year:integer, length:integer, genre:string)
2.2.5 Equivalent Representations of a Relation
Relations are sets of tuples, not lists of tuples. Thus the order in which the 
tuples of a relation are presented is immaterial. For example, we can list the 
three tuples of Fig. 2.3 in any of their six possible orders, and the relation is 
“the same” as Fig. 2.3.
24 CHAPTER 2. THE RELATIONAL MODEL OF DATA
Moreover, we can reorder the attributes of the relation as we choose, without 
changing the relation. However, when we reorder the relation schema, we must 
be careful to remember that the attributes are column headers. Thus, when we 
change the order of the attributes, we also change the order of their columns. 
When the columns move, the components of tuples change their order as well. 
The result is that each tuple has its components permuted in the same way as 
the attributes are permuted.
For example, Fig. 2.4 shows one of the many relations that could be obtained 
from Fig. 2.3 by permuting rows and columns. These two relations are considered “the same.” More precisely, these two tables are different presentations of 
the same relation.
year genre title length
1977 sciF i S ta r Wars 124
1992 comedy Wayne’s World 95
1939 drama Gone With th e Wind 231
Figure 2.4: Another presentation of the relation Movies
2.2.6 Relation Instances
A relation about movies is not static; rather, relations change over time. We 
expect to insert tuples for new movies, as these appear. We also expect changes 
to existing tuples if we get revised or corrected information about a movie, and 
perhaps deletion of tuples for movies that are expelled from the database for 
some reason.
It is less common for the schema of a relation to change. However, there are 
situations where we might want to add or delete attributes. Schema changes, 
while possible in commercial database systems, can be very expensive, because 
each of perhaps millions of tuples needs to be rewritten to add or delete components. Also, if we add an attribute, it may be difficult or even impossible to 
generate appropriate values for the new component in the existing tuples.
We shall call a set of tuples for a given relation an instance of that relation. 
For example, the three tuples shown in Fig. 2.3 form an instance of relation 
Movies. Presumably, the relation Movies has changed over time and will continue to change over time. For instance, in 1990, Movies did not contain the 
tuple for Wayne ’ s World. However, a conventional database system maintains 
only one version of any relation: the set of tuples that are in the relation “now.” 
This instance of the relation is called the current instance}
1 D atabases th a t m ain tain historical versions of d a ta as it existed in p ast tim es are called 
tem poral databases.
2.2. BASICS OF THE RELATIONAL MODEL 25
2.2.7 Keys of Relations
There are many constraints on relations that the relational model allows us to 
place on database schemas. We shall defer much of the discussion of constraints 
until Chapter 7. However, one kind of constraint is so fundamental that we shall 
introduce it here: key constraints. A set of attributes forms a key for a relation 
if we do not allow two tuples in a relation instance to have the same values in 
all the attributes of the key.
E xam ple 2.1: We can declare that the relation Movies has a key consisting 
of the two attributes t i t l e and year. That is, we don’t believe there could 
ever be two movies that had both the same title and the same year. Notice 
that t i t l e by itself does not form a key, since sometimes “remakes” of a movie 
appear. For example, there are three movies named King Kong, each made in 
a different year. It should also be obvious that year by itself is not a key, since 
there are usually many movies made in the same year. □
We indicate the attribute or attributes that form a key for a relation by 
underlining the key attribute(s). For instance, the Movies relation could have 
its schema written as:
Movies(t i t l e , ye a r , le n g th , genre)
Remember that the statement that a set of attributes forms a key for a 
relation is a statement about all possible instances of the relation, not a statement about a single instance. For example, looking only at the tiny relation of 
Fig. 2.3, we might imagine that genre by itself forms a key, since we do not see 
two tuples that agree on the value of their genre components. However, we can 
easily imagine that if the relation instance contained more movies, there would 
be many dramas, many comedies, and so on. Thus, there would be distinct 
tuples that agreed on the genre component. As a consequence, it would be 
incorrect to assert that genre is a key for the relation Movies.
While we might be sure that t i t l e and year can serve as a key for Movies, 
many real-world databases use artificial keys, doubting that it is safe to make 
any assumption about the values of attributes outside their control. For example, companies generally assign employee ID’s to all employees, and these 
ID’s are carefully chosen to be unique numbers. One purpose of these ID’s is 
to make sure that in the company database each employee can be distinguished 
from all others, even if there are several employees with the same name. Thus, 
the employee-ID attribute can serve as a key for a relation about employees.
In US corporations, it is normal for every employee to have a Social-Security 
number. If the database has an attribute that is the Social-Security number, 
then this attribute can also serve as a key for employees. Note that there is 
nothing wrong with there being several choices of key, as there would be for 
employees having both employee ID’s and Social-Security numbers.
The idea of creating an attribute whose purpose is to serve as a key is quite 
widespread. In addition to employee ID’s, we find student ID’s to distinguish
26 CHAPTER 2. THE RELATIONAL MODEL OF DATA
students in a university. We find drivers’ license numbers and automobile registration numbers to distinguish drivers and automobiles, respectively. You 
undoubtedly can find more examples of attributes created for the primary purpose of serving as keys.
Movies(
t i t l e :s trin g , 
ye a r:in te g e r, 
le n g th : in te g e r, 
g e n re :strin g , 
studioName: s tr in g , 
producerC#: in teg er
)
M ovieStar(
name:s trin g , 
ad d ress: s trin g , 
gender: ch a r, 
b ir th d a te :date
)
S ta rs In (
m ovieT itle: s tr in g , 
movieYear:in te g e r , 
starN am e:string
)
MovieExec(
nam e:string, 
ad d ress: s trin g , 
c e rt# : in te g e r, 
netW orth: in teg er
)
S tu d io (
name:s trin g , 
ad d ress: s tr in g , 
presC#:in te g er
)
Figure 2.5: Example database schema about movies
2.2.8 An Example Database Schema
We shall close this section with an example of a complete database schema. 
The topic is movies, and it builds on the relation Movies that has appeared so 
far in examples. The database schema is shown in Fig. 2.5. Here are the things 
we need to know to understand the intention of this schema.
2.2. BASICS OF THE RELATIONAL MODEL 27
Movies
This relation is an extension of the example relation we have been discussing 
so far. Remember that its key is title and year together. We have added 
two new attributes; studioName tells us the studio that owns the movie, and 
producerC# is an integer that represents the producer of the movie in a way 
that we shall discuss when we talk about the relation MovieExec below.
MovieStar
This relation tells us something about stars. The key is name, the name of the 
movie star. It is not usual to assume names of persons are unique and therefore 
suitable as a key. However, movie stars are different; one would never take a 
name that some other movie star had used. Thus, we shall use the convenient 
fiction that movie-star names are unique. A more conventional approach would 
be to invent a serial number of some sort, like social-security numbers, so that 
we could assign each individual a unique number and use that attribute as the 
key. We take that approach for movie executives, as we shall see. Another 
interesting point about the MovieStar relation is that we see two new data 
types. The gender can be a single character, M or F. Also, birthdate is of type 
“date,” which might be a character string of a special form.
Starsln
This relation connects movies to the stars of that movie, and likewise connects a 
star to the movies in which they appeared. Notice that movies are represented 
by the key for Movies — the title and year — although we have chosen different attribute names to emphasize that attributes movieTitle and movieYear 
represent the movie. Likewise, stars are represented by the key for MovieStar, 
with the attribute called starName. Finally, notice that all three attributes 
are necessary to form a key. It is perfectly reasonable to suppose that relation 
Starsln could have two distinct tuples that agree in any two of the three attributes. For instance, a star might appear in two movies in one year, giving 
rise to two tuples that agreed in movieYear and starName, but disagreed in 
movieTitle.
MovieExec
This relation tells us about movie executives. It contains their name, address, 
and networth as data about the executive. However, for a key we have invented 
“certificate numbers” for all movie executives, including producers (as appear 
in the relation Movies) and studio presidents (as appear in the relation Studio, 
below). These are integers; a different one is assigned to each executive.
28 CHAPTER 2. THE RELATIONAL MODEL OF DATA
acctNo type balance
12345 savings 12000
23456 checking 1000
34567 savings 25
The relation Accounts
firstName lastName idNo account
Robbie Banks 901-222 12345
Lena Hand 805-333 12345
Lena Hand 805-333 23456
The relation Customers 
Figure 2.6: Two relations of a banking database
Studio
This relation tells about movie studios. We rely on no two studios having the 
same name, and therefore use name as the key. The other attributes are the 
address of the studio and the certificate number for the president of the studio. 
We assume that the studio president is surely a movie executive and therefore 
appears in MovieExec.
2.2.9 Exercises for Section 2.2
E xercise 2.2.1: In Fig. 2.6 are instances of two relations that might constitute 
part of a banking database. Indicate the following:
a) The attributes of each relation.
b) The tuples of each relation.
c) The components of one tuple from each relation.
d) The relation schema for each relation.
e) The database schema.
f) A suitable domain for each attribute.
g) Another equivalent way to present each relation.
2.3. DEFINING A RELATION SCHEMA IN SQL 29
E xercise 2.2.2: In Section 2.2.7 we suggested that there are many examples 
of attributes that are created for the purpose of serving as keys of relations. 
Give some additional examples.
E xercise 2.2.3: How many different ways (considering orders of tuples and 
attributes) are there to represent a relation instance if that instance has:
a) Three attributes and three tuples, like the relation Accounts of Fig. 2.6?
b) Four attributes and five tuples?
c) n attributes and m tuples?
2.3 Defining a Relation Schema in SQL
SQL (pronounced “sequel”) is the principal language used to describe and manipulate relational databases. There is a current standard for SQL, called SQL99. Most commercial database management systems implement something similar, but not identical to, the standard. There are two aspects to SQL:
1. The Data-Definition sublanguage for declaring database schemas and
2. The Data-Manipulation sublanguage for querying (asking questions about) databases and for modifying the database.
The distinction between these two sublanguages is found in most languages; 
e.g., C or Java have portions that declare data and other portions that are 
executable code. These correspond to data-definition and data-manipulation, 
respectively.
In this section we shall begin a discussion of the data-definition portion 
of SQL. There is more on the subject in Chapter 7, especially the m atter of 
constraints on data. The data-manipulation portion is covered extensively in 
Chapter 6.
2.3.1 Relations in SQL
SQL makes a distinction between three kinds of relations:
1. Stored relations, which are called tables. These are the kind of relation 
we deal with ordinarily — a relation that exists in the database and that 
can be modified by changing its tuples, as well as queried.
2. Views, which are relations defined by a computation. These relations are 
not stored, but are constructed, in whole or in part, when needed. They 
are the subject of Section 8.1.
30 CHAPTER 2. THE RELATIONAL MODEL OF DATA
3. Temporary tables, which are constructed by the SQL language processor 
when it performs its job of executing queries and data modifications. 
These relations are then thrown away and not stored.
In this section, we shall learn how to declare tables. We do not treat the declaration and definition of views here, and temporary tables are never declared. 
The SQL CREATE TABLE statement declares the schema for a stored relation. It 
gives a name for the table, its attributes, and their data types. It also allows 
us to declare a key, or even several keys, for a relation. There are many other 
features to the CREATE TABLE statement, including many forms of constraints 
that can be declared, and the declaration of indexes (data structures that speed 
up many operations on the table) but we shall leave those for the appropriate 
time.
2.3.2 Data Types
To begin, let us introduce the primitive data types that are supported by SQL 
systems. All attributes must have a data type.
1. Character strings of fixed or varying length. The type CHAR(n) denotes 
a fixed-length string of up to n characters. VARCHAR(n) also denotes a 
string of up to n characters. The difference is implementation-dependent; 
typically CHAR implies that short strings are padded to make n characters, 
while VARCHAR implies that an endmarker or string-length is used. SQL 
permits reasonable coercions between values of character-string types. 
Normally, a string is padded by trailing blanks if it becomes the value 
of a component that is a fixed-length string of greater length. For example, the string ’foo’ ,2 if it became the value of a component for an 
attribute of type CHAR(5), would assume the value ’foo ’ (with two 
blanks following the second o).
2. Bit strings of fixed or varying length. These strings are analogous to fixed 
and varying-length character strings, but their values are strings of bits 
rather than characters. The type BIT (n) denotes bit strings of length n,
while BIT VARYING (n) denotes bit strings of length up to n.
3. The type BOOLEAN denotes an attribute whose value is logical. The possible values of such an attribute are TRUE, FALSE, and — although it would 
surprise George Boole — UNKNOWN.
4. The type INT or INTEGER (these names are synonyms) denotes typical 
integer values. The type SHORTINT also denotes integers, but the number 
of bits permitted may be less, depending on the implementation (as with 
the types int and short int in C).
2N otice th a t in SQ L, strings are surrounded by single-quotes, n o t double-quotes as in m any 
oth er program m ing languages.
2.3. DEFINING A RELATION SCHEMA IN SQL 31
Dates and Times in SQL
Different SQL implementations may provide many different representations for dates and times, but the following is the SQL standard representation. A date value is the keyword DATE followed by a quoted string 
of a special form. For example, DATE ’1948-05-14’ follows the required 
form. The first four characters are digits representing the year. Then come 
a hyphen and two digits representing the month. Finally there is another 
hyphen and two digits representing the day. Note that single-digit months 
and days are padded with a leading 0.
A time value is the keyword TIME and a quoted string. This string has 
two digits for the hour, on the military (24-hour) clock. Then come a colon, 
two digits for the minute, another colon, and two digits for the second. If 
fractions of a second are desired, we may continue with a decimal point and 
as many significant digits as we like. For instance, TIME ’ 15:00:02.5 ’ 
represents the time at which all students will have left a class that ends 
at 3 PM: two and a half seconds past three o’clock.
5. Floating-point numbers can be represented in a variety of ways. We may 
use the type FLOAT or REAL (these are synonyms) for typical floatingpoint numbers. A higher precision can be obtained with the type DOUBLE 
PRECISION; again the distinction between these types is as in C. SQL also 
has types that are real numbers with a fixed decimal point. For example, DECIMAL(n,d) allows values that consist of n decimal digits, with the 
decimal point assumed to be d positions from the right. Thus, 0123.45 
is a possible value of type DECIMAL(6,2). NUMERIC is almost a synonym 
for DECIMAL, although there are possible implementation-dependent differences.
6. Dates and times can be represented by the data types DATE and TIME, 
respectively (see the box on “Dates and Times in SQL”). These values 
are essentially character strings of a special form. We may, in fact, coerce 
dates and times to string types, and we may do the reverse if the string 
“makes sense” as a date or time.
2.3.3 Simple Table Declarations
The simplest form of declaration of a relation schema consists of the keywords CREATE TABLE followed by the name of the relation and a parenthesized, 
comma-separated list of the attribute names and their types.
E xam ple 2.2: The relation Movies with the schema given in Fig. 2.5 can be 
declared as in Fig. 2.7. The title is declared as a string of (up to) 100 characters.
32 CHAPTER 2. THE RELATIONAL MODEL OF DATA
CREATE TABLE Movies (
t i t l e CHAR(IOO),
year INT,
length INT,
genre CHAR(10),
studioName CHAR(30),
producerC# INT
);
Figure 2.7: SQL declaration of the table Movies
The year and length attributes are each integers, and the genre is a string of 
(up to) 10 characters. The decision to allow up to 100 characters for a title 
is arbitrary, but we don’t want to limit the lengths of titles too strongly, or 
long titles would be truncated to fit. We have assumed that 10 characters are 
enough to represent a genre of movie; again, that is an arbitrary choice, one 
we could regret if we had a genre with a long name. Likewise, we have chosen 
30 characters as sufficient for the studio name. The certificate number for the 
producer of the movie is another integer. □
Exam ple 2.3: Figure 2.8 is a SQL declaration of the relation MovieStar from 
Fig. 2.5. It illustrates some new options for data types. The name of this table 
is MovieStar, and it has four attributes. The first two attributes, name and 
address, have each been declared to be character strings. However, with the 
name, we have made the decision to use a fixed-length string of 30 characters, 
padding a name out with blanks at the end if necessary and truncating a name 
to 30 characters if it is longer. In contrast, we have declared addresses to be 
variable-length character strings of up to 255 characters.3 It is not clear that 
these two choices are the best possible, but we use them to illustrate the two 
major kinds of string data types.
CREATE TABLE MovieStar ( 
name CHAR(30),
address VARCHAR(255), 
gender CHAR(l), 
b irth d a te DATE
);
Figure 2.8: Declaring the relation schema for the MovieStar relation
3T h e num ber 255 is not th e result of som e weird notion of w hat typical addresses look like. 
A single byte can store integers betw een 0 and 255, so it is possible to represent a varyinglength character strin g of up to 255 bytes by a single byte for the count of characters plus the 
bytes to store the strin g itself. Com m ercial system s generally su p p o rt longer varying-length 
strings, however.
2.3. DEFINING A RELATION SCHEMA IN SQL 33
The gender attribute has values that are a single letter, M or F. Thus, we 
can safely use a single character as the type of this attribute. Finally, the 
b irth d a te attribute naturally deserves the data type DATE. □
2.3.4 Modifying Relation Schemas
We now know how to declare a table. But what if we need to change the schema 
of the table after it has been in use for a long time and has many tuples in its 
current instance? We can remove the entire table, including all of its current 
tuples, or we could change the schema by adding or deleting attributes.
We can delete a relation R by the SQL statement:
DROP TABLE R;
Relation R is no longer part of the database schema, and we can no longer 
access any of its tuples.
More frequently than we would drop a relation that is part of a long-lived 
database, we may need to modify the schema of an existing relation. These 
modifications are done by a statement that begins with the keywords ALTER 
TABLE and the name of the relation. We then have several options, the most 
important of which are
1. ADD followed by an attribute name and its data type.
2. DROP followed by an attribute name.
E xam ple 2.4: Thus, for instance, we could modify the MovieStar relation by 
adding an attribute phone with:
ALTER TABLE MovieStar ADD phone CHAR(16);
As a result, the MovieStar schema now has five attributes: the four mentioned 
in Fig. 2.8 and the attribute phone, which is a fixed-length string of 16 bytes. 
In the actual relation, tuples would all have components for phone, but we 
know of no phone numbers to put there. Thus, the value of each of these 
components is set to the special null value, NULL. In Section 2.3.5, we shall see 
how it is possible to choose another “default” value to be used instead of NULL 
for unknown values.
As another example, the ALTER TABLE statement:
ALTER TABLE MovieStar DROP b irth d a te ;
deletes the b irth d a te attribute. As a result, the schema for MovieStar no 
longer has that attribute, and all tuples of the current MovieStar instance 
have the component for b irth d a te deleted. □
34 CHAPTER 2. THE RELATIONAL MODEL OF DATA
2.3.5 Default Values
When we create or modify tuples, we sometimes do not have values for all 
components. For instance, we mentioned in Example 2.4 that when we add a 
column to a relation schema, the existing tuples do not have a known value, and 
it was suggested that NULL could be used in place of a “real” value. However, 
there are times when we would prefer to use another choice of default value, the 
value that appears in a column if no other value is known.
In general, any place we declare an attribute and its data type, we may add 
the keyword DEFAULT and an appropriate value. That value is either NULL or 
a constant. Certain other values that are provided by the system, such as the 
current time, may also be options.
Example 2.5: Let us consider Example 2.3. We might wish to use the character ? as the default for an unknown gender, and we might also wish to use 
the earliest possible date, DATE ’0000-00-00’ for an unknown birthdate. We 
could replace the declarations of gender and birthdate in Fig. 2.8 by:
gender CHAR(l) DEFAULT ’?’,
birthdate DATE DEFAULT DATE ’0000-00-00’
As another example, we could have declared the default value for new attribute phone to be ’u n lis te d ’ when we added this attribute in Example 2.4. 
In that case,
ALTER TABLE MovieStar ADD phone CHAR(16) DEFAULT ’unlisted’; 
would be the appropriate ALTER TABLE statement. □
2.3.6 Declaring Keys
There are two ways to declare an attribute or set of attributes to be a key in 
the CREATE TABLE statement that defines a stored relation.
1. We may declare one attribute to be a key when that attribute is listed in 
the relation schema.
2. We may add to the list of items declared in the schema (which so far 
have only been attributes) an additional declaration that says a particular 
attribute or set of attributes forms the key.
If the key consists of more than one attribute, we have to use method (2). If 
the key is a single attribute, either method may be used.
There are two declarations that may be used to indicate keyness:
a) PRIMARY KEY, or
b) UNIQUE.
2.3. DEFINING A RELATION SCHEMA IN SQL 35
The effect of declaring a set of attributes 5 to be a key for relation R either 
using PRIMARY KEY or UNIQUE is the following:
• Two tuples in R cannot agree on all of the attributes in set 5, unless one 
of them is NULL. Any attem pt to insert or update a tuple that violates 
this rule causes the DBMS to reject the action that caused the violation.
In addition, if PRIMARY KEY is used, then attributes in S are not allowed to 
have NULL as a value for their components. Again, any attem pt to violate this 
rule is rejected by the system. NULL is permitted if the set S is declared UNIQUE, 
however. A DBMS may make other distinctions between the two terms, if it 
wishes.
E xam ple 2.6: Let us reconsider the schema for relation MovieStar. Since no 
star would use the name of another star, we shall assume that name by itself 
forms a key for this relation. Thus, we can add this fact to the line declaring 
name. Figure 2.9 is a revision of Fig. 2.8 that reflects this change. We could 
also substitute UNIQUE for PRIMARY KEY in this declaration. If we did so, then 
two or more tuples could have NULL as the value of name, but there could be no 
other duplicate values for this attribute.
CREATE TABLE MovieStar (
name CHAR(30) PRIMARY KEY, 
address VARCHAR(255), 
gender CHAR(l), 
b irth d a te DATE
);
Figure 2.9: Making name the key
Alternatively, we can use a separate definition of the key. The resulting 
schema declaration would look like Fig. 2.10. Again, UNIQUE could replace 
PRIMARY KEY. □
CREATE TABLE MovieStar ( 
name CHAR(30), 
address VARCHAR(255), 
gender CHAR(l), 
b irth d a te DATE,
PRIMARY KEY (name)
);
Figure 2.10: A separate declaration of the key
36 CHAPTER 2. THE RELATIONAL MODEL OF DATA
E xam ple 2.7: In Example 2.6, the form of either Fig. 2.9 or Fig. 2.10 is 
acceptable, because the key is a single attribute. However, in a situation where 
the key has more than one attribute, we must use the style of Fig. 2.10. For 
instance, the relation Movie, whose key is the pair of attributes t i t l e and year, 
must be declared as in Fig. 2.11. However, as usual, UNIQUE is an option to 
replace PRIMARY KEY. □
CREATE TABLE Movies (
t i t l e CHAR(100),
year INT,
len g th INT,
genre CHAR(IO),
studioName CHAR(30), 
producerC# INT,
PRIMARY KEY ( t i t l e , year)
Figure 2.11: Making t i t l e and year be the key of Movies
2.3.7 Exercises for Section 2.3
E xercise 2.3.1: In this exercise we introduce one of our running examples of 
a relational database schema. The database schema consists of four relations, 
whose schemas are:
Product(m aker, model, type)
PC(model, speed, ram, hd, p rice )
Laptop(model, speed, ram, hd, screen , p ric e )
P rin ter(m o d el, co lo r, ty p e, p rice )
The Product relation gives the manufacturer, model number and type (PC, 
laptop, or printer) of various products. We assume for convenience that model 
numbers are unique over all manufacturers and product types; that assumption 
is not realistic, and a real database would include a code for the manufacturer 
as part of the model number. The PC relation gives for each model number 
that is a PC the speed (of the processor, in gigahertz), the amount of RAM (in 
megabytes), the size of the hard disk (in gigabytes), and the price. The Laptop 
relation is similar, except that the screen size (in inches) is also included. The 
P rin te r relation records for each printer model whether the printer produces 
color output (true, if so), the process type (laser or ink-jet, typically), and the 
price.
Write the following declarations:
a) A suitable schema for relation Product.
2.3. DEFINING A RELATIO N SCHEMA IN SQL 37
b) A suitable schema for relation PC.
c) A suitable schema for relation Laptop.
d) A suitable schema for relation P rin te r.
e) An alteration to your P r in te r schema from (d) to delete the attribute 
color.
f) An alteration to your Laptop schema from (c) to add the attribute od 
(optical-disk type, e.g., cd or dvd). Let the default value for this attribute 
be ’none’ if the laptop does not have an optical disk.
E xercise 2.3.2: This exercise introduces another running example, concerning 
World War II capital ships. It involves the following relations:
C la s s e s (c la s s , ty p e, country, numGuns, b o re, displacem ent) 
Ships(name, c la s s , launched)
B attles(nam e, d ate)
Outcom es(ship, b a t t l e , r e s u lt)
Ships are built in “classes” from the same design, and the class is usually named 
for the first ship of that class. The relation C lasses records the name of the 
class, the type ( ’b b ’ for battleship or ’b e ’ for battlecruiser), the country that 
built the ship, the number of main guns, the bore (diameter of the gun barrel, 
in inches) of the main guns, and the displacement (weight, in tons). Relation 
Ships records the name of the ship, the name of its class, and the year in which 
the ship was launched. Relation B a ttle s gives the name and date of battles 
involving these ships, and relation Outcomes gives the result (sunk, damaged, 
or ok) for each ship in each battle.
Write the following declarations:
a) A suitable schema for relation C lasses.
b) A suitable schema for relation Ships.
c) A suitable schema for relation B a ttle s.
d) A suitable schema for relation Outcomes.
e) An alteration to your C lasses relation from (a) to delete the attribute 
bore.
f) An alteration to your Ships relation from (b) to include the attribute 
yard giving the shipyard where the ship was built.
38 CHAPTER 2. THE RELATIONAL MODEL OF DATA
2.4 An Algebraic Query Language
In this section, we introduce the data-manipulation aspect of the relational 
model. Recall that a data model is not just structure; it needs a way to query 
the data and to modify the data. To begin our study of operations on relations, 
we shall learn about a special algebra, called relational algebra, that consists of 
some simple but powerful ways to construct new relations from given relations. 
When the given relations are stored data, then the constructed relations can be 
answers to queries about this data.
Relational algebra is not used today as a query language in commercial 
DBMS’s, although some of the early prototypes did use this algebra directly. 
Rather, the “real” query language, SQL, incorporates relational algebra at its 
center, and many SQL programs are really “syntactically sugared” expressions 
of relational algebra. Further, when a DBMS processes queries, the first thing 
that happens to a SQL query is that it gets translated into relational algebra 
or a very similar internal representation. Thus, there are several good reasons 
to start out learning this algebra.
2.4.1 Why Do We Need a Special Query Language?
Before introducing the operations of relational algebra, one should ask why, or 
whether, we need a new kind of programming languages for databases. Won’t 
conventional languages like C or Java suffice to ask and answer any computable 
question about relations? After all, we can represent a tuple of a relation by a 
struct (in C) or an object (in Java), and we can represent relations by arrays 
of these elements.
The surprising answer is that relational algebra is useful because it is less
powerful than C or Java. That is, there are computations one can perform in 
any conventional language that one cannot perform in relational algebra. An 
example is: determine whether the number of tuples in a relation is even or 
odd. By limiting what we can say or do in our query language, we get two huge 
rewards — ease of programming and the ability of the compiler to produce 
highly optimized code — that we discussed in Section 2.1.6.
2.4.2 What is an Algebra?
An algebra, in general, consists of operators and atomic operands. For instance, in the algebra of arithmetic, the atomic operands are variables like x
and constants like 15. The operators are the usual arithmetic ones: addition, 
subtraction, multiplication, and division. Any algebra allows us to build expressions by applying operators to atomic operands and/or other expressions 
of the algebra. Usually, parentheses are needed to group operators and their 
operands. For instance, in arithmetic we have expressions such as (x + y)* z or 
((x + 7)/(2/ -3 ) ) + x.
2.4. A N ALGEBRAIC QUERY LANGUAGE 39
Relational algebra is another example of an algebra. Its atomic operands 
are:
1. Variables that stand for relations.
2. Constants, which are finite relations.
We shall next see the operators of relational algebra.
2.4.3 Overview of Relational Algebra
The operations of the traditional relational algebra fall into four broad classes:
a) The usual set operations — union, intersection, and difference — applied 
to relations.
b) Operations that remove parts of a relation: “selection” eliminates some 
rows (tuples), and “projection” eliminates some columns.
c) Operations that combine the tuples of two relations, including “Cartesian 
product,” which pairs the tuples of two relations in all possible ways, and 
various kinds of “join” operations, which selectively pair tuples from two 
relations.
d) An operation called “renaming” that does not affect the tuples of a relation, but changes the relation schema, i.e., the names of the attributes 
and/or the name of the relation itself.
We generally shall refer to expressions of relational algebra as queries.
2.4.4 Set Operations on Relations
The three most common operations on sets are union, intersection, and difference. We assume the reader is familiar with these operations, which are defined 
as follows on arbitrary sets R and 5:
• RU S, the union of R and S, is the set of elements that are in R or 5 or 
both. An element appears only once in the union even if it is present in 
both R and S.
• R n S, the intersection of R and 5, is the set of elements that are in both 
R and S.
• R - S, the difference of R and S, is the set of elements that are in R but 
not in S. Note that R — S is different from S — R; the latter is the set of 
elements that are in S but not in R.
When we apply these operations to relations, we need to put some conditions 
on R and S:
40 CHAPTER 2. THE RELATIONAL MODEL OF DATA
1. R and S must have schemas with identical sets of attributes, and the 
types (domains) for each attribute must be the same in R and S.
2. Before we compute the set-theoretic union, intersection, or difference of 
sets of tuples, the columns of R and S must be ordered so that the order 
of attributes is the same for both relations.
Sometimes we would like to take the union, intersection, or difference of 
relations that have the same number of attributes, with corresponding domains, 
but that use different names for their attributes. If so, we may use the renaming 
operator to be discussed in Section 2.4.11 to change the schema of one or both 
relations and give them the same set of attributes.
name address gender birthdate
Carrie Fisher 123 Maple St., Hollywood F 9/9/99
Mark Hamill 456 Oak Rd., Brentwood M 8/8/88
Relation R
name address gender birthdate
Carrie Fisher 123 Maple St., Hollywood F 9/9/99
Harrison Ford 789 Palm Dr., Beverly Hills M 7/7/77
Relation S
Figure 2.12: Two relations
Exam ple 2.8: Suppose we have the two relations R and S, whose schemas 
are both that of relation MovieStar Section 2.2.8. Current instances of R and 
S are shown in Fig. 2.12. Then the union R U S is
name address gender birthdate
Carrie Fisher 123 Maple St., Hollywood F 9/9/99
Mark Hamill 456 Oak Rd., Brentwood M 8/8/88
Harrison Ford 789 Palm Dr., Beverly Hills M 7/7/77
Note that the two tuples for Carrie Fisher from the two relations appear only 
once in the result.
The intersection R fl 5 is
name_________ | address___________________| gender \ birthdate
Carrie Fisher | 123 Maple St., Hollywood | F | 9/9/99
Now, only the Carrie Fisher tuple appears, because only it is in both relations. 
The difference R — S is
2.4. A N ALGEBRAIC QUERY LANGUAGE 41
name______ | address______________ | gender | birthdate
Mark Hamill | 456 Oak Rd., Brentwood | M | 8/8/88
That is, the Fisher and Hamill tuples appear in R and thus are candidates for 
R — S. However, the Fisher tuple also appears in S and so is not in R — S. □
2.4.5 Projection
The projection operator is used to produce from a relation R a new relation 
that has only some of R ’s columns. The value of expression , a 2 ,... , A n (R) is 
a relation that has only the columns for attributes A i,A 2 ,... , An of R. The 
schema for the resulting value is the set of attributes {A i,A 2,... , An}, which 
we conventionally show in the order listed.
title year length genre studioName producerC#
Star Weirs 1977 124 sciFi Fox 12345
Galaxy Quest 1999 104 comedy DreamWorks 67890
Wayne’s World 1992 95 comedy Paramount 99999
Figure 2.13: The relation Movies
Example 2.9: Consider the relation Movies with the relation schema described in Section 2.2.8. An instance of this relation is shown in Fig. 2.13. We 
can project this relation onto the first three attributes with the expression:
'K title ,y e a r,len g th (Movies)
The resulting relation is
title year length
Star Wars 1977 124
Galaxy Quest 1999 104
Wayne’s World 1992 95
As another example, we can project onto the attribute genre with the expression ngenre(Movies). The result is the single-column relation
genre
sciFi
comedy
Notice that there are only two tuples in the resulting relation, since the last two 
tuples of Fig. 2.13 have the same value in their component for attribute genre, 
and in the relational algebra of sets, duplicate tuples are always eliminated. □
42 CHAPTER 2. THE RELATIONAL MODEL OF DATA
A Note About Data Quality :-)
While we have endeavored to make example data as accurate as possible, 
we have used bogus values for addresses and other personal information 
about movie stars, in order to protect the privacy of members of the acting 
profession, many of whom are shy individuals who shun publicity.
2.4.6 Selection
The selection operator, applied to a relation R, produces a new relation with a 
subset of R ’s tuples. The tuples in the resulting relation are those that satisfy 
some condition C that involves the attributes of R. We denote this operation 
ac{R)- The schema for the resulting relation is the same as R ’s schema, and 
we conventionally show the attributes in the same order as we use for R.
C is a conditional expression of the type with which we are familiar from 
conventional programming languages; for example, conditional expressions follow the keyword i f in programming languages such as C or Java. The only 
difference is that the operands in condition C are either constants or attributes 
of R. We apply C to each tuple t of R by substituting, for each attribute A
appearing in condition C, the component of t for attribute A. If after substituting for each attribute of C the condition C is true, then t is one of the tuples 
that appear in the result of ac(R); otherwise t is not in the result.
E xam ple 2.10: Let the relation Movies be as in Fig. 2.13. Then the value of 
expression aiength>ioo (Movies) is
title year length genre studioName producerC#
Star Weirs 1977 124 sciFi Fox 12345
Galaxy Quest 1999 104 comedy DreamWorks 67890
The first tuple satisfies the condition length > 100 because when we substitute 
for length the value 124 found in the component of the first tuple for attribute 
length, the condition becomes 124 > 100. The latter condition is true, so we 
accept the first tuple. The same argument explains why the second tuple of 
Fig. 2.13 is in the result.
The third tuple has a length component 95. Thus, when we substitute for 
length we get the condition 95 > 100, which is false. Hence the last tuple of 
Fig. 2.13 is not in the result. □
E xam ple 2.11: Suppose we want the set of tuples in the relation Movies that 
represent Fox movies at least 100 minutes long. We can get these tuples with 
a more complicated condition, involving the AND of two sub conditions. The 
expression is
& length> 100 AND s tu d io Name—* Fox’ (Movies)
The tuple
title_______| year \ length \ genre \ studioName | producerC#
Star Wars | 1977 | 124 | sciFi | Fox | 12345
is the only one in the resulting relation. □
2.4.7 Cartesian Product
The Cartesian product (or cross-product, or just product) of two sets R and 
S is the set of pairs that can be formed by choosing the first element of the 
pair to be any element of R and the second any element of S. This product 
is denoted R x S. When R and S are relations, the product is essentially the 
same. However, since the members of R and S are tuples, usually consisting 
of more than one component, the result of pairing a tuple from R with a tuple 
from S is a longer tuple, with one component for each of the components of the 
constituent tuples. By convention, the components from R (the left operand) 
precede the components from S in the attribute order for the result.
The relation schema for the resulting relation is the union of the schemas 
for R and S. However, if R and S should happen to have some attributes in 
common, then we need to invent new names for at least one of each pair of 
identical attributes. To disambiguate an attribute A that is in the schemas of 
both R and 5, we use R.A for the attribute from R and S.A for the attribute 
from S.
Exam ple 2.12: For conciseness, let us use an abstract example that illustrates 
the product operation. Let relations R and S have the schemas and tuples 
shown in Fig. 2.14(a) and (b). Then the product R x S consists of the six 
tuples shown in Fig. 2.14(c). Note how we have paired each of the two tuples of 
R with each of the three tuples of S. Since B is an attribute of both schemas, 
we have used R.B and S.B in the schema for R x S. The other attributes are 
unambiguous, and their names appear in the resulting schema unchanged. □
2.4.8 Natural Joins
More often than we want to take the product of two relations, we find a need to 
join them by pairing only those tuples that match in some way. The simplest 
sort of match is the natural join of two relations R and 5, denoted R x S, in 
which we pair only those tuples from R and S that agree in whatever attributes 
are common to the schemas of R and S. More precisely, let A \ , A2 ,... , An be 
all the attributes that are in both the schema of R and the schema of S. Then 
a tuple r from R and a tuple s from S are successfully paired if and only if r 
and s agree on each of the attributes A i, A2 , ■ ■ ■ , An.
If the tuples r and s are successfully paired in the join R tx S, then the 
result of the pairing is a tuple, called the joined tuple, with one component for 
each of the attributes in the union of the schemas of R and S. The joined tuple
2.4. A N ALGEBRAIC QUERY LANGUAGE 43
44 CHAPTER 2. THE RELATIONAL MODEL OF DATA
A B
1 2
3 4
(a) Relation R
B C D
2 5 6
4 7 8
9 10 11
(b) Relation S
A R.B S.B C D
1 2 2 5 6
1 2 4 7 8
1 2 9 10 11
3 4 2 5 6
3 4 4 7 8
3 4 9 10 11
(c) Result R x S
Figure 2.14: Two relations and their Cartesian product
agrees with tuple r in each attribute in the schema of R, and it agrees with 
s in each attribute in the schema of S. Since r and s are successfully paired, 
the joined tuple is able to agree with both these tuples on the attributes they 
have in common. The construction of the joined tuple is suggested by Fig. 2.15. 
However, the order of the attributes need not be that convenient; the attributes 
of R and 5 can appear in any order.
Exam ple 2.13: The natural join of the relations R and 5 from Fig. 2.14(a) 
and (b) is
A B c D
1 2 5 6
3 4 7 8
The only attribute common to R and S is B. Thus, to pair successfully, tuples 
need only to agree in their B components. If so, the resulting tuple has components for attributes A (from R), B (from either R or S), C (from S), and D
(from S).
2.4. A N ALGEBRAIC QUERY LANGUAGE 45
R
________ S
Figure 2.15: Joining tuples
In this example, the first tuple of R successfully pairs with only the first 
tuple of 5; they share the value 2 on their common attribute B. This pairing 
yields the first tuple of the result: (1,2,5,6). The second tuple of R pairs 
successfully only with the second tuple of S, and the pairing yields (3,4,7,8). 
Note that the third tuple of S does not pair with any tuple of R and thus has 
no effect on the result of R tx S. A tuple that fails to pair with any tuple of 
the other relation in a join is said to be a dangling tuple. □
E xam ple 2.14: The previous example does not illustrate all the possibilities 
inherent in the natural join operator. For example, no tuple paired successfully 
with more than one tuple, and there was only one attribute in common to the 
two relation schemas. In Fig. 2.16 we see two other relations, U and V, that 
share two attributes between their schemas: B and C. We also show an instance 
in which one tuple joins with several tuples.
For tuples to pair successfully, they must agree in both the B and C components. Thus, the first tuple of U joins with the first two tuples of V, while 
the second and third tuples of U join with the third tuple of V. The result of 
these four pairings is shown in Fig. 2.16(c). □
2.4.9 Theta-Joins
The natural join forces us to pair tuples using one specific condition. While this 
way, equating shared attributes, is the most common basis on which relations 
are joined, it is sometimes desirable to pair tuples from two relations on some 
other basis. For that purpose, we have a related notation called the thetajoin. Historically, the “theta” refers to an arbitrary condition, which we shall 
represent by C rather than 9.
The notation for a theta-join of relations R and S based on condition C is 
R ix c S. The result of this operation is constructed as follows:
1. Take the product of R and S.
2. Select from the product only those tuples that satisfy the condition C.
46 CHAPTER 2. THE RELATIONAL MODEL OF DATA
A B C
1 2 3
6 7 8
9 7 8
(a) Relation U
B c D
2 3 4
2 3 5
7 8 10
(b) Relation V
A B C D
1 2 3 4
1 2 3 5
6 7 8 10
9 7 8 10
(c) Result U xi V
Figure 2.16: Natural join of relations
As with the product operation, the schema for the result is the union of the 
schemas of R and S, with “R ” or “S.” prefixed to attributes if necessary to 
indicate from which schema the attribute came.
Exam ple 2.15: Consider the operation U ^ a < d V, where U and V are the 
relations from Fig. 2.16(a) and (b). We must consider all nine pairs of tuples, 
one from each relation, and see whether the A component from the [/-tuple 
is less than the D component of the F-tuple. The first tuple of U, with an A
component of 1, successfully pairs with each of the tuples from V. However, the 
second and third tuples from U, with A components of 6 and 9, respectively, 
pair successfully with only the last tuple of V . Thus, the result has only five 
tuples, constructed from the five successful pairings. This relation is shown in 
Fig. 2.17. □
Notice that the schema for the result in Fig. 2.17 consists of all six attributes, 
with U and V prefixed to their respective occurrences of attributes B and C to 
distinguish them. Thus, the theta-join contrasts with natural join, since in the 
latter common attributes are merged into one copy. Of course it makes sense to
2.4. A N ALGEBRAIC Q UERY LANG UAGE 47
A U.B U.C V.B V.C D
1 2 3 2 3 4
1 2 3 2 3 5
1 2 3 7 8 10
6 7 8 7 8 10
9 7 8 7 8 10
Figure 2.17: Result of U ixi a < d V
do so in the case of the natural join, since tuples don’t pair unless they agree in 
their common attributes. In the case of a theta-join, there is no guarantee that 
compared attributes will agree in the result, since they may not be compared 
with =.
E xam ple 2.16: Here is a theta-join on the same relations U and V that has 
a more complex condition:
u IX A < D AND U . B ^ V . B V
That is, we require for successful pairing not only that the A component of the 
[/-tuple be less than the D component of the V-tuple, but that the two tuples 
disagree on their respective B components. The tuple
A | U.B | U.C | V.B | V.C 1 D
1 | 2 |~~3 ["7 |~8 | 10
is the only one to satisfy both conditions, so this relation is the result of the 
theta-join above. □
2.4.10 Combining Operations to Form Queries
If all we could do was to write single operations on one or two relations as 
queries, then relational algebra would not be nearly as useful as it is. However, 
relational algebra, like all algebras, allows us to form expressions of arbitrary 
complexity by applying operations to the result of other operations.
One can construct expressions of relational algebra by applying operators 
to subexpressions, using parentheses when necessary to indicate grouping of 
operands. It is also possible to represent expressions as expression trees; the 
latter often are easier for us to read, although they are less convenient as a 
machine-readable notation.
E xam ple 2.17: Suppose we want to know, from our running Movies relation, 
“What are the titles and years of movies made by Fox that are at least 100 
minutes long?” One way to compute the answer to this query is:
1. Select those Movies tuples that have length > 100.
48 CHAPTER 2. THE RELATIONAL MODEL OF DATA
2. Select those Movies tuples that have studioName = ’Fox’.
3. Compute the intersection of (1) and (2).
4. Project the relation from (3) onto attributes t i t l e and year.
K . , title, year
n
C length >= 100
Movies Movies
Figure 2.18: Expression tree for a relational algebra expression
In Fig. 2.18 we see the above steps represented as an expression tree. Expression trees are evaluated bottom-up by applying the operator at an interior 
node to the arguments, which are the results of its children. By proceeding 
bottom-up, we know that the arguments will be available when we need them. 
The two selection nodes correspond to steps (1) and (2). The intersection node 
corresponds to step (3), and the projection node is step (4).
Alternatively, we could represent the same expression in a conventional, 
linear notation, with parentheses. The formula
71"title ^y ea r ovies) n GstudioName= * Fox ’ (Movies))
represents the same expression.
Incidentally, there is often more than one relational algebra expression that 
represents the same computation. For instance, the above query could also be 
written by replacing the intersection by logical AND within a single selection 
operation. That is,
7Ttitle ,y e a r ( ^ le n g th > 100 AND s tu d io N a m e = >F o x i (Movies)^
is an equivalent form of the query. □
2.4. A N ALGEBRAIC QUERY LANGUAGE 49
Equivalent Expressions and Query Optimization
All database systems have a query-answering system, and many of them 
are based on a language that is similar in expressive power to relational 
algebra. Thus, the query asked by a user may have many equivalent expressions (expressions that produce the same answer whenever they are 
given the same relations as operands), and some of these may be much 
more quickly evaluated. An important job of the query “optimizer” discussed briefly in Section 1.2.5 is to replace one expression of relational 
algebra by an equivalent expression that is more efficiently evaluated.
2.4.11 Naming and Renaming
In order to control the names of the attributes used for relations that are constructed by applying relational-algebra operations, it is often convenient to 
use an operator that explicitly renames relations. We shall use the operator 
Ps(Ai,A2,-.. ,a„)(R) to rename a relation R. The resulting relation has exactly 
the same tuples as R, but the name of the relation is S. Moreover, the attributes of the result relation S are named Ai, A2 , . .. ,A n, in order from the 
left. If we only want to change the name of the relation to S and leave the 
attributes as they are in R, we can just say ps(R)-
E xam ple 2 .1 8 : In Example 2.12 we took the product of two relations R and 
S from Fig. 2.14(a) and (b) and used the convention that when an attribute 
appears in both operands, it is renamed by prefixing the relation name to it. 
Suppose, however, that we do not wish to call the two versions of B by names 
R.B and S.B; rather we want to continue to use the name B for the attribute 
that comes from R, and we want to use X as the name of the attribute B
coming from S. We can rename the attributes of S so the first is called X . The 
result of the expression ps(x,c,D )(S) is a relation named S that looks just like 
the relation 5 from Fig. 2.14, but its first column has attribute X instead of B.
A B X C D
1 2 2 5 6
1 2 4 7 8
1 2 9 10 11
3 4 2 5 6
3 4 4 7 8
3 4 9 10 11
Figure 2.19: R x pS(x,c,D){S)
50 CHAPTER 2. THE RELATIONAL MODEL OF DATA
When we take the product of R with this new relation, there is no conflict 
of names among the attributes, so no further renaming is done. That is, the 
result of the expression R x P s ( x , c , D ) ( S ) is the relation R x S from Fig. 2.14(c), 
except that the five columns are labeled A, B, X , C, and D, from the left. This 
relation is shown in Fig. 2.19.
As an alternative, we could take the product without renaming, as we did 
in Example 2.12, and then rename the result. The expression
yields the same relation as in Fig. 2.19, with the same set of attributes. But 
this relation has a name, RS, while the result relation in Fig. 2.19 has no name.
□
2.4.12 Relationships Among Operations
Some of the operations that we have described in Section 2.4 can be expressed 
in terms of other relational-algebra operations. For example, intersection can 
be expressed in terms of set difference:
That is, if R and S are any two relations with the same schema, the intersection 
of R and S can be computed by first subtracting 5 from R to form a relation 
T consisting of all those tuples in R but not S. We then subtract T from R,
leaving only those tuples of R that are also in S.
The two forms of join are also expressible in terms of other operations. 
Theta-join can be expressed by product and selection:
The natural join of R and S can be expressed by starting with the product 
R x S . We then apply the selection operator with a condition C of the form
R.Ax = S.Ai AND R.A2 = S.A2 AND • • • AND R.An = S.An
where A i, A2,... , An are all the attributes appearing in the schemas of both R
and S. Finally, we must project out one copy of each of the equated attributes. 
Let L be the list of attributes in the schema of R followed by those attributes 
in the schema of S that are not also in the schema of R. Then
E xam ple 2.19: The natural join of the relations U and V from Fig. 2.16 can 
be written in terms of product, selection, and projection as:
P r s ( a , b , x , c , d ) ( R x S)
R r \ S = R - ( R - S )
R ix c S = ac(R x S)
7TA , U .B ,U .C ,D \ c r u .B = V .B AND U . G = V . c { U X V
2.4. A N ALGEBRAIC QUERY LANGUAGE 51
That is, we take the product U x V. Then we select for equality between each 
pair of attributes with the same name — B and C in this example. Finally, 
we project onto all the attributes except one of the B ’s and one of the C ’s; we 
have chosen to eliminate the attributes of V whose names also appear in the 
schema of U.
For another example, the theta-join of Example 2.16 can be written 
a A < D AND U .B j: V .B { U X V)
That is, we take the product of the relations U and V and then apply the 
condition that appeared in the theta-join. □
The rewriting rules mentioned in this section are the only “redundancies” 
among the operations that we have introduced. The six remaining operations — 
union, difference, selection, projection, product, and renaming — form an independent set, none of which can be written in terms of the other five.
2.4.13 A Linear Notation for Algebraic Expressions
In Section 2.4.10 we used an expression tree to represent a complex expression 
of relational algebra. An alternative is to invent names for the temporary 
relations that correspond to the interior nodes of the tree and write a sequence 
of assignments that create a value for each. The order of the assignments is 
flexible, as long as the children of a node N have had their values created before 
we attempt to create the value for N itself.
The notation we shall use for assignment statements is:
1. A relation name and parenthesized list of attributes for that relation. The 
name Answer will be used conventionally for the result of the final step;
i.e., the name of the relation at the root of the expression tree.
2. The assignment symbol :=.
3. Any algebraic expression on the right. We can choose to use only one 
operator per assignment, in which case each interior node of the tree gets 
its own assignment statement. However, it is also permissible to combine 
several algebraic operations in one right side, if it is convenient to do so.
E xam ple 2.20: Consider the tree of Fig. 2.18. One possible sequence of assignments to evaluate this expression is:
R(t,y,l,i,s,p) := criength>ioo (Movies)
S (t ,y, 1, i , s ,p) := <JgtudioName=’¥ojL’ (Movies) 
T(t,y,l,i,s,p) := R n S 
Answer (title, year) := 71"^ (T)
52 CHAPTER 2. THE RELATIONAL MODEL OF DATA
The first step computes the relation of the interior node labeled u i e n g th > 100 in 
Fig. 2.18, and the second step computes the node labeled (T3tu d io N a m e = ’Fox’- 
Notice that we get renaming “for free,” since we can use any attributes and 
relation name we wish for the left side of an assignment. The last two steps 
compute the intersection and the projection in the obvious way.
It is also permissible to combine some of the steps. For instance, we could 
combine the last two steps and write:
R(t,y,l,i,s,p) := aiength>ioo (Movies)
S (t, y , 1, i , S , p) (J s tu d io N a m e —’Fox’ (Movies)
Answer (title, year) := ir^yCR fl S)
We could even substitute for R and S in the last line and write the entire 
expression in one line. □
2.4.14 Exercises for Section 2.4
Exercise 2.4.1: This exercise builds upon the products schema of Exercise 
2.3.1. Recall that the database schema consists of four relations, whose schemas 
are:
Product(maker, model, type)
PC(model, speed, ram, hd, price)
Laptop(model, speed, ram, hd, screen, price)
Printer(model, color, type, price)
Some sample data for the relation Product is shown in Fig. 2.20. Sample 
data for the other three relations is shown in Fig. 2.21. Manufacturers and 
model numbers have been “sanitized,” but the data is typical of products on 
sale at the beginning of 2007.
Write expressions of relational algebra to answer the following queries. You 
may use the linear notation of Section 2.4.13 if you wish. For the data of Figs. 
2.20 and 2.21, show the result of your query. However, your answer should work 
for arbitrary data, not just the data of these figures.
a) What PC models have a speed of at least 3.00?
b) Which manufacturers make laptops with a hard disk of at least 100GB?
c) Find the model number and price of all products (of any type) made by 
manufacturer B.
d) Find the model numbers of all color laser printers.
e) Find those manufacturers that sell Laptops, but not PC’s.
! f) Find those hard-disk sizes that occur in two or more PC’s.
2.4. A N ALGEBRAIC QUERY LANGUAGE 53
maker model type
A 1001 pc
A 1002 pc
A 1003 pc
A 2004 laptop
A 2005 laptop
A 2006 laptop
B 1004 pc
B 1005 pc
B 1006 pc
B 2007 laptop
C 1007 pc
D 1008 pc
D 1009 pc
D 1010 pc
D 3004 printer
D 3005 printer
E 1011 pc
E 1012 pc
E 1013 pc
E 2001 laptop
E 2002 laptop
E 2003 laptop
E 3001 printer
E 3002 printer
E 3003 printer
F 2008 laptop
F 2009 laptop
G 2010 laptop
H 3006 printer
H 3007 printer
Figure 2.20: Sample data for Product
CHAPTER 2. THE RELATIONAL MODEL OF DATA
model speed ram hd price
1001 2.6 6 1024 250 2114
1002 2 .1 0 512 250 995
1003 1.42 512 80 478
1004 2.80 1024 250 649
1005 3.20 512 250 630
1006 3.20 1024 320 1049
1007 2 .2 0 1024 200 510
1008 2.2 0 2048 250 770
1009 2.0 0 1024 250 650
1010 2.80 2048 300 770
1011 1.86 2048 160 959
1012 2.80 1024 160 649
1013 3.06 512 80 529
(a) Sample data for relation PC
model speed ram hd screen price
2001 2 .0 0 2048 240 20.1 3673
2002 1.73 1024 80 17.0 949
2003 1.80 512 60 15.4 549
2004 2 .0 0 512 60 13.3 1150
2005 2.16 1024 120 17.0 2500
2006 2 .0 0 2048 80 15.4 1700
2007 1.83 1024 120 13.3 1429
2008 1.60 1024 100 15.4 900
2009 1.60 512 80 14.1 680
2010 2.0 0 2048 160 15.4 2300
(b) Sample data for relation Laptop
model color type price
3001 tru e in k -j e t 99
3002 fa ls e la s e r 239
3003 tru e la s e r 899
3004 tru e in k -je t 120
3005 fa lse la se r 120
3006 tru e in k -je t 100
3007 tru e la s e r 200
(c) Sample data for relation P rin te r
Figure 2.21: Sample data for relations of Exercise 2.4.1
2.4. A N ALGEBRAIC QUERY LANGUAGE 55
! g) Find those pairs of PC models that have both the same speed and RAM. 
A pair should be listed only once; e.g., list (i, j) but not (j, i).
!! h) Find those manufacturers of at least two different computers (PC’s or 
laptops) with speeds of at least 2.80.
!! i) Find the manufacturer(s) of the computer (PC or laptop) with the highest 
available speed.
!! j) Find the manufacturers of PC’s with at least three different speeds.
!! k) Find the manufacturers who sell exactly three different models of PC.
Exercise 2.4.2: Draw expression trees for each of your expressions of Exercise 2.4.1.
E xercise 2.4.3: This exercise builds upon Exercise 2.3.2 concerning World 
War II capital ships. Recall it involves the following relations:
Classes(class, type, country, numGuns, bore, displacement) 
Ships(name, class, launched)
Battles(name, date)
Outcomes(ship, battle, result)
Figures 2.22 and 2.23 give some sample data for these four relations.4 Note 
that, unlike the data for Exercise 2.4.1, there are some “dangling tuples” in this 
data, e.g., ships mentioned in Outcomes that are not mentioned in Ships.
Write expressions of relational algebra to answer the following queries. You 
may use the linear notation of Section 2.4.13 if you wish. For the data of Figs. 
2.22 and 2.23, show the result of your query. However, your answer should work 
for arbitrary data, not just the data of these figures.
a) Give the class names and countries of the classes that carried guns of at 
least 16-inch bore.
b) Find the ships launched prior to 1921.
c) Find the ships sunk in the battle of the Denmark Strait.
d) The treaty of Washington in 1921 prohibited capital ships heavier than 
35,000 tons. List the ships that violated the treaty of Washington.
e) List the name, displacement, and number of guns of the ships engaged in 
the battle of Guadalcanal.
f) List all the capital ships mentioned in the database. (Remember that all 
these ships may not appear in the Ships relation.)
4Source: J. N. W estw ood, F ighting Ships o f W orld W ar II, Follett P ublishing, Chicago, 
1975 an d R . C. S tern, US B attleships in A ction, S q u adron/S ignal P ublications, C arrollton, 
T X , 1980.
56 CHAPTER 2. THE RELATIONAL MODEL OF DATA
class type country numGuns bore displacement
Bismarck bb Germany 8 15 42000
Iowa bb USA 9 16 46000
Kongo be Japan 8 14 32000
North Carolina bb USA 9 16 37000
Renown be Gt. Britain 6 15 32000
Revenge bb Gt. Britain 8 15 29000
Tennessee bb USA 12 14 32000
Yamato bb Japan 9 18 65000
(a) Sample data for relation Classes
name date
Denmark Strait 5/24-27/41
Guadalcanal 11/15/42
North Cape 12/26/43
Surigao Strait 10/25/44
(b) Sample data for relation Battles
ship battle result
Arizona Pearl Harbor sunk
Bismarck Denmark Strait sunk
California Surigao Strait ok
Duke of York North Cape ok
Fuso Surigao Strait sunk
Hood Denmark Strait sunk
King George V Denmark Strait ok
Kirishima Guadalcanal sunk
Prince of Wales Denmark Strait damaged
Rodney Denmark Strait ok
Scharnhorst North Cape sunk
South Dakota Guadalcanal damaged
Tennessee Surigao Strait ok
Washington Guadalcanal ok
West Virginia Surigao Strait ok
Yamashiro Surigao Strait sunk
(c) Sample data for relation Outcomes
Figure 2.22: Data for Exercise 2.4.3
2.4. A N ALGEBRAIC QUERY LANGUAGE 57
name class launched
California Tennessee 1921
Haruna Kongo 1915
Hiei Kongo 1914
Iowa Iowa 1943
Kirishima Kongo 1915
Kongo Kongo 1913
Missouri Iowa 1944
Musashi Yamato 1942
New Jersey Iowa 1943
North Carolina North Carolina 1941
Ramillies Revenge 1917
Renown Renown 1916
Repulse Renown 1916
Resolution Revenge 1916
Revenge Revenge 1916
Royal Oak Revenge 1916
Royal Sovereign Revenge 1916
Tennessee Tennessee 1920
Washington North Carolina 1941
Wisconsin Iowa 1944
Yamato Yamato 1941
Figure 2.23: Sample data for relation Ships
! g) Find the classes that had only one ship as a member of that class.
! h) Find those countries that had both battleships and battlecruisers.
! i) Find those ships that “lived to fight another day”; they were damaged in 
one battle, but later fought in another.
Exercise 2.4.4: Draw expression trees for each of your expressions of Exercise 2.4.3.
Exercise 2.4.5: What is the difference between the natural join R ix S and 
the theta-join R \xc S where the condition C is that R.A = S.A for each 
attribute A appearing in the schemas of both R and S'!
Exercise 2.4.6: An operator on relations is said to be monotone if whenever 
we add a tuple to one of its arguments, the result contains all the tuples that 
it contained before adding the tuple, plus perhaps more tuples. Which of the 
operators described in this section are monotone? For each, either explain why 
it is monotone or give an example showing it is not.
58 CHAPTER 2. THE RELATIONAL MODEL OF DATA
Exercise 2.4.7: Suppose relations R and S have n tuples and m tuples, respectively. Give the minimum and maximum numbers of tuples that the results 
of the following expressions can have.
a) R U S.
b) R tx S .
c) ac(R) x S, for some condition C.
d) 7tl (R) — S, for some list of attributes L.
Exercise 2.4.8: The semijoin of relations R and S, written R IX S, is the set 
of tuples t in R such that there is at least one tuple in S that agrees with t in 
all attributes that R and S have in common. Give three different expressions 
of relational algebra that are equivalent to R X S.
Exercise 2.4.9: The antisemijoin R X S is the set of tuples t in R that do 
not agree with any tuple of S in the attributes common to R and 5. Give an 
expression of relational algebra equivalent to R t x S.
Exercise 2.4.10: Let R be a relation with schema
(Ai,A2, ... ,An,Bi,B2, ■.. ,Bm)
and let 5 be a relation with schema (i?i,# 2,• • ■ , Bm); that is, the attributes 
of S are a subset of the attributes of R. The quotient of R and S, denoted 
R-i- S, is the set of tuples t over attributes A i, A2, ... ,An (i.e., the attributes 
of R that are not attributes of S ) such that for every tuple s in S, the tuple 
ts, consisting of the components of t for Ai ,A 2,... ,A n and the components 
of s for B lyB 2,... , B rn, is a member of R. Give an expression of relational 
algebra, using the operators we have defined previously in this section, that is 
equivalent to R-r- S.
2.5 Constraints on Relations
We now take up the third important aspect of a data model: the ability to 
restrict the data that may be stored in a database. So far, we have seen only one 
kind of constraint, the requirement that an attribute or attributes form a key 
(Section 2.3.6). These and many other kinds of constraints can be expressed in 
relational algebra. In this section, we show how to express both key constraints 
and “referential-integrity” constraints; the latter require that a value appearing 
in one column of one relation also appear in some other column of the same 
or a different relation. In Chapter 7, we see how SQL database systems can 
enforce the same sorts of constraints as we can express in relational algebra.
2.5. CONSTRAINTS ON RELATIONS 59
2.5.1 Relational Algebra as a Constraint Language
There are two ways in which we can use expressions of relational algebra to 
express constraints.
1. If R is an expression of relational algebra, then R = 0 is a constraint 
that says “The value of R must be empty,” or equivalently “There are no 
tuples in the result of R.”
2. If R and S are expressions of relational algebra, then R C S is a constraint 
that says “Every tuple in the result of R must also be in the result of 5 .” 
Of course the result of S may contain additional tuples not produced by 
R.
These ways of expressing constraints are actually equivalent in what they 
can express, but sometimes one or the other is clearer or more succinct. That 
is, the constraint R C S could just as well have been written R — 5 = 0. To 
see why, notice that if every tuple in R is also in S, then surely R — S is empty. 
Conversely, if R — S contains no tuples, then every tuple in R must be in S (or 
else it would be in R — S ).
On the other hand, a constraint of the first form, R = 0, could just as 
well have been written R C 0. Technically, 0 is not an expression of relational 
algebra, but since there are expressions that evaluate to 0, such as R — R, there 
is no harm in using 0 as a relational-algebra expression.
In the following sections, we shall see how to express significant constraints 
in one of these two styles. As we shall see in Chapter 7, it is the first style — 
equal-to-the-emptyset — that is most commonly used in SQL programming. 
However, as shown above, we are free to think in terms of set-containment if 
we wish and later convert our constraint to the equal-to-the-emptyset style.
2.5.2 Referential Integrity Constraints
A common kind of constraint, called a referential integrity constraint, asserts 
that a value appearing in one context also appears in another, related context. 
For example, in our movies database, should we see a Starsln tuple that has 
person p in the starName component, we would expect that p appears as the 
name of some star in the MovieStar relation. If not, then we would question 
whether the listed “star” really was a star.
In general, if we have any value v as the component in attribute A of some 
tuple in one relation R, then because of our design intentions we may expect 
that v will appear in a particular component (say for attribute B) of some tuple 
of another relation S. We can express this integrity constraint in relational 
algebra as tta(R) Q b {S), or equivalently, tta(R) — ^ b (S) = 0.
E xam ple 2.21: Consider the two relations from our running movie database:
Movies(title, year, length, genre, studioName, producerC#) 
MovieExec(name, address, cert#, netWorth)
60 CHAPTER 2. THE RELATIONAL MODEL OF DATA
We might reasonably assume that the producer of every movie would have to 
appear in the MovieExec relation. If not, there is something wrong, and we 
would at least want a system implementing a relational database to inform us 
that we had a movie with a producer of which the database had no knowledge.
To be more precise, the producerC# component of each Movies tuple must 
also appear in the cert# component of some MovieExec tuple. Since executives 
are uniquely identified by their certificate numbers, we would thus be assured 
that the movie’s producer is found among the movie executives. We can express 
this constraint by the set-containment
7tproducerC#(.Movies) C ^cert#(MovieExec)
The value of the expression on the left is the set of all certificate numbers appearing in producerC# components of Movies tuples. Likewise, the expression 
on the right’s value is the set of all certificates in the cert# component of 
MovieExec tuples. Our constraint says that every certificate in the former set 
must also be in the latter set. □
Exam ple 2.22: We can similarly express a referential integrity constraint 
where the “value” involved is represented by more than one attribute. For 
instance, we may want to assert that any movie mentioned in the relation
Starsln(movieTitle, movieYear, starName)
also appears in the relation
Movies(title, year, length, genre, studioName, producerC#)
Movies are represented in both relations by title-year pairs, because we agreed 
that one of these attributes alone was not sufficient to identify a movie. The 
constraint
^ m o v ie T itle , m o v ieyear(StarsIn) C 7Ttitle, year(Movies)
expresses this referential integrity constraint by comparing the title-year pairs 
produced by projecting both relations onto the appropriate lists of components.
□
2.5.3 Key Constraints
The same constraint notation allows us to express far more than referential 
integrity. Here, we shall see how we can express algebraically the constraint 
that a certain attribute or set of attributes is a key for a relation.
E xam ple 2.23: Recall that name is the key for relation
MovieStar(name, address, gender, birthdate)
2.5. CONSTRAINTS ON RELATIONS 61
That is, no two tuples agree on the name component. We shall express algebraically one of several implications of this constraint: that if two tuples agree 
on name, then they must also agree on address. Note that in fact these “two” 
tuples, which agree on the key name, must be the same tuple and therefore 
certainly agree in all attributes.
The idea is that if we construct all pairs of MovieStar tuples (£1,(2), we 
must not find a pair that agree in the name component and disagree in the 
address component. To construct the pairs we use a Cartesian product, and 
to search for pairs that violate the condition we use a selection. We then assert 
the constraint by equating the result to 0.
To begin, since we are taking the product of a relation with itself, we need 
to rename at least one copy, in order to have names for the attributes of the 
product. For succinctness, let us use two new names, MSI and MS2, to refer 
to the MovieStar relation. Then the requirement can be expressed by the 
algebraic constraint:
& M S l.n a m e = M S £ .n a m e AND M S l.a d d r e s s ^ M S S .a d d r e s s i^SI X MS2) = 0 
In the above, MSI in the product MSI x MS2 is shorthand for the renaming:
P M S l(n a m e ,a d d r e ss ,g e n d e r,b ir th d a te ) (MovieStar) 
and MS2 is a similar renaming of MovieStar. □
2.5.4 Additional Constraint Examples
There are many other kinds of constraints that we can express in relational 
algebra and that are useful for restricting database contents. A large family 
of constraints involve the permitted values in a context. For example, the fact 
that each attribute has a type constrains the values of that attribute. Often 
the constraint is quite straightforward, such as “integers only” or “character 
strings of length up to 30.” Other times we want the values that may appear in 
an attribute to be restricted to a small enumerated set of values. Other times, 
there are complex limitations on the values that may appear. We shall give two 
examples, one of a simple domain constraint for an attribute, and the second a 
more complicated restriction.
E xam ple 2.24: Suppose we wish to specify that the only legal values for the 
gender attribute of MovieStar are ’ F ’ and ’ M ’. We can express this constraint 
algebraically by:
& g e n d e r ^ ’F’ AND g e n d e r ^ ’M”(MovieStar) = 0
That is, the set of tuples in MovieStar whose gender component is equal to 
neither ’ F ’ nor ’ M ’ is empty. □
62 CHAPTER 2. THE RELATIONAL MODEL OF DATA
Exam ple 2.25: Suppose we wish to require that one must have a net worth 
of at least $10,000,000 to be the president of a movie studio. We can express 
this constraint algebraically as follows. First, we need to theta-join the two 
relations
MovieExec(name, address, cert#, netWorth)
Studio(name, address, presC#)
using the condition that presC# from Studio and ce rt# from MovieExec are 
equal. That join combines pairs of tuples consisting of a studio and an executive, 
such that the executive is the president of the studio. If we select from this 
relation those tuples where the net worth is less than ten million, we have a set 
that, according to our constraint, must be empty. Thus, we may express the 
constraint as:
^ nc.t VV’ur’/./jCl0000000 (Studio XI p r e s C # = c e r t # MovieExec) 0
An alternative way to express the same constraint is to compare the set 
of certificates that represent studio presidents with the set of certificates that 
represent executives with a net worth of at least $10,000,000; the former must 
be a subset of the latter. The containment
'K p r e s C # (Studio) C 7 7 ( ^ n c t W o r th > J 0 0 0 0 0 0 0 (MoVieEx6c)^
expresses the above idea. □
2.5.5 Exercises for Section 2.5
Exercise 2.5.1: Express the following constraints about the relations of Exercise 2.3.1, reproduced here:
Product(maker, model, type)
PC(model, speed, ram, hd, price)
Laptop(model, speed, ram, hd, screen, price)
Printer(model, color, type, price)
You may write your constraints either as containments or by equating an expression to the empty set. For the data of Exercise 2.4.1, indicate any violations 
to your constraints.
a) A PC with a processor speed less than 2.00 must not sell for more than 
$500.
b) A laptop with a screen size less than 15.4 inches must have at least a 100 
gigabyte hard disk or sell for less than $1000.
! c) No manufacturer of PC’s may also make laptops.
2.6. SUMMARY OF CHAPTER 2 63
I! d) A manufacturer of a PC must also make a laptop with at least as great a 
processor speed.
! e) If a laptop has a larger main memory than a PC, then the laptop must 
also have a higher price than the PC.
Exercise 2.5.2: Express the following constraints in relational algebra. The 
constraints are based on the relations of Exercise 2.3.2:
Classes(class, type, country, numGuns, bore, displacement) 
Ships(name, class, launched)
Battles(name, date)
Outcomes(ship, battle, result)
You may write your constraints either as containments or by equating an expression to the empty set. For the data of Exercise 2.4.3, indicate any violations 
to your constraints.
a) No class of ships may have guns with larger than 16-inch bore.
b) If a class of ships has more than 9 guns, then their bore must be no larger 
than 14 inches.
! c) No class may have more than 2 ships.
! d) No country may have both battleships and battlecruisers.
!! e) No ship with more than 9 guns may be in a battle with a ship having 
fewer than 9 guns that was sunk.
! E xercise 2.5.3: Suppose R and S are two relations. Let C be the referential integrity constraint that says: whenever R has a tuple with some values 
v i, V2 , • ■. , vn in particular attributes A\ , ,... , An, there must be a tuple of S
that has the same values vi,v 2 ,... , vn in particular attributes B i , S 2, ■ ■ ■ , Bn.
Show how to express constraint C in relational algebra.
! E xercise 2.5.4: Another algebraic way to express a constraint is Ei = E2 ,
where both Ei and E2 are relational-algebra expressions. Can this form of 
constraint express more than the two forms we discussed in this section?
2.6 Summary of Chapter 2
♦ Data Models: A data model is a notation for describing the structure of 
the data in a database, along with the constraints on that data. The data 
model also normally provides a notation for describing operations on that 
data: queries and data modifications.
♦ Relational Model: Relations axe tables representing information. Columns 
are headed by attributes; each attribute has an associated domain, or 
data type. Rows are called tuples, and a tuple has one component for 
each attribute of the relation.
♦ Schemas: A relation name, together with the attributes of that relation 
and their types, form the relation schema. A collection of relation schemas 
forms a database schema. Particular data for a relation or collection of 
relations is called an instance of that relation schema or database schema.
♦ Keys: An important type of constraint on relations is the assertion that 
an attribute or set of attributes forms a key for the relation. No two 
tuples of a relation can agree on all attributes of the key, although they 
can agree on some of the key attributes.
♦ Semistructured Data Model: In this model, data is organized in a tree or 
graph structure. XML is an important example of a semistructured data 
model.
♦ SQL: The language SQL is the principal query language for relational 
database systems. The current standard is called SQL-99. Commercial 
systems generally vary from this standard but adhere to much of it.
♦ Data Definition: SQL has statements to declare elements of a database 
schema. The CREATE TABLE statement allows us to declare the schema 
for stored relations (called tables), specifying the attributes, their types, 
default values, and keys.
♦ Altering Schemas: We can change parts of the database schema with an 
ALTER statement. These changes include adding and removing attributes 
from relation schemas and changing the default value associated with an 
attribute. We may also use a DROP statement to completely eliminate 
relations or other schema elements.
♦ Relational Algebra: This algebra underlies most query languages for the 
relational model. Its principal operators are union, intersection, difference, selection, projection, Cartesian product, natural join, theta-join, 
and renaming.
♦ Selection and Projection: The selection operator produces a result consisting of all tuples of the argument relation that satisfy the selection 
condition. Projection removes undesired columns from the argument relation to produce the result.
♦ Joins: We join two relations by comparing tuples, one from each relation. 
In a natural join, we splice together those pairs of tuples that agree on all 
attributes common to the two relations. In a theta-join, pairs of tuples 
are concatenated if they meet a selection condition associated with the 
theta-join.
64 CHAPTER 2. THE RELATIONAL MODEL OF DATA
2.7. REFERENCES FOR CHAPTER 2 65
♦ Constraints in Relational Algebra: Many common kinds of constraints can 
be expressed as the containment of one relational algebra expression in 
another, or as the equality of a relational algebra expression to the empty 
set.
2.7 References for Chapter 2
The classic paper by Codd on the relational model is [1]. This paper introduces 
relational algebra, as well. The use of relational algebra to describe constraints 
is from [2], References for SQL are given in the bibliographic notes for Chapter 6.
The semistructured data model is from [3]. XML is a standard developed 
by the World-Wide-Web Consortium. The home page for information about 
XML is [4],
1. E. F. Codd, “A relational model for large shared data banks,” Comm.
ACM 13:6, pp. 377-387, 1970.
2. J.-M. Nicolas, “Logic for improving integrity checking in relational databases,” Acta Informatica 18:3, pp. 227-253, 1982.
3. Y. Papakonstantinou, H. Garcia-Molina, and J. Widom, “Object exchange across heterogeneous information sources,” IEEE Intl. Conf. on
Data Engineering, pp. 251-260, March 1995.
4. World-Wide-Web Consortium, http://www.w3.org/XML/

Chapter 3
Design Theory for
Relational Databases
There are many ways we could go about designing a relational database schema 
for an application. In Chapter 4 we shall see several high-level notations for 
describing the structure of data and the ways in which these high-level designs 
can be converted into relations. We can also examine the requirements for a 
database and define relations directly, without going through a high-level intermediate stage. Whatever approach we use, it is common for an initial relational 
schema to have room for improvement, especially by eliminating redundancy. 
Often, the problems with a schema involve trying to combine too much into 
one relation.
Fortunately, there is a well developed theory for relational databases: “dependencies,” their implications for what makes a good relational database 
schema, and what we can do about a schema if it has flaws. In this chapter, 
we first identify the problems that are caused in some relation schemas by the 
presence of certain dependencies; these problems are referred to as “anomalies.”
Our discussion starts with “functional dependencies,” a generalization of the 
idea of a key for a relation. We then use the notion of functional dependencies 
to define normal forms for relation schemas. The impact of this theory, called 
“normalization,” is that we decompose relations into two or more relations when 
that will remove anomalies. Next, we introduce “multivalued dependencies,” 
which intuitively represent a condition where one or more attributes of a relation 
are independent from one or more other attributes. These dependencies also 
lead to normal forms and decomposition of relations to eliminate redundancy.
3.1 Functional Dependencies
There is a design theory for relations that lets us examine a design carefully 
and make improvements based on a few simple principles. The theory begins by
67
6 8 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
having us state the constraints that apply to the relation. The most common 
constraint is the “functional dependency,” a statement of a type that generalizes 
the idea of a key for a relation, which we introduced in Section 2.5.3. Later in 
this chapter, we shall see how this theory gives us simple tools to improve our 
designs by the process of “decomposition” of relations: the replacement of one 
relation by several, whose sets of attributes together include all the attributes 
of the original.
3.1.1 Definition of Functional Dependency
A functional dependency (FD) on a relation R is a statement of the form “If two 
tuples of R agree on all of the attributes A-i,A2.... ,A„ (i.e., the tuples have 
the same values in their respective components for each of these attributes), 
then they must also agree on all of another list of attributes B±, B2 , ■ ■ ■ , B m.
We write this FD formally as Ai A 2 ■ ■ ■ An B 1 B2 ■ ■ ■ B m and say that
“A i,A 2 , ... , An functionally determine Bi, B2 , . ■ ■ , Bm”
Figure 3.1 suggests what this FD tells us about any two tuples t and u in the 
relation R. However, the ^4’s and B's can be anywhere; it is not necessary for 
the A’s and B ’s to appear consecutively or for the A’s to precede the B ’s.
If t and Then they 
u agree m ust agree 
here, here
Figure 3.1: The effect of a functional dependency on two tuples.
If we can be sure every instance of a relation R will be one in which a given 
FD is true, then we say that R satisfies the FD. It is important to remember 
that when we say that R satisfies an FD / , we are asserting a constraint on R,
not just saying something about one particular instance of R.
It is common for the right side of an FD to be a single attribute. In fact, 
we shall see that the one functional dependency A 1A2 ■ ■ ■ An —> B 1B2 ■ • ■ B m is 
equivalent to the set of FD’s:
A i A2 ■ • ■ A n — > B i
A\ A2 • • - An —> B2
A1A2 ■ ■ ■ A n —¥ B m
3.1. FUNCTIONAL DEPENDENCIES 69
title year length genre studioN am e starN am e
Star Wars 1977 124 SciFi Fox Carrie Fisher
Star Wars 1977 124 SciFi Fox Mark Hamill
Star Wars 1977 124 SciFi Fox Harrison Ford
Gone With the Wind 1939 231 drama MGM Vivien Leigh
Wayne’s World 1992 95 comedy Paramount Dana Carvey
Wayne’s World 1992 95 comedy Paramount Mike Meyers
Figure 3.2: An instance of the relation Moviesl(title, year, length, 
genre, studioName, starName)
E xam ple 3.1: Let us consider the relation
Moviesl(title, year, length, genre, studioName, starName)
an instance of which is shown in Fig. 3.2. While related to our running Movies 
relation, it has additional attributes, which is why we call it “Moviesl” instead of “Movies.” Notice that this relation tries to “do too much.” It holds 
information that in our running database schema was attributed to three different relations: Movies, Studio, and S ta rsln . As we shall see, the schema for 
Moviesl is not a good design. But to see what is wrong with the design, we 
must first determine the functional dependencies that hold for the relation. We 
claim that the following FD holds:
title year —> length genre studioName
Informally, this FD says that if two tuples have the same value in their 
title components, and they also have the same value in their year components, then these two tuples must also have the same values in their length 
components, the same values in their genre components, and the same values 
in their studioName components. This assertion makes sense, since we believe 
that it is not possible for there to be two movies released in the same year 
with the same title (although there could be movies of the same title released 
in different years). This point was discussed in Example 2.1. Thus, we expect 
that given a title and year, there is a unique movie. Therefore, there is a unique 
length for the movie, a unique genre, and a unique studio.
On the other hand, we observe that the statement
title year —> starName
is false; it is not a functional dependency. Given a movie, it is entirely possible 
that there is more than one star for the movie listed in our database. Notice 
that even had we been lazy and only listed one star for Star Wars and one star 
for Wayne’s World (just as we only listed one of the many stars for Gone With
the Wind), this FD would not suddenly become true for the relation Moviesl.
70 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
The reason is that the FD says something about all possible instances of the 
relation, not about one of its instances. The fact that we could have an instance 
with multiple stars for a movie rules out the possibility that title and year 
functionally determine starName. □
3.1.2 Keys of Relations
We say a set of one or more attributes {Ai,A 2 , ... , An} is a key for a relation 
R if:
1. Those attributes functionally determine all other attributes of the relation. That is, it is impossible for two distinct tuples of R to agree on all 
of A i, A2 ,... , An.
2. No proper subset of {Ai,A 2 ,... , An} functionally determines all other 
attributes of R; i.e., a key must be minimal.
When a key consists of a single attribute A, we often say that A (rather than 
{,4}) is a key.
Example 3.2: Attributes {title, year, starName} form a key for the relation 
Moviesl of Fig. 3.2. First, we must show that they functionally determine all 
the other attributes. That is, suppose two tuples agree on these three attributes: 
title, year, and starName. Because they agree on title and year, they must 
agree on the other attributes — length, genre, and studioName — as we 
discussed in Example 3.1. Thus, two different tuples cannot agree on all of 
title, year, and starName; they would in fact be the same tuple.
Now, we must argue that no proper subset of {title, year, starName} 
functionally determines all other attributes. To see why, begin by observing 
that title and year do not determine starName, because many movies have 
more than one star. Thus, {title, year} is not a key.
{year, starName} is not a key because we could have a star in two movies 
in the same year; therefore
year starName —» title
is not an FD. Also, we claim that {title, starName} is not a key, because two 
movies with the same title, made in different years, occasionally have a star in 
common.1 □
Sometimes a relation has more than one key. If so, it is common to designate one of the keys as the primary key. In commercial database systems, the 
choice of primary key can influence some implementation issues such as how 
the relation is stored on disk. However, the theory of FD’s gives no special role 
to “primary keys.”
1 Since we asserted in an earlier book th a t th ere were no known exam ples of th is phenom enon, several people have show n us we were w rong. I t’s an interesting challenge to 
discover sta rs th a t appeared in two versions of th e sam e movie.
3.1. FUNCTIONAL DEPENDENCIES 71
W hat Is “Functional” About Functional
Dependencies?
A1 A2 ■ ■ ■ An —» B is called a “functional” dependency because in principle 
there is a function that takes a list of values, one for each of attributes 
A i,A 2 ,... , A n and produces a unique value (or no value at all) for B.
For instance, in the Moviesl relation, we can imagine a function that 
takes a string like "Star Wars" and an integer like 1977 and produces the 
unique value of length, namely 124, that appears in the relation Moviesl. 
However, this function is not the usual sort of function that we meet in 
mathematics, because there is no way to compute it from first principles. 
That is, we cannot perform some operations on strings like "Star Wars" 
and integers like 1977 and come up with the correct length. Rather, the 
function is only computed by lookup in the relation. We look for a tuple 
with the given title and year values and see what value that tuple has 
for length.
3.1.3 Superkeys
A set of attributes that contains a key is called a superkey, short for “superset 
of a key.” Thus, every key is a superkey. However, some superkeys are not 
(minimal) keys. Note that every superkey satisfies the first condition of a key: it 
functionally determines all other attributes of the relation. However, a superkey 
need not satisfy the second condition: minimality.
E xam ple 3.3: In the relation of Example 3.2, there are many superkeys. Not 
only is the key
{title, year, starName} 
a superkey, but any superset of this set of attributes, such as 
{title, year, starName, length, studioName} 
is a superkey. □
3.1.4 Exercises for Section 3.1
E xercise 3.1.1: Consider a relation about people in the United States, including their name, Social Security number, street address, city, state, ZIP code, 
area code, and phone number (7 digits). What FD’s would you expect to hold? 
What are the keys for the relation? To answer this question, you need to know 
something about the way these numbers are assigned. For instance, can an area
72 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
Other Key Terminology
In some books and articles one finds different terminology regarding keys. 
One can find the term “key” used the way we have used the term “superkey,” that is, a set of attributes that functionally determine all the 
attributes, with no requirement of minimality. These sources typically use 
the term “candidate key” for a key that is minimal — that is, a “key” in 
the sense we use the term.
code straddle two states? Can a ZIP code straddle two area codes? Can two 
people have the same Social Security number? Can they have the same address 
or phone number?
E xercise 3.1.2: Consider a relation representing the present position of molecules in a closed container. The attributes are an ID for the molecule, the x, y,
and z coordinates of the molecule, and its velocity in the x, y, and z dimensions. 
What FD’s would you expect to hold? What are the keys?
E xercise 3.1.3: Suppose R is a relation with attributes A 1,A 2, .. . , An. As a 
function of n, tell how many superkeys R has, if:
a) The only key is Ai.
b) The only keys are Ai and Aic) The only keys are { y li,^ } and {Ag,Ai}.
d) The only keys are { ^ 1, ^ 2} and
3.2 Rules About Functional Dependencies
In this section, we shall learn how to reason about FD’s. That is, suppose we 
are told of a set of FD’s that a relation satisfies. Often, we can deduce that the 
relation must satisfy certain other FD’s. This ability to discover additional FD’s 
is essential when we discuss the design of good relation schemas in Section 3.3.
3.2.1 Reasoning About Functional Dependencies
Let us begin with a motivating example that will show us how we can infer a 
functional dependency from other given FD’s.
E xam ple 3.4: If we are told that a relation R(A, B, C) satisfies the FD’s 
A —> B and B —> C, then we can deduce that R also satisfies the FD A —> C.
How does that reasoning go? To prove that A C, we must consider two 
tuples of R that agree on A and prove they also agree on C.
3.2. RULES ABOU T FUNCTIONAL DEPENDENCIES 73
Let the tuples agreeing on attribute A be (a, 61, C i ) and (0 , 62, 02). Since R
satisfies A B , and these tuples agree on A, they must also agree on B. That 
is, 61 = 62, and the tuples are really (a,b,Ci) and (0 , 6, 02), where 6 is both 61
and 62. Similarly, since R satisfies B C, and the tuples agree on B, they 
agree on C. Thus, c\ = C2; i.e., the tuples do agree on C. We have proved 
that any two tuples of R that agree on A also agree on C, and that is the FD 
A ^ C . □
FD’s often can be presented in several different ways, without changing the 
set of legal instances of the relation. We say:
• Two sets of FD’s 5 and T are equivalent if the set of relation instances 
satisfying S is exactly the same as the set of relation instances satisfying 
T.
• More generally, a set of FD’s S follows from a set of FD’s T if every 
relation instance that satisfies all the FD’s in T also satisfies all the FD’s 
in S.
Note then that two sets of FD’s S and T are equivalent if and only if S follows 
from T, and T follows from S.
In this section we shall see several useful rules about FD’s. In general, these 
rules let us replace one set of FD’s by an equivalent set, or to add to a set of 
FD’s others that follow from the original set. An example is the transitive rule
that lets us follow chains of FD’s, as in Example 3.4. We shall also give an 
algorithm for answering the general question of whether one FD follows from 
one or more other FD’s.
3.2.2 The Splitting/Combining Rule
Recall that in Section 3.1.1 we commented that the FD:
A i A2 ■ • • A n —> Bi B2 ■ ■ ■ B m
was equivalent to the set of FD’s:
A1A2 ■ ■ ■ An —»• B\, A1A2 • ■ ■ An -* B2, ... , A1A2 ■ ■ ■ An —> Bm
That is, we may split attributes on the right side so that only one attribute 
appears on the right of each FD. Likewise, we can replace a collection of FD’s 
having a common left side by a single FD with the same left side and all the 
right sides combined into one set of attributes. In either event, the new set of 
FD’s is equivalent to the old. The equivalence noted above can be used in two 
ways.
• We can replace an FD A\A 2 ---An —> B \B 2 ■ ■ ■ B m by a set of FD’s 
A iA 2 ■ ■ ■ An —s> Bi for i = 1,2,... ,m. This transformation we call the 
splitting rule.
74 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
• We can replace a set of FD’s A 1A2 ■ ■ ■ An Bi for i = 1,2,... , m by the 
single FD A± A2 ■ ■ ■ A n —> B 1B2 ■ ■ ■ B m. We call this transformation the 
combining rule.
E xam ple 3.5: In Example 3.1 the set of FD’s:
title year —► length 
title year —> genre 
title year —¥ studioName
is equivalent to the single FD:
title year —► length genre studioName
that we asserted there. □
The reason the splitting and combining rules axe true should be obvious. 
Suppose we have two tuples that agree in A i,A 2 ,... ,An. As a single FD, 
we would assert “then the tuples must agree in all of B i ,B 2,... ,B m.” As 
individual FD’s, we assert “then the tuples agree in B\, and they agree in B 2,
and,..., and they agree in B m.” These two conclusions say exactly the same 
thing.
One might imagine that splitting could be applied to the left sides of FD’s 
as well as to right sides. However, there is no splitting rule for left sides, as the 
following example shows.
E xam ple 3.6: Consider one of the FD’s such as:
title year —t length
for the relation Moviesl in Example 3.1. If we try to split the left side into
title —> length 
year length
then we get two false FD’s. That is, t i t l e does not functionally determine 
length, since there can be several movies with the same title (e.g., King Kong) 
but of different lengths. Similarly, year does not functionally determine length, 
because there are certainly movies of different lengths made in any one year.
□
3.2.3 Trivial Functional Dependencies
A constraint of any kind on a relation is said to be trivial if it holds for every 
instance of the relation, regardless of what other constraints are assumed. When 
the constraints are FD’s, it is easy to tell whether an FD is trivial. They are 
the FD’s Ai A2 ■ ■ ■ An — ByB2 ■ ■ ■ B m such that
{B 1,B 2 ,... ,B m} C {Ai ,A 2,... ,A n}
That is, a trivial FD has a right side that is a subset of its left side. For example,
3.2. RULES ABOUT FUNCTIONAL DEPENDENCIES 75
title year —¥ title
is a trivial FD, as is
title —¥ title
Every trivial FD holds in every relation, since it says that “two tuples that 
agree in all of Ai, A2 ,... ,An agree in a subset of them.” Thus, we may assume 
any trivial FD, without having to justify it on the basis of what FD’s are 
asserted for the relation.
There is an intermediate situation in which some, but not all, of the attributes on the right side of an FD are also on the left. This FD is not trivial, 
but it can be simplifed by removing from the right side of an FD those attributes 
that appear on the left. That is:
• The FD A 1 A2 ■ ■ ■ A„ B iB 2 ■ ■ ■ B m is equivalent to
A 1 A 2 ■ ■ ■ A n —> C 1 C 2 ■ ■ ■ C k
where the C ’s are all those B ’s that are not also .4’s.
We call this rule, illustrated in Fig. 3.3, the trivial-dependency rule.
If t and Then they 
u agree m ust agree 
on the A’s on the 5 s
So surely 
they agree 
on the C s
Figure 3.3: The trivial-dependency rule
3.2.4 Computing the Closure of Attributes
Before proceeding to other rules, we shall give a general principle from which 
all true rules follow. Suppose {Ai,A 2 ,... ,An} is a set of attributes and S
76 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
is a set of FD’s. The closure of {Ai,A 2 , ... , An} under the FD’s in S is the 
set of attributes B such that every relation that satisfies all the FD’s in set 
S also satisfies A 1A2 ---A„ —► B. That is, A iA 2 ■ ■ ■ An -» B follows from 
the FD’s of S. We denote the closure of a set of attributes A\ A2 ■ ■ • A n by 
{Ai,A 2 ,... ,A n}+. Note that A i,A 2,... ,A n are always in {A\,A 2 ,... ,An}+
because the FD Ai A2 • ■ • An ► Ai is trivial when i is one of 1,2,... , n.
Figure 3.4: Computing the closure of a set of attributes
Figure 3.4 illustrates the closure process. Starting with the given set of 
attributes, we repeatedly expand the set by adding the right sides of FD’s as 
soon as we have included their left sides. Eventually, we cannot expand the set 
any further, and the resulting set is the closure. More precisely:
A lgorithm 3.7: Closure of a Set of Attributes.
INPUT: A set of attributes {Ai,A 2 , ... , An} and a set of FD’s S.
O U T P U T : The closure {Ai,A 2 ,... ,A n}+.
1. If necessary, split the FD’s of 5, so each FD in S has a single attribute 
on the right.
2. Let X be a set of attributes that eventually will become the closure. 
Initialize X to be { ^ 1, ^ 2,... , A n}.
3. Repeatedly search for some FD
Bi B2 ■ ■ ■ B m C
such that all of £?i, B2,... , Bm are in the set of attributes X , but C is not. 
Add C to the set X and repeat the search. Since X can only grow, and 
the number of attributes of any relation schema must be finite, eventually 
nothing more can be added to X , and this step ends.
3.2. RULES ABOU T FUNCTIONAL DEPENDENCIES 77
4. The set X , after no more attributes can be added to it, is the correct 
value of {Ai ,A 2, ... , A„}+.
□
E xam ple 3.8: Let us consider a relation with attributes A, B, C, D, E, and 
F. Suppose that this relation has the FD’s A B —>• C, BC -» AD, D —» E, and 
C F —> B. What is the closure of {A, B}, that is, { A ,B } +?
First, split B C —> AD into B C —> A and B C —> D. Then, start with 
X — {A, B}. First, notice that both attributes on the left side of FD A B —» C
are in X , so we may add the attribute C, which is on the right side of that FD. 
Thus, after one iteration of Step 3, X becomes {A,B,C}.
Next, we see that the left sides of BC ->• A and B C —» D are now contained 
in X , so we may add to X the attributes A and D. A is already there, but 
D is not, so X next becomes {A,B,C,D}. At this point, we may use the FD 
D -> E to add E to X , which is now {A, B, C, D, E}. No more changes to X
are possible. In particular, the FD CF —> B can not be used, because its left 
side never becomes contained in X . Thus, { A ,B } + — {A ,B ,C ,D ,E }. □
By computing the closure of any set of -attributes, we can test whether 
any given FD Ai A 2 ■ ■ • An -¥ B follows from a set of FD’s S. First compute 
{j4i, A 2, ... , A n}+ using the set of FD’s S. If B is in {Ai ,A 2, ... , A n}+, then 
A \A 2 ■■■An -> B does follow from S, and if B is not in {Ai ,A 2, ... , A n}+, then 
this FD does not follow from S. More generally, A \A 2 -- ■ An —*• B \B 2 ■ ■ ■ B m
follows from set of FD’s S if and only if all of B\, B 2, ... , B m are in
{ A i,A 2, ... , A n}+
E xam ple 3.9: Consider the relation and FD’s of Example 3.8. Suppose we 
wish to test whether A B -* D follows from these FD’s. We compute {A, B}+ , 
which is {A,B,C,D ,E}, as we saw in that example. Since D is a member of 
the closure, we conclude that A B —>• D does follow.
On the other hand, consider the FD D —¥ A. To test whether this FD follows 
from the given FD’s, first compute {D }+. To do so, we start with X = {D}.
We can use the FD D —► E to add E to the set X . However, then we are stuck. 
We cannot find any other FD whose left side is contained in X — {D ,E }, so 
{D}+ = {D, E}. Since A is not a member of {D, E}, we conclude that D A
does not follow. □
3.2.5 W hy the Closure Algorithm Works
In this section, we shall show why Algorithm 3.7 correctly decides whether or 
not an FD A\ A 2 ■ ■ • An -> B follows from a given set of FD’s S. There are two 
parts to the proof:
1. We must prove that Algorithm 3.7 does not claim too much. That is, we 
must show that if A\ A2 ■ • ■ A„ —> B is asserted by the closure test (i.e.,
78 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
B is in {Ai ,A 2, • • ■ > A n}+), then AiA2 ■ ■ ■ A n -» B holds in any relation 
that satisfies all the FD’s in S.
2. We must prove that Algorithm 3.7 does not fail to discover a FD that 
truly follows from the set of FD’s S.
W hy th e C losure A lgorithm C laim s only True F D ’s
We can prove by induction on the number of times that we apply the growing 
operation of Step 3 that for every attribute D in X, the FD A \A 2 ■ ■ ■ A„ —> D
holds. That is, every relation R satisfying all of the FD’s in S also satisfies 
A1 A2 ■ ■ ■ An —> D.
BASIS: The basis case is when there are zero steps. Then D must be one of 
A 1,A 2,... , An. and surely AiA% ■ ■ ■ An -¥ D holds in any relation, because it 
is a trivial FD.
INDUCTION: For the induction, suppose D was added when we used the FD 
Bi B2 ■ ■ ■ B m —>■ D of S. We know by the inductive hypothesis that R satisfies 
A 1A2 ---A„ —> B \B 2 - ■ -Bm. Now, suppose two tuples of R agree on all of 
A l t A2, ... , A n. Then since R satisfies A iA 2 ■■■ An -¥ B \B 2 ■ • • Bm, the two 
tuples must agree on all of B i , B 2, ... , Bm. Since R satisfies B \B 2 • ■ ■ Bm —>■ D,
we also know these two tuples agree on D. Thus, R satisfies A iA 2 ■ ■ ■ An —l D.
W hy the Closure A lgorith m 'd iscovers A ll True F D ’s
Suppose A\A2 • • • A„ B were an FD that Algorithm 3.7 says does not follow 
from set S. That is, the closure of {Ai, A2, ... ,A„} using set of FD’s S does 
not include B. We must show that FD AiA2 ■ ■ ■ A n —> B really doesn’t follow 
from S. That is, we must show that there is at least one relation instance that 
satisfies all the FD’s in S, and yet does not satisfy A \A 2 ■ ■ ■ A n B.
This instance I is actually quite simple to construct; it is shown in Fig. 3.5. 
I has only two tuples: t and s. The two tuples agree in all the attributes 
of {Ai ,A2,. .. , An}+, and they disagree in all the other attributes. We must 
show first that I satisfies all the FD’s of S, and then that it does not satisfy 
A \A 2 ■ ■ ■ A n —> B.
{Ai ,A 2, ... , An}+ Other Attributes
~J: 1 1 1 ••• 1 1 0 0 0 0 0
s: 1 1 1 • ■ • 1 1 1 1 1 • • • 1 1
Figure 3.5: An instance I satisfying S but not A \A 2 ■ ■ ■ A n B
Suppose there were some FD C\C2 ■ ■ ■ Ck —> D in set S (after splitting 
right sides) that instance I does not satisfy. Since I has only two tuples, t
and s, those must be the two tuples that violate C\C2 ■ ■ -Ck -* D. That is, t
and s agree in all the attributes of {Ci, C2, ... , Ck}, yet disagree on D. If we
3.2. RULES ABOU T FUNCTIONAL DEPENDENCIES 79
examine Fig. 3.5 we see that all of C\ , C2, .. ■ ,Ck must be among the attributes 
of {Ai ,A 2, ... ,A n}+, because those are the only attributes on which t and s
agree. Likewise, D must be among the other attributes, because only on those 
attributes do t and s disagree.
But then we did not compute the closure correctly. CiC2 ---Ck ->■ D should 
have been applied when X was { A i,A 2, ... ,A n} to add D to X . We conclude 
that C\C2 ■■ -Ck —► D cannot exist; i.e., instance I satisfies S.
Second, we must show that I does not satisfy A \A 2 ■ ■ ■ A n —> B. However, 
this part is easy. Surely, A \,A 2, . . . , A n are among the attributes on which t and 
s agree. Also, we know that B is not in {A\ , A2, ... , An}+, so B is one of the 
attributes on which t and s disagree. Thus, I does not satisfy A \A 2 •■■An -¥ B.
We conclude that Algorithm 3.7 asserts neither too few nor too many FD’s; it 
asserts exactly those FD’s that do follow from S.
3.2.6 The Transitive Rule
The transitive rule lets us cascade two FD’s, and generalizes the observation of 
Example 3.4.
• If A\A% • ■ • A n B i B 2 ■ ■ ■ B m and B \B 2 ■ ■ ■ B m -»• C\C2---Ck hold in 
relation R, then Ai A 2 ■ ■ ■ A„ —>■ C\ C2 • ■ ■ Ck also holds in R.
If some of the C ’s are among the A’s, we may eliminate them from the right 
side by the trivial-dependencies rulev
To see why the transitive rule holds, apply the test of Section 3.2.4. To 
test whether A iA 2 ■ ■ ■ A n —> C\C2 ■ ■ ■ Cu holds, we need to compute the closure 
{Ai, A 2, ... , A n}+ with respect to the two given FD’s.
The FD A i A2 ■ ■ ■ An —> B \B 2 ■ ■ ■ Bm tells us that all of B i,B 2, ... , B m are 
in {Ai ,A 2, ... , An}+. Then, we can use the FD B i B2 ■ ■ ■ B m —¥ C\C2 ■ ■ ■ Ck
to add Ci,C2, ... ,Ck to {Ai ,A 2, ... , An}+. Since all the C ’s are in
{ A i,A 2, ... ,A n}+
we conclude that A \A 2 ■ ■ • A n -»■ C\ C2 ■ ■ ■ Ck holds for any relation that satisfies 
both Ai A2 ■ • • An —¥ B \B 2 • • • B m and B \B 2 ■ ■ ■ Bm CiC2 • • ■ CkE xam ple 3.10: Here is another version of the Movies relation that includes 
both the studio of the movie and some information about that studio.
title year length genre studioName studioAddr
Star Wars 1977 124 sciFi Fox Hollywood
Eight Below 2005 120 drama Disney Buena Vista
Wayne’s World 1992 95 comedy Paramount Hollywood
Two of the FD’s that we might reasonably claim to hold are:
title year -» studioName 
studioName —> studioAddr
80 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
Closures and Keys
Notice that {Ai,A<2 , ... ,A„}+ is the set of all attributes of a relation if 
and only if A\,A 2 ,... ,A„ is a superkey for the relation. For only then 
does A i,A 2 ,... , An functionally determine all the other attributes. We 
can test if A i,A 2,... , An is a key for a relation by checking first that 
{Ai,A2 , ... , An}+ is all attributes, and then checking that, for no set X
formed by removing one attribute from {Ai,A2 , ... , An}, is X + the set 
of all attributes.
The first is justified because there can be only one movie with a given title 
and year, and there is only one studio that owns a given movie. The second is 
justified because studios have unique addresses.
The transitive rule allows us to combine the two FD’s above to get a new 
FD:
title year —> studioAddr
This FD says that a title and year (i.e., a movie) determines an address — the 
address of the studio owning the movie. □
3.2.7 Closing Sets of Functional Dependencies
Sometimes we have a choice of which FD’s we use to represent the full set of 
FD’s for a relation. If we are given a set of FD’s S (such as the FD’s that hold 
in a given relation), then any set of FD’s equivalent to S is said to be a basis
for S. To avoid some of the explosion of possible bases, we shall limit ourselves 
to considering only bases whose FD’s have singleton right sides. If we have any 
basis, we can apply the splitting rule to make the right sides be singletons. A 
minimal basis for a relation is a basis B that satisfies three conditions:
1. All the FD’s in B have singleton right sides.
2. If any FD is removed from B, the result is no longer a basis.
3. If for any FD in B we remove one or more attributes from the left side of 
F, the result is no longer a basis.
Notice that no trivial FD can be in a minimal basis, because it could be removed 
by rule (2).
Exam ple 3 .1 1 : Consider a relation R{A, B, C) such that each attribute functionally determines the other two attributes. The full set of derived FD’s thus 
includes six FD’s with one attribute on the left and one on the right; A -»■ B,
A -¥ C, B A, B -¥ C, C A, and C B. It also includes the three
3.2. RULES ABOU T FUNCTIONAL DEPENDENCIES 81
A Complete Set of Inference Rules
If we want to know whether one FD follows from some given FD’s, the 
closure computation of Section 3.2.4 will always serve. However, it is 
interesting to know that there is a set of rules, called Armstrong’s axioms,
from which it is possible to derive any FD that follows from a given set. 
These axioms are:
1. Reflexivity. If {B 1,B 2, ... , B m} C {Ai ,A 2, . .. , An}, then 
Ai A2 ■ ■ ■ An —> B iB2 ■ ■ ■ B m. These are what we have called trivial FD’s.
2. Augmentation. If A\A2 • • • A n -4 B%B2 ■ • ■ B m, then
A iA 2 ■ ■ ■ AnC iC2 ■ ■ ■ Ck —> B iB 2 ■ ■ ■ B mC iC2 ■ ■ ■ Ck
for any set of attributes C\, C2, ... ,Ck- Since some of the C ’s may 
also be j4’s or B ’s or both, we should eliminate from the left side 
duplicate attributes and do the same for the right side.
3. Transitivity. If
A\ A2 * * * An B \B 2 ■ ■ ■ B m and B \B 2 • ■ ■ B m C\C2 • • - Ck
then A iA2 ■ ■ ■ A n —¥ C±C2 ■ ■ ■ Cknontrivial FD’s with two attributes on the left: A B —> C, AC —¥ B, and 
BC —¥ A. There are also FD’s with more than one attribute on the right, such 
as A BC, and trivial FD’s such as A -> A.
Relation R and its FD’s have several minimal bases. One is
{A -> B, B A, B C, C ->• B}
Another is {^4 -¥ B, B C, C —» A}. There are several other minimal bases 
for R, and we leave their discovery as an exercise. □
3.2.8 Projecting Functional Dependencies
When we study design of relation schemas, we shall also have need to answer 
the following question about FD’s. Suppose we have a relation R with set of 
FD’s S, and we project R by computing Ri — itl(R), for some list of attributes 
R. What FD’s hold in i?i?
The answer is obtained in principle by computing the projection of functional
dependencies S, which is all FD’s that:
82 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
a) Follow from S, and
b) Involve only attributes of R \.
Since there may be a large number of such FD’s, and many of them may be 
redundant (i.e., they follow from other such FD’s), we are free to simplify that 
set of FD’s if we wish. However, in general, the calculation of the FD’s for 
Ri is exponential in the number of attributes of R\. The simple algorithm is 
summarized below.
A lgorithm 3 .1 2 : Projecting a Set of Functional Dependencies.
INPUT: A relation R and a second relation Ri computed by the projection 
Ri = nL(R). Also, a set of FD’s 5 that hold in R.
O U T P U T : The set of FD’s that hold in Ri.
M E T H O D :
1. Let T be the eventual output set of FD’s. Initially, T is empty.
2. For each set of attributes X that is a subset of the attributes of Ri,
compute X +. This computation is performed with respect to the set of 
FD’s S, and may involve attributes that are in the schema of R but not 
R\. Add to T all nontrivial FD’s X A such that A is both in X + and 
an attribute of R\.
3. Now, T is a basis for the FD’s that hold in Ri, but may not be a minimal 
basis. We may construct a minimal basis by modifying T as follows:
(a) If there is an FD F in T that follows from the other FD’s in T, 
remove F from T.
(b) Let Y —» B be an FD in T, with at least two attributes in Y, and let 
Z be Y with one of its attributes removed. If Z -> B follows from 
the FD’s in T (including Y —> B), then replace Y -» B by Z B.
(c) Repeat the above steps in all possible ways until no more changes to 
T can be made.
□
E xam ple 3.13: Suppose R(A, B, C, D) has FD’s A —► B, B C, and C D.
Suppose also that we wish to project out the attribute B, leaving a relation 
Ri(A,C,D). In principle, to find the FD’s for R \, we need to take the closure 
of all eight subsets of {A, C, D}, using the full set of FD’s, including those 
involving B. However, there are some obvious simplifications we can make.
• Closing the empty set and the set of all attributes cannot yield a nontrivial 
FD.
3.2. RULES ABOU T FUNCTIONAL DEPENDENCIES 83
• If we already know that the closure of some set X is all attributes, then 
we cannot discover any new FD’s by closing supersets of X .
Thus, we may start with the closures of the singleton sets, and then move 
on to the doubleton sets if necessary. For each closure of a set X , we add the 
FD X E for each attribute E that is in X + and in the schema of Ri, but 
not in X .
First, {^4}+ = {A,B,C,D}. Thus, A —> C and A —» D hold in R\. Note 
that A —> B is true in R, but makes no sense in R,\ because B is not an attribute 
of Ri.
Next, we consider {C'}+ = {C,D}, from which we get the additional FD 
C -» D for Ri. Since {D}+ = {£>}, we can add no more FD’s, and are done 
with the singletons.
Since {A}+ includes all attributes of R i , there is no point in considering any 
superset of {A}. The reason is that whatever FD we could discover, for instance 
AC -» D, follows from an FD with only A on the left side: A —> D in this case. 
Thus, the only doubleton whose closure we need to take is {C, D }+ — {C,D }. 
This observation allows us to add nothing. We are done with the closures, and 
the FD’s we have discovered are A C, A D, and C D.
If we wish, we can observe that A —> D follows from the other two by 
transitivity. Therefore a simpler, equivalent set of FD’s for R\ is A —> C and 
C —> D. This set is, in fact, a minimal basis for the FD’s of R \. □
3.2.9 Exercises for Section 3.2
E xercise 3.2.1: Consider a relation with schema R(A,B,C ,D ) and FD’s 
A B —^ C , C —^ D , and D — A.
a) What are all the nontrivial FD’s that follow from the given FD’s? You 
should restrict yourself to FD’s with single attributes on the right side.
b) What are all the keys of R?
c) What are all the superkeys for R that are not keys?
E xercise 3.2.2: Repeat Exercise 3.2.1 for the following schemas and sets of 
FD’s:
i) S(A, B, C, D) with FD’s A -> B, B ->■ C, and B -» D.
ii) T(A, B, C, D) with FD’s A B -*■ C, B C ->■ D, CD ->■ A, and AD ->■ B.
in) U(A, B, C, D) with FD’s A -> B, B ->■ C, C -»• D, and D A.
E xercise 3.2.3: Show that the following rules hold, by using the closure test 
of Section 3.2.4.
a) Augmenting left sides. If A 1A2 ■ ■ ■ A n —¥ B is an FD, and C is another 
attribute, then A 1 A2 ■ ■ ■ A nC B follows.
84 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
b) Full augmentation. If A iA 2 ■ ■ ■ An -» B is an FD, and C is another attribute, then A1 A2 ■ ■ ■ AnC —>■ BC follows. Note: from this rule, the 
“augmentation” rule mentioned in the box of Section 3.2.7 on “A Complete Set of Inference Rules” can easily be proved.
c) Pseudotransitivity. Suppose FD’s A1A2 ■ ■ ■ A„ —» B1B2 • ■ ■ B m and
C i C f - C k - tD
hold, and the B ’s are each among the C ’s. Then
A\ Ai • ■ ■ AnE\ E2 • • ■ Ej —¥ D
holds, where the E ’s are all those of the C ’s that are not found among 
the B ’s.
d) Addition. If FD’s A1A2 ■ ■ ■ An —¥ B 1B2 ■ ■ • B m and
C1C2 • • • Ck —^ D1D2 • ■ ■ Dj
hold, then FD A1 A2 * • • AnC\C2 ' ■ * Ck —^ B1B2 ■ * * B7nI)j D2 • * • Dj also 
holds. In the above, we should remove one copy of any attribute that 
appears among both the A’s and C’s or among both the B ’s and D ’s.
! Exercise 3.2.4: Show that each of the following are not valid rules about FD’s 
by giving example relations that satisfy the given FD’s (following the “if”) but 
not the FD that allegedly follows (after the “then”).
a) If A —> B then B —> A.
b) If AB -¥ C and A C, then B->C.
c) If AB C, then A —> C or B —► C.
! Exercise 3.2.5: Show that if a relation has no attribute that is functionally 
determined by all the other attributes, then the relation has no nontrivial FD’s 
at all.
! Exercise 3.2.6: Let X and Y be sets of attributes. Show that if X C Y, then 
X + C Y+, where the closures are taken with respect to the same set of FD’s.
! Exercise 3.2.7: Prove that (X+)+ = X +.
! Exercise 3.2.8: We say a set of attributes X is closed (with respect to a given 
set of FD’s) if X + = X . Consider a relation with schema R{A, B, C, D) and an 
unknown set of FD’s. If we are told which sets of attributes are closed, we can 
discover the FD’s. What are the FD’s if:
a) All sets of the four attributes are closed.
3.3. DESIGN OF RELATIONAL DATABASE SCHEMAS 85
b) The only closed sets are 0 and {A, B ,C ,D }.
c) The closed sets are 0, {A,B}, and {A, B,C, D}.
! E xercise 3.2.9: Find all the minimal bases for the FD’s and relation of Example 3.11.
! E xercise 3.2.10: Suppose we have relation R(A,B,C,D ,E), with some set 
of FD’s, and we wish to project those FD’s onto relation S(A, B, C). Give the 
FD’s that hold in S if the FD’s for R are:
a) A B —^ D E , C —^ E , D —^ (7, and E —^ A.
b) A —¥ D : BD — E, AC —¥ E, and D E —^ B.
c) A B —¥ D , AC —¥ E, B C —¥ D , D —^ A , and E — B.
d) A ->■ B, B C, C D, D -> E, and E A.
In each case, it is sufficient to give a minimal basis for the full set of FD’s of S.
!! E xercise 3.2.11: Show that if an FD F follows from some given FD’s, then 
we can prove F from the given FD’s using Armstrong’s axioms (defined in the 
box “A Complete Set of Inference Rules” in Section 3.2.7). Hint: Examine 
Algorithm 3.7 and show how each step of that algorithm can be mimicked by 
inferring some FD’s by Armstrong’s axioms.
3.3 Design of Relational Database Schemas
Careless selection of a relational database schema can lead to redundancy and 
related anomalies. For instance, consider the relation in Fig. 3.2, which we 
reproduce here as Fig. 3.6. Notice that the length and genre for Star Wars
and Wayne’s World are each repeated, once for each star of the movie. The 
repetition of this information is redundant. It also introduces the potential for 
several kinds of errors, as we shall see.
In this section, we shall tackle the problem of design of good relation schemas 
in the following stages:
1. We first explore in more detail the problems that arise when our schema 
is poorly designed.
2. Then, we introduce the idea of “decomposition,” breaking a relation 
schema (set of attributes) into two smaller schemas.
3. Next, we introduce “Boyce-Codd normal form,” or “BCNF,” a condition 
on a relation schema that eliminates these problems.
4. These points are tied together when we explain how to assure the BCNF 
condition by decomposing relation schemas.
86 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
title year length genre studioName starNam e
Star Wars 1977 124 SciFi Fox Carrie Fisher
Star Wars 1977 124 SciFi Fox Hark Hamill
Star Wars 1977 124 SciFi Fox Harrison Ford
Gone With the Wind 1939 231 drama MGM Vivien Leigh
Wayne’s World 1992 95 comedy Paramount Dana Carvey
Wayne’s World 1992 95 comedy Paramount Mike Meyers
Figure 3.6: The relation Moviesl exhibiting anomalies
3.3.1 Anomalies
Problems such as redundancy that occur when we try to cram too much into a 
single relation axe called anomalies. The principal kinds of anomalies that we 
encounter are:
1. Redundancy. Information may be repeated unnecessarily in several tuples. 
Examples are the length and genre for movies in Fig. 3.6.
2. Update Anomalies. We may change information in one tuple but leave 
the same information unchanged in another. For example, if we found 
that Star Wars is really 125 minutes long, we might carelessly change the 
length in the first tuple of Fig. 3.6 but not in the second or third tuples. 
You might argue that one should never be so careless, but it is possible 
to redesign relation Moviesl so that the risk of such mistakes does not 
exist.
3. Deletion Anomalies. If a set of values becomes empty, we may lose other 
information as a side effect. For example, should we delete Vivien Leigh 
from the set of stars of Gone With the Wind, then we have no more stars 
for that movie in the database. The last tuple for Gone With the Wind
in the relation Moviesl would disappear, and with it information that it 
is 231 minutes long and a drama.
3.3.2 Decomposing Relations
The accepted way to eliminate these anomalies is to decompose relations. Decomposition of R involves splitting the attributes of R to make the schemas of 
two new relations. After describing the decomposition process, we shall show 
how to pick a decomposition that eliminates anomalies.
Given a relation R(A\ , A2 , . ■ ■ ,A n), we may decompose R into two relations 
S(Bi,B 2 , ... , Bm) and T(Ci, C2, ... , Ck) such that:
1. {Ai,A2, ... ,An} = {Bi, B2, ■ ■ ■ , Bm} U {Ci, C2 , ■ • • , Ck}-
3. T - ircu c 2,...,ck(R)-
Example 3.14: Let us decompose the Moviesl relation of Fig. 3.6. Our choice, 
whose merit will be seen in Section 3.3.3,is to use:
1. A relation called Movies2, whose schema is all the attributes except for 
starName.
2. A relation called Movies3, whose schema consists of the attributes title, 
year, and starName.
The projection of Moviesl onto these two new schemas is shown in Fig, 3.7.
□
3.3. DESIGN OF RELATIONAL DATABASE SCHEMAS 87
title year length genre studioName
Star Wars 1977 124 sciFi Fox
Gone With the Wind 1939 231 drama MGM
Wayne’s World 1992 95 comedy Paramount
(b) The relation Movies2.
title year starName
Star Wars 1977 Carrie Fisher
Star Weirs 1977 Mark Hamill
Star Wars 1977 Harrison Ford
Gone With the Wind 1939 Vivien Leigh
Wayne’s World 1992 Dana Carvey
Wayne’s World 1992 Mike Meyers
(b) The relation Movies3.
Figure 3.7: Projections of relation Moviesl
Notice how this decomposition eliminates the anomalies we mentioned in 
Section 3.3.1. The redundancy has been eliminated; for example, the length 
of each film appears only once, in relation Movies2. The risk of an update 
anomaly is gone. For instance, since we only have to change the length of Star
Wars in one tuple of Movies2, we cannot wind up with two different lengths 
for that movie.
Finally, the risk of a deletion anomaly is gone. If we delete all the stars 
for Gone With the Wind, say, that deletion makes the movie disappear from 
Movies3. But all the other information about the movie can still be found in 
Movies2.
88 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
It might appear that Movies3 still has redundancy, since the title and year 
of a movie can appear several times. However, these two attributes form a key 
for movies, and there is no more succinct way to represent a movie. Moreover, 
Movies3 does not offer an opportunity for an update anomaly. For instance, one 
might suppose that if we changed to 2008 the year in the Carrie Fisher tuple, 
but not the other two tuples for Star Wars, then there would be an update 
anomaly. However, there is nothing in our assumed FD’s that prevents there 
being a different movie named Star Wars in 2008, and Carrie Fisher may star 
in that one as well. Thus, we do not want to prevent changing the year in one 
Star Wars tuple, nor is such a change necessarily incorrect.
3.3.3 Boyce-Codd Normal Form
The goal of decomposition is to replace a relation by several that do not exhibit 
anomalies. There is, it turns out, a simple condition under which the anomalies 
discussed above can be guaranteed not to exist. This condition is called BoyceCodd normal form, or BCNF.
• A relation R is in BCNF if and only if: whenever there is a nontrivial FD 
A iA2 ■ • • An -* B iB 2 ■ ■ ■ B m for R, it is the case that {Ai, A2, ... , An} is 
a superkey for R.
That is, the left side of every nontrivial FD must be a superkey. Recall that 
a superkey need not be minimal. Thus, an equivalent statement of the BCNF 
condition is that the left side of every nontrivial FD must contain a key.
Exam ple 3.15 : Relation Moviesl, as in Fig. 3.6, is not in BCNF. To see why, 
we first need to determine what sets of attributes are keys. We argued in Example 3.2 why {title, year, starName} is a key. Thus, any set of attributes 
containing these three is a superkey. The same arguments we followed in Example 3.2 can be used to explain why no set of attributes that does not include 
all three of title, year, and starName could be a superkey. Thus, we assert 
that {title, year, starName} is the only key for Moviesl.
However, consider the FD
title year —> length genre studioName
which holds in Moviesl according to our discussion in Example 3.2.
Unfortunately, the left side of the above FD is not a superkey. In particular, 
we know that title and year do not functionally determine the sixth attribute, 
starName. Thus, the existence of this FD violates the BCNF condition and tells 
us Moviesl is not in BCNF. □
Exam ple 3.16: On the other hand, Movies2 of Fig. 3.7 is in BCNF. Since
title year —¥ length genre studioName
3.3. DESIGN OF RELATIONAL DATABASE SCHEMAS 89
holds in this relation, and we have argued that neither t i t l e nor year by itself 
functionally determines any of the other attributes, the only key for Movies2 
is { t i t le , year}. Moreover, the only nontrivial FD’s must have at least t i t l e 
and year on the left side, and therefore their left sides must be superkeys. Thus, 
Movles2 is in BCNF. □
E xam ple 3.17: We claim that any two-attribute relation is in BCNF. We 
need to examine the possible nontrivial FD’s with a single attribute on the 
right. There are not too many cases to consider, so let us consider them in 
turn. In what follows, suppose that the attributes are A and B.
1. There are no nontrivial FD’s. Then surely the BCNF condition must hold, 
because only a nontrivial FD can violate this condition. Incidentally, note 
that {A, B } is the only key in this case.
2. A —¥ B holds, but B -4 - A does not hold. In this case, A is the only key, 
and each nontrivial FD contains A on the left (in fact the left can only 
be A). Thus there is no violation of the BCNF condition.
3. B ->• A holds, but A ->• B does not hold. This case is symmetric to 
case (2).
4. Both A —» B and B -> A hold. Then both A and B are keys. Surely 
any FD has at least one of these on the left, so there can be no BCNF 
violation.
It is worth noticing from case (4) above that there may be more than one 
key for a relation. Further, the BCNF condition only requires that some key be 
contained in the left side of any nontrivial FD, not that all keys are contained in 
the left side. Also observe that a relation with two attributes, each functionally 
determining the other, is not completely implausible. For example, a company 
may assign its employees unique employee ID’s and also record their Social 
Security numbers. A relation with attributes empID and ssNo would have each 
attribute functionally determining the other. Put another way, each attribute 
is a key, since we don’t expect to find two tuples that agree on either attribute.
□
3.3.4 Decomposition into BCNF
By repeatedly choosing suitable decompositions, we can break any relation 
schema into a collection of subsets of its attributes with the following important 
properties:
1. These subsets are the schemas of relations in BCNF.
2. The data in the original relation is represented faithfully by the data in the 
relations that are the result of the decomposition, in a sense to be made 
precise in Section 3.4.1. Roughly, we need to be able to reconstruct the 
original relation instance exactly from the decomposed relation instances.
90 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
Example 3.17 suggests that perhaps all we have to do is break a relation schema 
into two-attribute subsets, and the result is surely in BCNF. However, such 
an arbitrary decomposition will not satisfy condition (2), as we shall see in 
Section 3.4.1. In fact, we must be more careful and use the violating FD’s to 
guide our decomposition.
The decomposition strategy we shall follow is to look for a nontrivial FD 
A1A2 ■■■ A n -¥ B 1B2 ■ ■ ■ Bm that violates BCNF; i.e., { A i,A 2, ... , An} is not a 
superkey. We shall add to the right side as many attributes as are functionally 
determined by {A i,A 2 ,... ,A n}. This step is not mandatory, but it often 
reduces the total amount of work done, and we shall include it in our algorithm. 
Figure 3.8 illustrates how the attributes are broken into two overlapping relation 
schemas. One is all the attributes involved in the violating FD, and the other 
is the left side of the FD plus all the attributes not involved in the FD, i.e., all 
the attributes except those B ’s that are not /Ts.
Figure 3.8: Relation schema decomposition based on a BCNF violation
Exam ple 3.18: Consider our running example, the Moviesl relation of Fig. 
3.6. We saw in Example 3.15 that
title year —> length genre studioName
is a BCNF violation. In this case, the right side already includes all the attributes functionally determined by title and year, so we shall use this BCNF 
violation to decompose Moviesl into:
1. The schema {title, year, length, genre, studioName} consisting of all 
the attributes on either side of the FD.
2. The schema {title, year, starName} consisting of the left side of the FD 
plus all attributes of Moviesl that do not appear in either side of the FD 
(only starName, in this case).
Notice that these schemas are the ones selected for relations Movies2 and 
Movies3 in Example 3.14. We observed in Example 3.16 that Movies2 is in 
BCNF. Movies3 is also in BCNF; it has no nontrivial FD’s. □
3.3. DESIGN OF RELATIONAL DATABASE SCHEMAS 91
In Example 3.18, one judicious application of the decomposition rule is 
enough to produce a collection of relations that are in BCNF. In general, that 
is not the case, as the next example shows.
E xam ple 3.19: Consider a relation with schema
{title, year, studioName, president, presAddr}
That is, each tuple of this relation tells about a movie, its studio, the president 
of the studio, and the address of the president of the studio. Three FD’s that 
we would assume in this relation are
title year —» studioName 
studioName —» president 
president —¥ presAddr
By closing sets of these five attributes, we discover that {title, year} is the 
only key for this relation. Thus the last two FD’s above violate BCNF. Suppose 
we choose to decompose starting with
studioName -> president
First, we add to the right side of this functional dependency any other attributes 
in the closure of studioName. That closure includes presAddr, so our final 
choice of FD for the decomposition is:
studioName —> president presAddr
The decomposition based on this FD yields the following two relation schemas.
{title, year, studioName}
{studioName, president, presAddr}
If we use Algorithm 3.12 to project FD’s, we determine that the FD’s for 
the first relation has a basis:
title year —¥ studioName
while the second has:
studioName —¥ president 
president —¥ presAddr
The sole key for the first relation is { t i t le , year}, and it is therefore in BCNF. 
However, the second has {studioName} for its only key but also has the FD:
president —¥ presAddr
which is a BCNF violation. Thus, we must decompose again, this time using 
the above FD. The resulting three relation schemas, all in BCNF, are:
92 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
{title, year, studioName}
{studioName, president}
{president, presAddr}
□
In general, we must keep applying the decomposition rule as many times as 
needed, until all our relations are in BCNF. We can be sure of ultimate success, 
because every time we apply the decomposition rule to a relation R, the two 
resulting schemas each have fewer attributes than that of R. As we saw in 
Example 3.17, when we get down to two attributes, the relation is sure to be 
in BCNF; often relations with larger sets of attributes are also in BCNF. The 
strategy is summarized below.
A lgorithm 3.20: BCNF Decomposition Algorithm.
INPUT: A relation Ro with a set of functional dependencies SoO U T P U T : A decomposition of Ro into a collection of relations, all of which are 
in BCNF.
M E T H O D : The following steps can be applied recursively to any relation R and 
set of FD’s S . Initially, apply them with R = Ro and S = Sq.
1. Check whether R is in BCNF. If so, nothing more needs to be done. 
Return {J?} as the answer.
2. If there are BCNF violations, let one be X Y. Use Algorithm 3.7 to 
compute X +. Choose Ri = X + as one relation schema and let R? have 
attributes X and those attributes of R that are not in X +.
3. Use Algorithm 3.12 to compute the sets of FD’s for R\ and R%-, let these 
be Si and S2, respectively.
4. Recursively decompose Ri and R2 using this algorithm. Return the union 
of the results of these decompositions.
□
3.3.5 Exercises for Section 3.3
Exercise 3.3.1: For each of the following relation schemas and sets of FD’s:
a) R(A, B, C, D) with FD’s AB —► C, C -> D, and D A.
b) R (A ,B ,C ,D ) with FD’s B —> C and B D.
c) R{A, B, C, D) with FD’s AB -+ C ,B C ->■ D, CD ->■ A, and AD B.
d) R(A, B, C, D) with FD’s A B, B C, C ->• D, and D A.
3.4. DECOMPOSITION: THE GOOD, BAD, AND UGLY 93
e) R(A, B, C, D, E ) with FD’s A B —^ C , D E —¥ C, and B —¥ D.
f) R(A, B, C, D, E ) with FD’s A B —¥ C , C —^ D, D —¥ B, and D —¥ E.
do the following:
i) Indicate all the BCNF violations. Do not forget to consider FD’s that are 
not in the given set, but follow from them. However, it is not necessary 
to give violations that have more than one attribute on the right side.
ii) Decompose the relations, as necessary, into collections of relations that 
are in BCNF.
E xercise 3.3.2: We mentioned in Section 3.3.4 that we would exercise our 
option to expand the right side of an FD that is a BCNF violation if possible. 
Consider a relation R whose schema is the set of attributes {.4, B, C, D] with 
FD’s A -¥ B and A -¥ C. Either is a BCNF violation, because the only key 
for R is {A, D}. Suppose we begin by decomposing R according to A -¥ B. Do 
we ultimately get the same result as if we first expand the BCNF violation to 
A -¥ B C? Why or why not?
! E xercise 3.3.3: Let R be as in Exercise 3.3.2, but let the FD’s be A -¥ B and 
B —¥ C. Again compare decomposing using A —¥ B first against decomposing 
by A -¥ B C first.
! E xercise 3.3.4: Suppose we have a relation schema R(A, B, C) with FD A —¥
B. Suppose also that we decide to decompose this schema into S (A ,B ) and 
T (B , C). Give an example of an instance of relation R whose projection onto 
S and T and subsequent rejoining as in Section 3.4.1 does not yield the same 
relation instance. That is, tta,b (R) x ^ b ,c (R) / R3.4 Decomposition: The Good, Bad, and Ugly
So far, we observed that before we decompose a relation schema into BCNF, 
it can exhibit anomalies; after we decompose, the resulting relations do not 
exhibit anomalies. T hat’s the “good.” But decomposition can also have some 
bad, if not downright ugly, consequences. In this section, we shall consider 
three distinct properties we would like a decomposition to have.
1. Elimination of Anomalies by decomposition as in Section 3.3.
2. Recoverability of Information. Can we recover the original relation from 
the tuples in its decomposition?
3. Preservation of Dependencies. If we check the projected FD’s in the relations of the decomposition, can we can be sure that when we reconstruct 
the original relation from the decomposition by joining, the result will 
satisfy the original FD’s?
94 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
It turns out that the BCNF decomposition of Algorithm 3.20 gives us (1) and 
(2), but does not necessarily give us all three. In Section 3.5 we shall see another 
way to pick a decomposition that gives us (2) and (3) but does not necessarily 
give us (1). In fact, there is no way to get all three at once.
3.4.1 Recovering Information from a Decomposition
Since we learned that every two-attribute relation is in BCNF, why did we 
have to go through the trouble of Algorithm 3.20? Why not just take any 
relation R and decompose it into relations, each of whose schemas is a pair of 
R ’s attributes? The answer is that the data in the decomposed relations, even 
if their tuples were each the projection of a relation instance of R, might not 
allow us to join the relations of the decomposition and get the instance of R
back. If we do get R back, then we say the decomposition has a lossless join.
However, if we decompose using Algorithm 3.20, where all decompositions 
are motivated by a BCNF-violating FD, then the projections of the original 
tuples can be joined again to produce all and only the original tuples. We shall 
consider why here. Then, in Section 3.4.2 we shall give an algorithm called the 
“chase,” for testing whether the projection of a relation onto any decomposition 
allows us to recover the relation by rejoining.
To simplify the situation, consider a relation R{A, B, C) and an FD B —► C
that is a BCNF violation. The decomposition based on the FD B -» C separates 
the attributes into relations R\{A, B) and R2 (B,C).
Let t be a tuple of R. We may write t = (a, b, c), where a, b, and c are the 
components of t for attributes A, B, and C, respectively. Tuple t projects as 
(a, b) in R1 (A,B) — ka,b{R) and as (6, c) in R2 (B,C ) = kb,c(R)- When we 
compute the natural join Ri ix R2, these two projected tuples join, because 
they agree on the common B component (they both have b there). They give 
us t = (a. b, c). the tuple we started with, in the join. That is, regardless of 
what tuple t we started with, we can always join its projections to get t back.
However, getting back those tuples we started with is not enough to assure 
that the original relation R is truly represented by the decomposition. Consider 
what happens if there are two tuples of R, say t = (a,b,c) and v = (d,b,e). 
When we project t onto R,\ (A. B) we get u = (a, b), and when we project v onto 
R2 (B,C) we get w = (b,e). These tuples also match in the natural join, and 
the resulting tuple is x — (a,b,e). Is it possible that a: is a bogus tuple? That 
is, could (a, b, e) not be a tuple of R?
Since we assume the FD B -¥ C for relation R, the answer is “no.” Recall 
that this FD says any two tuples of R that agree in their B components must 
also agree in their C components. Since t and v agree in their B components, 
they also agree on their C components. That means c — e; i.e., the two values 
we supposed were different are really the same. Thus, tuple (a, b, e) of R is 
really (a, b, c); that is, x = t.
Since t is in R. it must be that x is in R. Put another way, as long as FD 
B —»■ C holds, the joining of two projected tuples cannot produce a bogus tuple.
3.4. DECOMPOSITION: THE GOOD, BAD, AND UGLY 95
Rather, every tuple produced by the natural join is guaranteed to be a tuple of 
R.
This argument works in general. We assumed A, B, and C were each 
single attributes, but the same argument would apply if they were any sets 
of attributes X , Y and Z. That is, if Y —> Z holds in R, whose attributes are 
X U Y U Z, then R = nxuy(R ) cx k y u z ( R ) -
We may conclude:
• If we decompose a relation according to Algorithm 3.20, then the original 
relation can be recovered exactly by the natural join.
To see why, we argued above that at any one step of the recursive decomposition, 
a relation is equal to the join of its projections onto the two components. If 
those components are decomposed further, they can also be recovered by the 
natural join from their decomposed relations. Thus, an easy induction on the 
number of binary decomposition steps says that the original relation is always 
the natural join of whatever relations it is decomposed into. We can also prove 
that the natural join is associative and commutative, so the order in which we 
perform the natural join of the decomposition components does not matter.
The FD Y -» Z, or its symmetric FD Y X , is essential. Without one of 
these FD’s, we might not be able to recover the original relation. Here is an 
example.
E xam ple 3.21: Suppose we have the relation R(A, B, C) as above, but neither 
of the FD’s B A nor B —> C holds. Then R might consist of the two tuples
A B C
1 2 3
4 2 5
The projections of R onto the relations with schemas {A. B } and {B, C]
are R i = ttab(R) =
A B
1 2
4 2
and R-2 — ttbc(R ) —
B C
2 3
2 5
respectively. Since all four tuples share the same 5-value, 2, each tuple of one 
relation joins with both tuples of the other relation. When we try to reconstruct 
R by the natural join of the projected relations, we get R3 — R i cxi R2 —
96 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
Is Join the Only Way to Recover?
We have assumed that the only possible way we could reconstruct a relation from its projections is to use the natural join. However, might there 
be some other algorithm to reconstruct the original relation that would 
work even in cases where the natural join fails? There is in fact no such 
other way. In Example 3.21, the relations R and R3 are different instances, 
yet have exactly the same projections onto {^4, B} and {B, C}, namely the 
instances we called Ri and R2 , respectively. Thus, given Ri and R2 , no 
algorithm whatsoever can tell whether the original instance was R or R3 .
Moreover, this example is not unusual. Given any decomposition of 
a relation with attributes IU FU Z into relations with schemas X U Y
and Y U Z, where neither Y —► X nor Y —> Z holds, we can construct 
an example similar to Example 3.21 where the original instance cannot be 
determined from its projections.
A B C
1 2 3
1 2 5
4 2 3
4 2 5
That is, we get “too much”; we get two bogus tuples, (1,2,5) and (4,2,3), that 
were not in the original relation R. □
3.4.2 The Chase Test for Lossless Join
In Section 3.4.1 we argued why a particular decomposition, that of R (A ,B ,C )
into {A ,B } and {B ,C }, with a particular FD, B —► C, had a lossless join. 
Now, consider a more general situation. We have decomposed relation R into 
relations with sets of attributes S \,S 2 ,--- ,S k■ We have a given set of FD’s 
F that hold in R. Is it true that if we project R onto the relations of the 
decomposition, then we can recover R by taking the natural join of all these 
relations? That is, is it true that 7TSj (R) ix 7rs2 (R) tx • • • m -KSk (R) = R? Three 
important things to remember are:
• The natural join is associative and commutative. It does not matter in 
what order we join the projections; we shall get the same relation as a 
result. In particular, the result is the set of tuples t such that for all 
i — 1 , 2 t projected onto the set of attributes St is a tuple in 
7rs;(-R).
3.4. DECOMPOSITION: THE GOOD, BAD, AND UGLY 97
• Any tuple t in R is surely in ns1(R) 1x1 71 s 2 (R) tx •• • cx nsk (R) ■ The 
reason is that the projection of t onto Si is surely in 7rs; (R) for each i,
and therefore by our first point above, t is in the result of the join.
• As a consequence, 7^ (R) m 7t,s 2 (R) tx • • • ix ir s k (R) — R when the FD’s 
in F hold for R if and only if every tuple in the join is also in R. That is, 
the membership test is all we need to verify that the decomposition has 
a lossless join.
The chase test for a lossless join is just an organized way to see whether a 
tuple t in 7T.SJ(R) tx its2 {R) xj • • • tx nsk(R) can be proved, using the FD’s in 
F, also to be a tuple in R. If t is in the join, then there must be tuples in R,
say h , t 2 , ■ ■ ■ ,tk, such that t is the join of the projections of each ti onto the 
set of attributes Si, for * = 1 ,2 ,... , k. We therefore know that ti agrees with t
on the attributes of Si, but ti has unknown values in its components not in 5,.
We draw a picture of what we know, called a tableau. Assuming R has 
attributes A ,B ,... we use a ,b ,... for the components of t. For ti, we use the 
same letter as t in the components that are in Si, but we subscript the letter 
with i if the component is not in i. In that way, ti will agree with t for the 
attributes of S», but have a unique value — one that can appear nowhere else 
in the tableau — for other attributes.
E xam ple 3.22: Suppose we have relation R (A ,B ,C ,D ), which we have decomposed into relations with sets of attributes Si — {A ,D }, S2 = {A ,C }, and 
S3 — {B ,C ,D }. Then the tableau for this decomposition is shown in Fig. 3.9.
A B C D
a bi Cl d
a 62 c d2
a3 b c d
Figure 3.9: Tableau for the decomposition of R into {A ,D }, {A ,C }, and 
{B ,C ,D }
The first row corresponds to set of attributes A and D. Notice that the 
components for attributes A and D are the unsubscripted letters a and d.
However, for the other attributes, b and c, we add the subscript 1 to indicate that 
they are arbitrary values. This choice makes sense, since the tuple (a,bi,Ci,d)
represents a tuple of R that contributes to t = (a, b, c, d) by being projected onto 
{A, D} and then joined with other tuples. Since the B- and C-components of 
this tuple are projected out, we know nothing yet about what values the tuple 
had for those attributes.
Similarly, the second row has the unsubscripted letters in attributes A and
C, while the subscript 2 is used for the other attributes. The last row has the 
unsubscripted letters in components for {B, C, D} and subscript 3 on a. Since
98 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
each row uses its own number as a subscript, the only symbols that can appear 
more than once are the unsubscripted letters. □
Remember that our goal is to use the given set of FD’s F to prove that t is 
really in R. In order to do so, we “chase” the tableau by applying the FD’s in 
F to equate symbols in the tableau whenever we can. If we discover that one of 
the rows is actually the same as t (that is, the row becomes all unsubscripted 
symbols), then we have proved that any tuple t in the join of the projections 
was actually a tuple of R.
To avoid confusion, when equating two symbols, if one of them is unsubscripted, make the other be the same. However, if we equate two symbols, both 
with their own subscript, then you can change either to be the other. However, 
remember that when equating symbols, you must change all occurrences of one 
to be the other, not just some of the occurences.
E xam ple 3 .2 3 : Let us continue with the decomposition of Example 3.22, and 
suppose the given FD’s are A —>■ B, B —► C, and CD —¥ A. Start with the 
tableau of Fig. 3.9. Since the first two rows agree in their A-components, the FD 
A —¥ B tells us they must also agree in their 5-components. That is, b\ = b2.
We can replace either one with the other, since they are both subscripted. Let 
us replace b2 by &i. Then the resulting tableau is:
A B C D
a bi Cl d
a bi c d2
a-3 b c d
Now, we see that the first two rows have equal B-values, and so we may use 
the FD B —¥ C to deduce that their C-components, ci and c, are the same. 
Since c is unsubscripted, we replace Ci by c, leaving:
A B C D
a bi c d
a bi c d2
a3 b c d
Next, we observe that the first and third rows agree in both columns C and
D. Thus, we may apply the FD CD —¥ A to deduce that these rows also have 
the same A-value; that is, a — a3. We replace a3 by a, giving us:
A B C D
a bi c d
a b1 c d2
a b c d
3.4. DECOMPOSITION: THE GOOD, BAD, AND UGLY 99
At this point, we see that the last row has become equal to t, that is, 
(a,b,c,d). We have proved that if R satisfies the FD’s A ->■ B, B ->• C, and 
CD A, then whenever we project onto {A. D}, {A, C \, and {B ,C ,D } and 
rejoin, what we get must have been in R. In particular, what we get is the same 
as the tuple of R that we projected onto {B ,C ,D }. □
3.4.3 W hy the Chase Works
There are two issues to address:
1. When the chase results in a row that matches the tuple t (i.e., the tableau 
is shown to have a row with all unsubscripted variables), why must the 
join be lossless?
2. When, after applying FD’s whenever we can, we still find no row of all 
unsubscripted variables, why must the join not be lossless?
Question (1) is easy to answer. The chase process itself is a proof that one 
of the projected tuples from R must in fact be the tuple t that is produced by 
the join. We also know that every tuple in R is sure to come back if we project 
and join. Thus, the chase has proved that the result of projection and join is 
exactly R.
For the second question, suppose that we eventually derive a tableau without 
an unsubscripted row, and that this tableau does not allow us to apply any of 
the FD’s to equate any symbols. Then think of the tableau as an instance of the 
relation R. It obviously satisfies the given FD’s, because none can be applied 
to equate symbols. We know that the ith row has unsubscripted symbols in the 
attributes of Si, the *th relation of the decomposition. Thus, when we project 
this relation onto the S i’s and take the natural join, we get the tuple with all 
unsubscripted variables. This tuple is not in R, so we conclude that the join is 
not lossless.
E xam ple 3.24: Consider the relation R (A ,B ,C ,D ) with the FD B — AD
and the proposed decomposition {A, B}, {B, C}, and {C, D}. Here is the initial 
tableau:
A B C D
a b Cl di
0 ,2 b c
0.3 fa c d
When we apply the lone FD, we deduce that a = and d\ = (fa. Thus, the 
final tableau is:
A B C D
a b Cl di
a b c di
03 &3 c d
100 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
No more changes can be made because of the given FD’s, and there is no 
row that is fully unsubscripted. Thus, this decomposition does not have a 
lossless join. We can verify that fact by treating the above tableau as a relation 
with three tuples. When we project onto {A ,B }, we get {(a, 6)}, (03, 63)}. 
The projection onto {B ,C } is {(6, ci), (6, c), (63, 0)}, and the projection onto 
{C, D} is (cr,di), (c, di), (c, d)}. If we join the first two projections, we get 
{(a, 6, ci), (a, 6, c), (03, 63, 0)}. Joining this relation with the third projection 
gives {(0 , 6, ci,di), (a,b,c,di), (a,b,c,d), (a3 ,b3 ,c ,d i), (o3, 63, c, d)}. Notice 
that this join has two more tuples than R, and in particular it has the tuple 
(a, 6, c, d), as it must. □
3.4.4 Dependency Preservation
We mentioned that it is not possible, in some cases, to decompose a relation into 
BCNF relations that have both the lossless-join and dependency-preservation 
properties. Below is an example where we need to make a tradeoff between 
preserving dependencies and BNCF.
Exam ple 3.25: Suppose we have a relation Bookings with attributes:
1. t i t l e , the name of a movie.
2. th e a te r, the name of a theater where the movie is being shown.
3. c ity , the city where the theater is located.
The intent behind a tuple (m ,t,c ) is that the movie with title m is currently 
being shown at theater t in city c.
We might reasonably assert the following FD’s:
th e a te r —> c ity 
t i t l e c ity -» th e a te r
The first says that a theater is located in one city. The second is not obvious 
but is based on the common practice of not booking a movie into two theaters 
in the same city. We shall assert this FD if only for the sake of the example.
Let us first find the keys. No single attribute is a key. For example, t i t l e 
is not a key because a movie can play in several theaters at once and in several 
cities at once.2 Also, th e a te r is not a key, because although th e a te r functionally determines c ity , there are multiscreen theaters that show many movies 
at once. Thus, th e a te r does not determine t i t l e . Finally, c ity is not a key 
because cities usually have more than one theater and more than one movie 
playing.
2In th is exam ple we assum e th a t th ere are not two “cu rren t” movies w ith th e sam e title, 
even though we have previously recognized th a t th ere could be two m ovies w ith th e sam e 
title m ade in different years.
3.4. DECOMPOSITION: THE GOOD, BAD, AND UGLY 1 0 1
On the other hand, two of the three sets of two attributes are keys. Clearly 
{ t i t le , city } is a key because of the given FD that says these attributes 
functionally determine th e a te r.
It is also true that { th eater, t i t l e } is a key, because its closure includes 
c ity due to the given FD th e a te r —¥ c ity . The remaining pair of attributes, 
c ity and th e a te r, do not functionally determine t i t l e , because of multiscreen 
theaters, and are therefore not a key. We conclude that the only two keys are
{ t i t le , city }
{ th eate r, t i t l e }
Now we immediately see a BCNF violation. We were given functional dependency th e a te r —¥ c ity , but its left side, th e a te r, is not a superkey. We 
are therefore tempted to decompose, using this BCNF-violating FD, into the 
two relation schemas:
{ th eate r, city }
{ th eate r, t i t l e }
There is a problem with this decomposition, concerning the FD
t i t l e c ity —^th eater
There could be current relations for the decomposed schemas that satisfy the 
FD th e a te r —> c ity (which can be checked in the relation { th eater, city}) 
but that, when joined, yield a relation not satisfying t i t l e c ity —^theater. 
For instance, the two relations
theater city
Guild
Park
Menlo
Menlo
Park
Park
and
theater title
Guild Antz
Park Antz
are permissible according to the FD’s that apply to each of the above relations, 
but when we join them we get two tuples
theater city title
Guild Menlo Park Antz
Park Menlo Park Antz
that violate the FD t i t l e c ity —¥ th e a te r. □
102 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
3.4.5 Exercises for Section 3.4
Exercise 3.4.1: Let R(A, B, C, D, E) be decomposed into relations with the 
following three sets of attributes: {A, B, C}, {B, C, D}, and {A, C, E). For each 
of the following sets of FD’s, use the chase test to tell whether the decomposition 
of R is lossless. For those that are not lossless, give an example of an instance 
of R that returns more than R when projected onto the decomposed relations 
and rejoined.
a) B —^ E and CE —¥ A.
b) AC -» E and BC D.
c) A >■ D , D —^ E , and B —^ D.
d) A —>■ D , CD —> E , and E —^ D.
Exercise 3.4.2: For each of the sets of FD’s in Exercise 3.4.1, are dependencies 
preserved by the decomposition?
3.5 Third Normal Form
The solution to the problem illustrated by Example 3.25 is to relax our BCNF 
requirement slightly, in order to allow the occasional relation schema that cannot be decomposed into BCNF relations without our losing the ability to check 
the FD’s. This relaxed condition is called “third normal form.” In this section 
we shall give the requirements for third normal form, and then show how to 
do a decomposition in a manner quite different from Algorithm 3.20, in order 
to obtain relations in third normal form that have both the lossless-join and 
dependency-preservation properties.
3.5.1 Definition of Third Normal Form
A relation R is in third normal form (3NF) if:
• Whenever Ai A2 ■ ■ ■ A„ —>■ B iB 2 ■ ■ ■ Bm is a nontrivial FD, either
{Ai ,A 2,... ,A„}
is a superkey, or those of B%, B2 ,... , B m that are not among the A’s, are 
each a member of some key (not necessarily the same key).
An attribute that is a member of some key is often said to be prime. Thus, the 
3NF condition can be stated as “for each nontrivial FD, either the left side is a 
superkey, or the right side consists of prime attributes only.”
Note that the difference between this 3NF condition and the BCNF condition is the clause “is a member of some key (i.e., prime).” This clause “excuses” 
an FD like th e a te r —> c ity in Example 3.25, because the right side, city , is 
prime.
3.5. THIRD NORMAL FORM 103
Other Normal Forms
If there is a “third normal form,” what happened to the first two “normal forms”? They indeed were defined, but today there is little use for 
them. First normal form is simply the condition that every component 
of every tuple is an atomic value. Second normal form is a less restrictive 
verison of 3NF. There is also a “fourth normal form” that we shall meet 
in Section 3.6.
3.5.2 The Synthesis Algorithm for 3NF Schemas
We can now explain and justify how we decompose a relation R into a set of 
relations such that:
a) The relations of the decomposition are all in 3NF.
b) The decomposition has a lossless join.
c) The decomposition has the dependency-preservation property.
A lgorithm 3.26: Synthesis of Third-Normal-Form Relations With a Lossless 
Join and Dependency Preservation.
INPUT: A relation R and a set F of functional dependencies that hold for R.
O U T P U T : A decomposition of R into a collection of relations, each of which is 
in 3NF. The decomposition has the lossless-join and dependency-preservation 
properties.
M E T H O D : Perform the following steps:
1. Find a minimal basis for F, say G.
2. For each functional dependency X —> A in G, use X A as the schema of 
one of the relations in the decomposition.
3. If none of the relation schemas from Step 2 is a superkey for R, add 
another relation whose schema is a key for R.
□
E xam ple 3.27: Consider the relation R (A ,B ,C ,D ,E ) with FD’s A B —>■ C,
C -»■ B, and A ->■ D. To start, notice that the given FD’s are their own 
minimal basis. To check, we need to do a bit of work. First, we need to verify 
that we cannot eliminate any of the given dependencies. That is, we show, 
using Algorithm 3.7, that no two of the FD’s imply the third. For example, 
we must take the closure of {A, B}, the left side of the first FD, using only the
104 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
second and third FD’s, C —» B and A —> D. This closure includes D but not
C, so we conclude that the first FD AB —>• C is not implied by the second and 
third FD’s. We get a similar conclusion if we try to drop the second or third 
FD.
We must also verify that we cannot eliminate any attributes from a left 
side. In this simple case, the only possibility is that we could eliminate A or 
B from the first FD. For example, if we eliminate A, we would be left with 
B —► C. We must show that B C is not implied by the three original FD’s, 
A B C, C B, and A —> D. With these FD’s, the closure of {5} is just B,
so B —> C does not follow. A similar conclusion is drawn if we try to drop B
from A B -> C. Thus, we have our minimal basis.
We start the 3NF synthesis by taking the attributes of each FD as a relation 
schema. That is, we get relations S i(A ,B ,C ), S2 {B, C). and Sz{A,D). It is 
never necessary to use a relation whose schema is a proper subset of another 
relation’s schema, so we can drop
We must also consider whether we need to add a relation whose schema is 
a key. In this example, R has two keys: {A ,B ,E } and {A ,C ,E }, as you can 
verify. Neither of these keys is a subset of the schemas chosen so far. Thus, we 
must add one of them, say Sn(A ,B ,E ). The final decomposition of R is thus 
S i(A ,B ,C ), Ss(A,D ), and S4 (A ,B ,E ). □
3.5.3 Why the 3NF Synthesis Algorithm Works
We need to show three things: that the lossless-join and dependency-preservation properties hold, and that all the relations of the decomposition are in 
3NF.
1. Lossless Join. Start with a relation of the decomposition whose set of 
attributes K is a superkey. Consider the sequence of FD’s that are used 
in Algorithm 3.7 to expand K to become K +. Since i f is a superkey, 
we know K + is all the attributes. The same sequence of FD applications 
on the tableau cause the subscripted symbols in the row corresponding 
to K to be equated to unsubscripted symbols in the same order as the 
attributes were added to the closure. Thus, the chase test concludes that 
the decomposition is lossless.
2. Dependency Preservation. Each FD of the minimal basis has all its attributes in some relation of the decomposition. Thus, each dependency 
can be checked in the decomposed relations.
3. Third Normal Form. If we have to add a relation whose schema is a key, 
then this relation is surely in 3NF. The reason is that all attributes of this 
relation are prime, and thus no violation of 3NF could be present in this 
relation. For the relations whose schemas are derived from the FD’s of a 
minimal basis, the proof that they are in 3NF is beyond the scope of this 
book. The argument involves showing that a 3NF violation implies that 
the basis is not minimal.
3.6. MULTIVALUED DEPENDENCIES 105
3.5.4 Exercises for Section 3.5
E xercise 3.5.1: For each of the relation schemas and sets of FD’s of Exercise 3.3.1:
i) Indicate all the 3NF violations.
ii) Decompose the relations, as necessary, into collections of relations that 
are in 3NF.
Exercise 3.5.2: Consider the relation Courses(C ,T ,H ,R ,S ,G ), whose attributes may be thought of informally as course, teacher, hour, room, student, 
and grade. Let the set of FD’s for Courses be C —>■ T, H R —> C, H T -»• R,
H S -¥ R, and C S ->• G. Intuitively, the first says that a course has a unique 
teacher, and the second says that only one course can meet in a given room at 
a given hour. The third says that a teacher can be in only one room at a given 
hour, and the fourth says the same about students. The last says that students 
get only one grade in a course.
a) What are all the keys for Courses?
b) Verify that the given FD’s are their own minimal basis.
c) Use the 3NF synthesis algorithm to find a lossless-join, dependency-preserving decomposition of R into 3NF relations. Are any of the relations 
not in BCNF?
Exercise 3.5.3: Consider a relation Stocks(B, O, I, S, Q, D), whose attributes 
may be thought of informally as broker, office (of the broker), investor, stock, 
quantity (of the stock owned by the investor), and dividend (of the stock). Let 
the set of FD’s for Stocks be S —> D, I B, IS ^ Q, and B —> O. Repeat 
Exercise 3.5.2 for the relation Stocks.
E xercise 3.5.4: Verify, using the chase, that the decomposition of Example 3.27 has a lossless join.
!! E xercise 3.5.5: Suppose we modified Algorithm 3.20 (BNCF decomposition) 
so that instead of decomposing a relation R whenever R was not in BCNF, we 
only decomposed R if it was not in 3NF. Provide a counterexample to show that 
this modified algorithm would not necessarily produce a 3NF decomposition 
with dependency preservation.
3.6 M ultivalued Dependencies
A “multivalued dependency” is an assertion that two attributes or sets of attributes are independent of one another. This condition is, as we shall see, 
a generalization of the notion of a functional dependency, in the sense that
106 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
every FD implies the corresponding multivalued dependency. However, there 
are some situations involving independence of attribute sets that cannot be 
explained as FD’s. In this section we shall explore the cause of multivalued 
dependencies and see how they can be used in database schema design.
3.6.1 Attribute Independence and Its Consequent
Redundancy
There are occasional situations where we design a relation schema and find it is 
in BCNF, yet the relation has a kind of redundancy that is not related to FD’s. 
The most common source of redundancy in BCNF schemas is an attempt to 
put two or more set-valued properties of the key into a single relation.
Exam ple 3.28: In this example, we shall suppose that stars may have several 
addresses, which we break into street and city components. The set of addresses 
is one of the set-valued properties this relation will store. The second set-valued 
property of stars that we shall put into this relation is the set of titles and years 
of movies in which the star appeared. Then Fig. 3.10 is a typical instance of 
this relation.
name street city title year
C. Fisher 123 Maple St. Hollywood Star Wars 1977
C. Fisher 5 Locust Ln. Malibu Star Wars 1977
C. Fisher 123 Maple St. Hollywood Empire Strikes Back 1980
C. Fisher 5 Locust Ln. Malibu Empire Strikes Back 1980
C. Fisher 123 Maple St. Hollywood Return of the Jedi 1983
C. Fisher 5 Locust Ln. Malibu Return of the Jedi 1983
Figure 3.10: Sets of addresses independent from movies
We focus in Fig. 3.10 on Carrie Fisher’s two hypothetical addresses and her 
three best-known movies. There is no reason to associate an address with one 
movie and not another. Thus, the only way to express the fact that addresses 
and movies are independent properties of stars is to have each address appear 
with each movie. But when we repeat address and movie facts in all combinations, there is obvious redundancy. For instance, Fig. 3.10 repeats each of 
Carrie Fisher’s addresses three times (once for each of her movies) and each 
movie twice (once for each address).
Yet there is no BCNF violation in the relation suggested by Fig. 3.10. There 
are, in fact, no nontrivial FD’s at all. For example, attribute c ity is not 
functionally determined by the other four attributes. There might be a star 
with two homes that had the same street address in different cities. Then there 
would be two tuples that agreed in all attributes but c ity and disagreed in 
city . Thus,
3.6. MULTIVALUED DEPENDENCIES 107
name street title year —> city
is not an FD for our relation. We leave it to the reader to check that none of 
the five attributes is functionally determined by the other four. Since there are 
no nontrivial FD’s, it follows that all five attributes form the only key and that 
there are no BCNF violations. □
3.6.2 Definition of Multivalued Dependencies
A multivalued dependency (abbreviated MVD) is a statement about some relation R that when you fix the values for one set of attributes, then the values in 
certain other attributes are independent of the values of all the other attributes 
in the relation. More precisely, we say the MVD
A1 A2 ■ ■ ■ A n —>4 B 1 B2 ■ ■ ■ B m
holds for a relation R if when we restrict ourselves to the tuples of R that have 
particular values for each of the attributes among the ,4’s, then the set of values 
we find among the B ’s is independent of the set of values we find among the 
attributes of R that are not among the ,4’s or B ’s. Still more precisely, we say 
this MVD holds if
For each pair of tuples t and u of relation R that agree on all the 
j4’s, we can find in R some tuple v that agrees:
1. With both t and u on the A’s,
2. With t on the B ’s, and
3. With u on all attributes of R that axe not among the A's or 
B ’s.
Note that we can use this rule with t and u interchanged, to infer the existence 
of a fourth tuple w that agrees with u on the B ’s and with t on the other 
attributes. As a consequence, for any fixed values of the A’s, the associated 
values of the B ’s and the other attributes appear in all possible combinations 
in different tuples. Figure 3.11 suggests how v relates to t and u when an MVD 
holds. However, the ^4’s and B ’s to not have to appear consecutively.
In general, we may assume that the .4’s and B ’s (left side and right side) of 
an MVD are disjoint. However, as with FD’s, it is permissible to add some of 
the A's to the right side if we wish.
E xam ple 3.29: In Example 3.28 we encountered an MVD that in our notation 
is expressed:
name —H street city
That is, for each star’s name, the set of addresses appears in conjunction with 
each of the star’s movies. For an example of how the formal definition of this 
MVD applies, consider the first and fourth tuples from Fig. 3.10:
108 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
Figure 3.11: A multivalued dependency guarantees that v exists
name street city title year
C. Fisher 123 Maple St. Hollywood Star Wars 1977
C. Fisher 5 Locust Ln. Malibu Empire Strikes Back 1980
If we let the first tuple be t and the second be u, then the MVD asserts 
that we must also find in R the tuple that has name C. Fisher, a street and 
city that agree with the first tuple, and other attributes ( t i t l e and year) that 
agree with the second tuple. There is indeed such a tuple; it is the third tuple 
of Fig. 3.10.
Similarly, we could let t be the second tuple above and u be the first. Then 
the MVD tells us that there is a tuple of R that agrees with the second in 
attributes name, s tre e t, and c ity and with the first in name, t i t l e , and year. 
This tuple also exists; it is the second tuple of Fig. 3.10. □
3.6.3 Reasoning About Multivalued Dependencies
There are a number of rules about MVD’s that are similar to the rules we 
learned for FD’s in Section 3.2. For example, MVD’s obey
• Trivial MVD’s. The MVD
Ai A2 • • • An — B\ B2 • • • Bm
holds in any relation if {Bi, B2 , ... , B m} C {Ai, A2 , ... , A n}.
• The transitive rule, which says that if Ai A2 ■ ■ ■ A n —H B iB 2 ■ • ■ B m and 
B1 B2 - ■■ B m —>-> C1C2 • • • Ck hold for some relation, then so does
A1 A2 ■ ■ ■ A n —h C1 C2 • • • Ck
Any C ’s that are also ^4’s must be deleted from the right side.
3.6. MULTIVALUED DEPENDENCIES 109
On the other hand, MVD’s do not obey the splitting part of the splitting/combining rule, as the following example shows.
E xam ple 3.30: Consider again Fig. 3.10, where we observed the MVD:
name —H s tr e e t c ity 
If the splitting rule applied to MVD’s, we would expect
name —H s tr e e t
also to be true. This MVD says that each star’s street addresses are independent of the other attributes, including c ity . However, that statement is false. 
Consider, for instance, the first two tuples of Fig. 3.10. The hypothetical MVD 
would allow us to infer that the tuples with the streets interchanged:
name street city title year
C. Fisher 5 Locust Ln. Hollywood Star Wars 1977
C. Fisher 123 Maple St. Malibu Star Wars 1977
were in the relation. But these are not true tuples, because, for instance, the 
home on 5 Locust Ln. is in Malibu, not Hollywood. □
However, there are several new rules dealing with MVD’s that we can learn.
• FD Promotion. Every FD is an MVD. That is, if
A1 A2 • • • A n —»• B 1 B2 ■ ■ ■ B m
then A\ A2 • ■ ■ An —>-> B \ B2 • ■ ■ B m.
To see why, suppose R is some relation for which the FD
A 1 A2 ■ • ■ A n —¥ B 1B2 ■ • • B m
holds, and suppose t and u are tuples of R that agree on the A’s. To show 
that the MVD A1 A2 ■ ■ ■ An —H- B 1B2 ■ ■ ■ B m holds, we have to show that R
also contains a tuple v that agrees with t and u on the A’s, with t on the B ’s,
and with u on all other attributes. But v can be u. Surely u agrees with t and 
u on the .4’s, because we started by assuming that these two tuples agree on 
the j4’s. The FD A 1A2 ■ ■■ A n —> B iB ^ - - B m assures us that u agrees with t
on the S ’s. And of course u agrees with itself on the other attributes. Thus, 
whenever an FD holds, the corresponding MVD holds.
• Complementation Rule. If A1 A2 ■ • ■ A n —B- B1 B2 ■ ■ ■ Bm is an MVD for 
relation R, then R also satisfies A 1 A2 ■ ■ ■ A„ -++ C1 C2 ■ ■ ■ Ck, where the 
C ’s are all attributes of R not among the A.’s and B ’s.
110 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
That is, swapping the B ’s between two tuples that agree in the v4’s has the 
same effect as swapping the C s.
E xam ple 3.31: Again consider the relation of Fig. 3.10, for which we asserted 
the MVD:
name —»-> s tr e e t c ity 
The complementation rule says that
name — title year
must also hold in this relation, because t i t l e and year are the attributes not 
mentioned in the first MVD. The second MVD intuitively means that each star 
has a set of movies starred in, which are independent of the star’s addresses.
□
An MVD whose right side is a subset of the left side is trivial — it holds 
in every relation. However, an interesting consequence of the complementation 
rule is that there are some other MVD’s that are trivial, but that look distinctly 
nontrivial.
• More Trivial MVD’s. If all the attributes of relation R are
{Ai,A2,... ,An,Bi,B2,--. ,Bm}
then A1A2 ■ ■ ■ An -h- B1 B2 ■ ■ ■ Bm holds in R.
To see why these additional trivial MVD’s hold, notice that if we take two 
tuples that agree in A i, A2 ,... , An and swap their components in attributes 
B i,B 2 ,-.- ,B m, we get the same two tuples back, although in the opposite 
order.
3.6.4 Fourth Normal Form
The redundancy that we found in Section 3.6.1 to be caused by MVD’s can be 
eliminated if we use these dependencies for decomposition. In this section we 
shall introduce a new normal form, called “fourth normal form.” In this normal 
form, all nontrivial MVD’s are eliminated, as are all FD’s that violate BCNF. 
As a result, the decomposed relations have neither the redundancy from FD’s 
that we discussed in Section 3.3.1 nor the redundancy from MVD’s that we 
discussed in Section 3.6.1.
The “fourth normal form” condition is essentially the BCNF condition, but 
applied to MVD’s instead of FD’s. Formally:
• A relation R is in fourth normal form (4NF) if whenever
Ai A2 ■ ■ ■ An —H- B\B2 ■ ■ ■ Bm
3.6. MULTIVALUED DEPENDENCIES 1 1 1
is a nontrivial MVD, { A i,A 2 , ... , A n} is a superkey.
That is, if a relation is in 4NF, then every nontrivial MVD is really an FD with 
a superkey on the left. Note that the notions of keys and super keys depend on 
FD’s only; adding MVD’s does not change the definition of “key.”
E xam ple 3.32: The relation of Fig. 3.10 violates the 4NF condition. For 
example,
name — street city
is a nontrivial MVD, yet name by itself is not a superkey. In fact, the only key 
for this relation is all the attributes. □
Fourth normal form is truly a generalization of BCNF. Recall from Section 3.6.3 that every FD is also an MVD. Thus, every BCNF violation is also 
a 4NF violation. Put another way, every relation that is in 4NF is therefore in 
BCNF.
However, there are some relations that are in BCNF but not 4NF. Figure 3.10 is a good example. The only key for this relation is all five attributes, 
and there are no nontrivial FD’s. Thus it is surely in BCNF. However, as we 
observed in Example 3.32, it is not in 4NF.
3.6.5 Decomposition into Fourth Normal Form
The 4NF decomposition algorithm is quite analogous to the BCNF decomposition algorithm.
A lgorithm 3.33: Decomposition into Fourth Normal Form.
INPUT: A relation Ro with a set of functional and multivalued dependencies
S0.
O U T P U T : A decomposition of Ro into relations all of which are in 4NF. The 
decomposition has the lossless-join property.
M E T H O D : Do the following steps, with R — Ro and S = So'-
1. Find a 4NF violation in R, say A1 A2 ---A n B \B 2 ■ ■ ■ B m. where
{Ai, A2, .. ■ , A n}
is not a superkey. Note this MVD could be a true MVD in S, or it could 
be derived from the corresponding FD .41^-2 ■ • • An —>■ B iB 2 • • • B m in S,
since every FD is an MVD. If there is none, return; R by itself is a suitable 
decomposition.
2. If there is such a 4NF violation, break the schema for the relation R that 
has the 4NF violation into two schemas:
112 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
(a) R i, whose schema is A’s and the B's.
(b) R2 , whose schema is the ^4’s and all attributes of R that are not 
among the A’s or B ’s.
3. Find the FD’s and MVD’s that hold in R i and R2 (Section 3.7 explains 
how to do this task in general, but often this “projection” of dependencies 
is straightforward). Recursively decompose jRi and R2 with respect to 
their projected dependencies.
□
E xam ple 3.34: Let us continue Example 3.32. We observed that
name — street c ity
was a 4NF violation. The decomposition rule above tells us to replace the 
five-attribute schema by one schema that has only the three attributes in the 
above MVD and another schema that consists of the left side, name, plus the 
attributes that do not appear in the MVD. These attributes are t i t l e and 
year, so the following two schemas
{name, s tr e e t, city}
{name, t i t l e , year}
are the result of the decomposition. In each schema there are no nontrivial 
multivalued (or functional) dependencies, so they are in 4NF. Note that in the 
relation with schema {name, s tr e e t, city}, the MVD:
name s tr e e t c ity
is trivial since it involves all attributes. Likewise, in the relation with schema 
{name, t i t l e , year}, the MVD:
name —H t i t l e year
is trivial. Should one or both schemas of the decomposition not be in 4NF, we 
would have had to decompose the non-4NF schema(s). □
As for the BCNF decomposition, each decomposition step leaves us with 
schemas that have strictly fewer attributes than we started with, so eventually 
we get to schemas that need not be decomposed further; that is, they are 
in 4NF. Moreover, the argument justifying the decomposition that we gave 
in Section 3.4.1 carries over to MVD’s as well. When we decompose a relation 
because of an MVD A iA 2 ■ ■ ■ A„ -H- B iB 2 ■ ■ ■ B m, this dependency is enough to 
justify the claim that we can reconstruct the original relation from the relations 
of the decomposition.
We shall, in Section 3.7, give an algorithm by which we can verify that the 
MVD used to justify a 4NF decomposition also proves that the decomposition 
has a lossless join. Also in that section, we shall show how it is possible, although 
time-consuming, to perform the projection of MVD’s onto the decomposed 
relations. This projection is required if we are to decide whether or not further 
decomposition is necessary.
3.6. MULTIVALUED DEPENDENCIES 113
3.6.6 Relationships Among Normal Forms
As we have mentioned, 4NF implies BCNF, which in turn implies 3NF. Thus, 
the sets of relation schemas (including dependencies) satisfying the three normal 
forms are related as in Fig. 3.12. That is, if a relation with certain dependencies is in 4NF, it is also in BCNF and 3NF. Also, if a relation with certain 
dependencies is in BCNF, then it is in 3NF.
R elations in 3N F
R elations in B C N F
R elations in 4N F
Figure 3.12: 4NF implies BCNF implies 3NF
Another way to compare the normal forms is by the guarantees they make 
about the set of relations that result from a decomposition into that normal 
form. These observations are summarized in the table of Fig. 3.13. That is, 
BCNF (and therefore 4NF) eliminates the redundancy and other anomalies 
that are caused by FD’s, while only 4NF eliminates the additional redundancy 
that is caused by the presence of MVD’s that are not FD’s. Often, 3NF is 
enough to eliminate this redundancy, but there are examples where it is not. 
BCNF does not guarantee preservation of FD’s, and none of the normal forms 
guarantee preservation of MVD’s, although in typical cases the dependencies 
are preserved.
Property 3NF BCNF 4NF
Eliminates redundancy 
due to FD’s
No Yes Yes
Eliminates redundancy 
due to MVD’s
No No Yes
Preserves FD’s Yes No No
Preserves MVD’s No No No
Figure 3.13: Properties of normal forms and their decompositions
3.6.7 Exercises for Section 3.6
E xercise 3.6.1: Suppose we have a relation R(A, B, C) with an MVD A —H-
114 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
B. If we know that the tuples (a,6i,ci), (a, &2, c-2), and (0 , 63, 03) are in the 
current instance of R, what other tuples do we know must also be in R I
Exercise 3.6.2: Suppose we have a relation in which we want to record for 
each person their name, Social Security number, and birthdate. Also, for each 
child of the person, the name, Social Security number, and birthdate of the 
child, and for each automobile the person owns, its serial number and make. 
To be more precise, this relation has all tuples
(n, s, b, cn, cs, cb, as, am)
such that
1. n is the name of the person with Social Security number s.
2. b is n ’s birthdate.
3. cn is the name of one of n ’s children.
4. cs is cn’s Social Security number.
5. cb is cn’s birthdate.
6. as is the serial number of one of n ’s automobiles.
7. am is the make of the automobile with serial number as.
For this relation:
a) Tell the functional and multivalued dependencies we would expect to hold.
b) Suggest a decomposition of the relation into 4NF.
Exercise 3.6.3: For each of the following relation schemas and dependencies
a) R{A, B, C, D) with MVD’s A -H- B and A -»■ C.
b) R(A, B, C, D) with MVD’s A -H- B and B -*-» CD.
c) R(A, B, C, D) with MVD AB -H- C and FD B -> D.
d) R (A ,B ,C ,D ,E ) with MVD’s A -H- B and A B C and FD’s A -> D
and AB -» E.
do the following:
i) Find all the 4NF violations.
ii) Decompose the relations into a collection of relation schemas in 4NF.
Exercise 3.6.4: Give informal arguments why we would not expect any of the 
five attributes in Example 3.28 to be functionally determined by the other four.
3.7. A N ALGORITHM FOR DISCOVERING M VD ’S 115
3.7 An Algorithm for Discovering M V D ’s
Reasoning about MVD’s, or combinations of MVD’s and FD’s, is rather more 
difficult than reasoning about FD’s alone. For FD’s, we have Algorithm 3.7 to 
decide whether or not an FD follows from some given FD’s. In this section, 
we shall first show that the closure algorithm is really the same as the chase 
algorithm we studied in Section 3.4.2. The ideas behind the chase can be 
extended to incorporate MVD’s as well as FD’s. Once we have that tool in 
place, we can solve all the problems we need to solve about MVD’s and FD’s, 
such as finding whether an MVD follows from given dependencies or projecting 
MVD’s and FD’s onto the relations of a decomposition.
3.7.1 The Closure and the Chase
In Section 3.2.4 we saw how to take a set of attributes X and compute its 
closure X + of all attributes that functionally depend on X . In that manner, we 
can test whether an FD X -¥ Y follows from a given set of FD’s F, by closing 
X with respect to F and seeing whether Y C X +. We could see the closure as 
a variant of the chase, in which the starting tableau and the goal condition are 
different from what we used in Section 3.4.2.
Suppose we start with a tableau that consists of two rows. These rows agree 
in the attributes of X and disagree in all other attributes. If we apply the FD’s 
in F to chase this tableau, we shall equate the symbols in exactly those columns 
that are in X + — X . Thus, a chase-based test for whether X —► Y follows from 
F can be summarized as:
1. Start with a tableau having two rows that agree only on X .
2. Chase the tableau using the FD’s of F.
3. If the final tableau agrees in all columns of Y , then X Y holds; otherwise it does not.
E xam ple 3.35: Let us repeat Example 3.8, where we had a relation
R (A ,B ,C ,D ,E ,F )
with FD’s A B —>• C, B C —► AD, D —»• E, and C F —► B. We want to test 
whether A B — D holds. Start with the tableau:
A B C D E F
a b Cl di ei fi
a b C2 d,2 e2 h
We can apply A B C to infer c\ = C2; say both become c±. The resulting 
tableau is:
116 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
A B C D E F
a b Cl d\ ei h
a b Cl di C2 h
Next, apply B C —> AD to infer that d\ = d2, and apply D —>■ E to infer 
ei = e2. At this point, the tableau is:
A B C D E F
a b Cl di ei h
a b Cl di ei h
and we can go no further. Since the two tuples now agree in the D column, we 
know that A B -» D does follow from the given FD’s. □
3.7.2 Extending the Chase to M VD’s
The method of inferring an FD using the chase can be applied to infer MVD’s 
as well. When we try to infer an FD, we are asking whether we can conclude 
that two possibly unequal values must indeed be the same. When we apply an 
FD X —> Y , we search for pairs of rows in the tableau that agree on all the 
columns of X , and we force the symbols in each column of Y to be equal.
However, MVD’s do not tell us to conclude symbols are equal. Rather, 
X —H- Y tells us that if we find two rows of the tableau that agree in X , then 
we can form two new tuples by swapping all their components in the attributes 
of Y ; the resulting two tuples must also be in the relation, and therefore in 
the tableau. Likewise, if we want to infer some MVD X —H- Y from given 
FD’s and MVD’s, we start with a tableau consisting of two tuples that agree 
in X and disagree in all attributes not in the set X . We apply the given 
FD’s to equate symbols, and we apply the given MVD’s to swap the values in 
certain attributes between two existing rows of the tableau in order to add new 
rows to the tableau. If we ever discover that one of the original tuples, with 
its components for Y replaced by those of the other original tuple, is in the 
tableau, then we have inferred the MVD.
There is a point of caution to be observed in this more complex chase process. Since symbols may get equated and replaced by other symbols, we may 
not recognize that we have created one of the desired tuples, because some of 
the original symbols may be replaced by others. The simplest way to avoid a 
problem is to define the target tuple initially, and never change its symbols. 
That is, let the target row be one with an unsubscripted letter in each component. Let the two initial rows of the tableau for the test of X —>-* Y have the 
unsubscripted letters in X . Let the first row also have unsubscripted letters in 
Y , and let the second row have the unsubscripted letters in all attributes not 
in X or Y. Fill in the other positions of the two rows with new symbols that 
each occur only once. When we equate subscripted and unsubscripted symbols, 
always replace a subscripted one by the unsubscripted one, as we did in Section 3.4.2. Then, when applying the chase, we have only to ask whether the 
all-unsubscripted-letters row ever appears in the tableau.
3.7. A N ALGORITHM FOR DISCOVERING M VD ’S 117
E xam ple 3.36: Suppose we have a relation R (A ,B ,C ,D ) with given dependencies A B and B —>4 C. We wish to prove that A —h> C holds in R. Start 
with the two-row tableau that represents A —H- C :
A B C D
a h c di
a b C2 d
Notice that our target row is (a,b,c,d). Both rows of the tableau have the 
unsubscripted letter in the column for A. The first row has the unsubscripted 
letter in C, and the second row has unsubscripted letters in the remaining 
columns.
We first apply the FD A —¥ B to infer that b = b\. We must therefore 
replace the subscripted &i by the unsubscripted b. The tableau becomes:
A B C D
a b c di
a b C2 d
Next, we apply the MVD B —>4 C, since the two rows now agree in the B
column. We swap the C columns to get two more rows which we add to the 
tableau, which becomes:
A B C D
a b c d \
a b C2 d
a b C2 d i
a b C d
We have now a row with all unsubscripted symbols, which proves that A —h- C
holds in relation R. Notice how the tableau manipulations really give a proof 
that A —»-> C holds. This proof is: “Given two tuples of R that agree in A,
they must also agree in B because A -¥ B. Since they agree in B, we can swap 
their C components by B C, and the resulting tuples will be in R. Thus, if 
two tuples of R agree in A, the tuples that result when we swap their C ’s are 
also in R; i.e., A —>-> C.” □
E xam ple 3.37: There is a surprising rule for FD’s and MVD’s that says whenever there is an MVD X —»-» Y , and any FD whose right side is a (not necessarily 
proper) subset of Y , say Z, then X —> Z. We shall use the chase process to 
prove a simple example of this rule. Let us be given relation R(A, B, C, D) with 
MVD A —>4 B C and FD D -¥ C. We claim that A C.
Since we are trying to prove an FD, we don’t have to worry about a target 
tuple of unsubscripted letters. We can start with any two tuples that agree in 
A and disagree in every other column, such as:
118 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
A B C D
a bi C l di
a 62 C2 d,2
Our goal is to prove that cj = C2-
The only thing we can do to start is to apply the MVD A —H BC, since 
the two rows agree on A, but no other columns. When we swap the B and C
columns of these two rows, we get two new rows to add:
A B C D
a bi C l di
a 62 C2 di
a 62 C2 di
a bi C l d2
Now, we have pairs of rows that agree in D, so we can apply the FD D —> C .
For instance, the first and third rows have the same D-value d\ , so we can apply 
the FD and conclude ci = C2. That is our goal, so we have proved A —> C . The 
new tableau is:
A B C D
a bi Cl di
a 62 Cl di
a 62 Cl di
a bi Cl d2
It happens that no further changes are possible, using the given dependencies. 
However, that doesn’t matter, since we already proved what we need. □
3.7.3 Why the Chase Works for M VD’s
The arguments are essentially the same as we have given before. Each step of the 
chase, whether it equates symbols or generates new rows, is a true observation 
about tuples of the given relation R that is justified by the FD or MVD that 
we apply in that step. Thus, a positive conclusion of the chase is always a proof 
that the concluded FD or MVD holds in R.
When the chase ends in failure — the goal row (for an MVD) or the desired 
equality of symbols (for an FD) is not produced — then the final tableau is a 
counterexample. It satisfies the given dependencies, or else we would not be 
finished making changes. However, it does not satisfy the dependency we were 
trying to prove.
There is one other issue that did not come up when we performed the chase 
using only FD’s. Since the chase with MVD’s adds rows to the tableau, how 
do we know we ever terminate the chase? Could we keep adding rows forever, 
never reaching our goal, but not sure that after a few more steps we would 
achieve that goal? Fortunately, that cannot happen. The reason is that we
3.7. A N ALGORITHM FOR DISCOVERING M VD ’S 119
never create any new symbols. We start out with at most two symbols in each 
of k columns, and all rows we create will have one of these two symbols in its 
component for that column. Thus, we cannot ever have more than 2k rows in 
our tableau, if k is the number of columns. The chase with MVD’s can take 
exponential time, but it cannot run forever.
3.7.4 Projecting M VD’s
Recall that our reason for wanting to infer MVD’s was to perform a cascade of 
decompositions leading to 4NF relations. To do that task, we need to be able 
to project the given dependencies onto the schemas of the two relations that 
we get in the first step of the decomposition. Only then can we know whether 
they are in 4NF or need to be decomposed further.
In the worst case, we have to test every possible FD and MVD for each of 
the decomposed relations. The chase test is applied on the full set of attributes 
of the original relation. However, the goal for an MVD is to produce a row 
of the tableau that has unsubscripted letters in all the attributes of one of 
the relations of the decomposition; that row may have any letters in the other 
attributes. The goal for an FD is the same: equality of the symbols in a given 
column.
E xam ple 3.38: Suppose we have a relation R(A, B, C, D, E ) that we decompose, and let one of the relations of the decomposition be 5(A, B, C). Suppose 
that the MVD A —H CD holds in R. Does this MVD imply any dependency 
in S? We claim that A —>4 C holds in S, as does A —>4 B (by the complementation rule). Let us verify that A — C holds in S. We start with the 
tableau:
A B C D E
a bi c di ei
a b Cl d e
Use the MVD of R, A —»-> CD to swap the C and D components of these two 
rows to get two new rows:
A B C D E
a bi c di ei
a b C2 d e
a bi C2 d Cl
a b C di e
Notice that the last row has unsubscripted symbols in all the attributes of S,
that is, A, B, and C. That is enough to conclude that A —B- C holds in S. □
Often, our search for FD’s and MVD’s in the projected relations does not 
have to be completely exhaustive. Here are some simplifications.
120 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
1. It is surely not necessary to check the trivial FD’s and MVD’s.
2. For FD’s, we can restrict ourselves to looking for FD’s with a singleton 
right side, because of the combining rule for FD’s.
3. An FD or MVD whose left side does not contain the left side of any given 
dependency surely cannot hold, since there is no way for its chase test 
to get started. That is, the two rows with which you start the test are 
unchanged by the given dependencies.
3.7.5 Exercises for Section 3.7
E xercise 3 .7 .1 : Use the chase test to tell whether each of the following dependencies hold in a relation R(A, B, C, D, E) with the dependencies A —H- BC,
B -> D, and C -»• E.
a) A -> D.
b) A D.
c) A ^ E .
d) A -H- E.
! E xercise 3 .7 .2 : If we project the relation R of Exercise 3.7.1 onto S(A, C, E),
what nontrivial FD’s and MVD’s hold in S?
! E xercise 3 .7 .3 : Show the following rules for MVD’s. In each case, you can 
set up the proof as a chase test, but you must think a little more generally than 
in the examples, since the set of attributes are arbitrary sets X , Y , Z, and the 
other unnamed attributes of the relation in which these dependencies hold.
a) The Union Rule. If X , Y, and Z are sets of attributes, X —>-» Y , and 
X Z, then X -h- (Y U Z).
b) The Intersection Rule. If X , Y , and Z are sets of attributes, X -y* Y ,
and X — Z, then X —y-y (Y n Z ).
c) The Difference Rule. If X , Y , and Z are sets of attributes, X —h Y , and 
X -»• Z, then X - » ( Y - Z).
d) Removing attributes shared by left and right side. If X —H Y holds, then 
X - » {Y - X ) holds.
! Exercise 3.7.4: Give counterexample relations to show why the following rules 
for MVD’s do not hold. Hint: apply the chase test and see what happens.
a) If A — BC, then A —yy B.
b) If A —H- B, then A —► B.
c) If AB —»-> C, then A -h- C.
.8. SUMM ARY OF CHAPTER 3 121
.8 Summary of Chapter 3
♦ Functional Dependencies: A functional dependency is a statement that 
two tuples of a relation that agree on some particular set of attributes 
must also agree on some other particular set of attributes.
♦ Keys of a Relation: A superkey for a relation is a set of attributes that 
functionally determines all the attributes of the relation. A key is a superkey, no proper subset of which is also a superkey.
♦ Reasoning About Functional Dependencies: There are many rules that let 
us infer that one FD X —» A holds in any relation instance that satisfies 
some other given set of FD’s. To verify that X -» A holds, compute the 
closure of X , using the given FD’s to expand X until it includes A.
♦ Minimal Basis for a set of FD ’s: For any set of FD’s, there is at least 
one minimal basis, which is a set of FD’s equivalent to the original (each 
set implies the other set), with singleton right sides, no FD that can be 
eliminated while preserving equivalence, and no attribute in a left side 
that can be eliminated while preserving equivalence.
♦ Boyce-Codd Normal Form: A relation is in BCNF if the only nontrivial 
FD’s say that some superkey functionally determines one or more of the 
other attributes. A major benefit of BCNF is that it eliminates redundancy caused by the existence of FD’s.
♦ Lossless-Join Decomposition: A useful property of a decomposition is that 
the original relation can be recovered exactly by taking the natural join of 
the relations in the decomposition. Any decomposition gives us back at 
least the tuples with which we start, but a carelessly chosen decomposition 
can give tuples in the join that were not in the original relation.
♦ Dependency-Preserving Decomposition: Another desirable property of a 
decomposition is that we can check all the functional dependencies that 
hold in the original relation by checking FD’s in the decomposed relations.
♦ Third Normal Form: Sometimes decomposition into BCNF can lose the 
dependency-preservation property. A relaxed form of BCNF, called 3NF, 
allows an FD X -»■ A even if X is not a superkey, provided A is a member 
of some key. 3NF does not guarantee to eliminate all redundancy due to 
FD’s, but often does so.
♦ The Chase: We can test whether a decomposition has the lossless-join 
property by setting up a tableau — a set of rows that represent tuples of 
the original relation. We chase a tableau by applying the given functional 
dependencies to infer that certain pairs of symbols must be the same. The 
decomposition is lossless with respect to a given set of FD’s if and only if 
the chase leads to a row identical to the tuple whose membership in the 
join of the projected relations we assumed.
1 2 2 CHAPTER 3. DESIGN THEORY FOR RELATIONAL DATABASES
♦ Synthesis Algorithm, for 3NF: If we take a minimal basis for a given set 
of FD’s, turn each of these FD’s into a relation, and add a key for the 
relation, if necessary, the result is a decomposition into 3NF that has the 
lossless-join and dependency-preservation properties.
♦ Multivalued Dependencies: A multivalued dependency is a statement that 
two sets of attributes in a relation have sets of values that appear in all 
possible combinations.
♦ Fourth Normal Form: MVD’s can also cause redundancy in a relation. 
4NF is like BCNF, but also forbids nontrivial MVD’s whose left side is 
not a superkey. It is possible to decompose a relation into 4NF without 
losing information.
♦ Reasoning About M VD’s: We can infer MVD’s and FD’s from a given set 
of MVD’s and FD’s by a chase process. We start with a two-row tableau 
that represent the dependency we are trying to prove. FD’s are applied by 
equating symbols, and MVD’s are applied by adding rows to the tableau 
that have the appropriate components interchanged.
3.9 References for Chapter 3
Third normal form was described in [6]. This paper introduces the idea of 
functional dependencies, as well as the basic relational concept. Boyce-Codd 
normal form is in a later paper [7].
Multivalued dependencies and fourth normal form were defined by Fagin in 
[9]. However, the idea of multivalued dependencies also appears independently 
in [8] and [11].
Armstrong was the first to study rules for inferring FD’s [2], The rules for 
FD’s that we have covered here (including what we call “Armstrong’s axioms”) 
and rules for inferring MVD’s as well, come from [3].
The technique for testing an FD by computing the closure for a set of attributes is from [4], as is the fact that a minimal basis provides a 3NF decomposition. The fact that this decomposition provides the lossless-join and 
dependency-preservation propoerties is from [5].
The tableau test for the lossless-join property and the chase are from [1], 
More information and the history of the idea is found in [10].
1. A. V. Aho, C. Beeri, and J. D. Ullman, “The theory of joins in relational 
databases,” ACM Transactions on Database Systems 4:3, pp. 297-314, 
1979.
2. W. W. Armstrong, “Dependency structures of database relationships,” 
Proceedings of the 1974 IFIP Congress, pp. 580-583.
3.9. REFERENCES FOR CHAPTER 3 123
3. C. Beeri, R. Fagin, and J. H. Howard, “A complete axiomatization for 
functional and multivalued dependencies,” ACM SIGMOD Intl. Conf. on
Management of Data, pp. 47-61, 1977.
4. P. A. Bernstein, “Synthesizing third normal form relations from functional 
dependencies,” ACM Transactions on Database Systems 1:4, pp. 277-298,
1976.
5. J. Biskup, U. Dayal, and P. A. Bernstein, “Synthesizing independent 
database schemas,” ACM SIGMOD Intl. Conf. on Management of Data,
pp. 143-152, 1979.
6. E. F. Codd, “A relational model for large shared data banks,” Comm.
ACM 13:6, pp. 377-387, 1970.
7. E. F. Codd, “Further normalization of the data base relational model,” in 
Database Systems (R. Rustin, ed.), Prentice-Hall, Englewood Cliffs, NJ, 
1972.
8. C. Delobel, “Normalization and hierarchical dependencies in the relational 
data model,” ACM Transactions on Database Systems 3:3, pp. 201-222, 
1978.
9. R. Fagin, “Multivalued dependencies and a new normal form for relational 
databases,” ACM Transactions on Database Systems 2:3, pp. 262-278,
1977.
10. J. D. Ullman, Principles of Database and Knowledge-Base Systems, Volume I, Computer Science Press, New York, 1988.
11. C. Zaniolo and M. A. Melkanoff, “On the design of relational database 
schemata,” ACM Transactions on Database Systems 6:1, pp. 1-47, 1981.

Chapter 4
High-Level Database
Models
Let us consider the process whereby a new database, such as our movie database, 
is created. Figure 4.1 suggests the process. We begin with a design phase, in 
which we address and answer questions about what information will be stored, 
how information elements will be related to one another, what constraints such 
as keys or referential integrity may be assumed, and so on. This phase may last 
for a long time, while options are evaluated and opinions axe reconciled. We 
show this phase in Fig. 4.1 as the conversion of ideas to a high-level design.
Relational
Ideas ---------- ► H igh-L evel ---------- ^ Database
Desi§n Schem a
Figure 4.1: The database modeling and implementation process
Since the great majority of commercial database systems use the relational 
model, we might suppose that the design phase should use this model too. 
However, in practice it is often easier to start with a higher-level model and 
then convert the design to the relational model. The primary reason for doing so 
is that the relational model has only one concept — the relation — rather than 
several complementary concepts that more closely model real-world situations. 
Simplicity of concepts in the relational model is a great strength of the model, 
especially when it comes to efficient implementation of database operations. 
Yet that strength becomes a weakness when we do a preliminary design, which 
is why it often is helpful to begin by using a high-level design model.
There are several options for the notation in which the design is expressed. 
The first, and oldest, method is the “entity-relationship diagram,” and here is 
where we shall start in Section 4.1. A more recent trend is the use of UML 
(“Unified Modeling Language”), a notation that was originally designed for
Relational
DBM S
125
126 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
describing object-oriented software projects, but which has been adapted to describe database schemas as well. We shall see this model in Section 4.7. Finally, 
in Section 4.9, we shall consider ODL (“Object Description Language”), which 
was created to describe databases as collections of classes and their objects.
The next phase shown in Fig. 4.1 is the conversion of our high-level design 
to a relational design. This phase occurs only when we are confident of the 
high-level design. Whichever of the high-level models we use, there is a fairly 
mechanical way of converting the high-level design into a relational database 
schema, which then runs on a conventional DBMS. Sections 4.5 and 4.6 discuss 
conversion of E /R diagrams to relational database schemas. Section 4.8 does 
the same for UML, and Section 4.10 serves for ODL.
4.1 The Entity/Relationship Model
In the entity-relationship model (or E /R model), the structure of data is represented graphically, as an “entity-relationship diagram,” using three principal 
element types:
1. Entity sets,
2. Attributes, and
3. Relationships.
We shall cover each in turn.
4.1.1 Entity Sets
An entity is an abstract object of some sort, and a collection of similar entities 
forms an entity set. An entity in some ways resembles an “object” in the sense of 
object-oriented programming. Likewise, an entity set bears some resemblance 
to a class of objects. However, the E /R model is a static concept, involving the 
structure of data and not the operations on data. Thus, one would not expect 
to find methods associated with an entity set as one would with a class.
E xam ple 4.1: Let us consider the design of our running movie-database example. Each movie is an entity, and the set of all movies constitutes an entity 
set. Likewise, the stars are entities, and the set of stars is an entity set. A 
studio is another kind of entity, and the set of studios is a third entity set that 
will appear in our examples. □
4.1.2 Attributes
Entity sets have associated attributes, which are properties of the entities in 
that set. For instance, the entity set Movies might be given attributes such 
as title and length. It should not surprise you if the attributes for the entity
4.1. THE ENTITY/RELATIO NSH IP MODEL 127
E /R Model Variations
In some versions of the E /R model, the type of an attribute can be either:
1. A primitive type, as in the version presented here.
2. A “struct,” as in C, or tuple with a fixed number of primitive components.
3. A set of values of one type: either primitive or a “struct” type.
For example, the type of an attribute in such a model could be a set of 
pairs, each pair consisting of an integer and a string.
set Movies resemble the attributes of the relation Movies in our example. It 
is common for entity sets to be implemented as relations, although not every 
relation in our final relational design will come from an entity set.
In our version of the E /R model, we shall assume that attributes are of 
primitive types, such as strings, integers, or reals. There are other variations of 
this model in which attributes can have some limited structure; see the box on 
“E /R Model Variations.”
4.1.3 Relationships
Relationships are connections among two or more entity sets. For instance, 
if Movies and Stars are two entity sets, we could have a relationship Stars-in
that connects movies and stars. The intent is that a movie entity m is related 
to a star entity s by the relationship Stars-in if s appears in movie m. While 
binary relationships, those between two entity sets, are by far the most common 
type of relationship, the E /R model allows relationships to involve any number 
of entity sets. We shall defer discussion of these multiway relationships until 
Section 4.1.7.
4.1.4 Entity-Relationship Diagrams
An E /R diagram is a graph representing entity sets, attributes, and relationships. Elements of each of these kinds are represented by nodes of the graph, 
and we use a special shape of node to indicate the kind, as follows:
• Entity sets are represented by rectangles.
• Attributes are represented by ovals.
• Relationships are represented by diamonds.
128 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
Edges connect an entity set to its attributes and also connect a relationship to 
its entity sets.
Exam ple 4.2 : In Fig. 4.2 is an E /R diagram that represents a simple database 
about movies. The entity sets are Movies, Stars, and Studios.
Figure 4.2: An entity-relationship diagram for the movie database
The Movies entity set has four of our usual attributes: title, year, length,
and genre. The other two entity sets Stars and Studios happen to have the 
same two attributes: name and address, each with an obvious meaning. We 
also see two relationships in the diagram:
1. Stars-in is a relationship connecting each movie to the stars of that movie. 
This relationship consequently also connects stars to the movies in which 
they appeared.
2. Owns connects each movie to the studio that owns the movie. The arrow 
pointing to entity set Studios in Fig. 4.2 indicates that each movie is 
owned by at most one studio. We shall discuss uniqueness constraints 
such as this one in Section 4.1.6.
□
4.1.5 Instances of an E /R Diagram
E /R diagrams are a notation for describing schemas of databases. We may 
imagine that a database described by an E /R diagram contains particular data, 
an “instance” of the database. Since the database is not implemented in the 
E /R model, only designed, the instance never exists in the sense that a relation’s
4.1. THE ENTITY/RELATIO NSH IP MODEL 129
instances exist in a DBMS. However, it is often useful to visualize the database 
being designed as if it existed.
For each entity set, the database instance will have a particular finite set 
of entities. Each of these entities has particular values for each attribute. A 
relationship R that connects n entity sets Ei ,E2,... ,E„ may be imagined to 
have an “instance” that consists of a finite set of tuples (ei,e2, ... ,en), where 
each ei is chosen from the entities that are in the current instance of entity set 
Ei. We regard each of these tuples as “connected” by relationship R.
This set of tuples is called the relationship set for R. It is often helpful to 
visualize a relationship set as a table or relation. However, the “tuples” of a 
relationship set are not really tuples of a relation, since their components are 
entities rather than primitive types such as strings or integers. The columns of 
the table are headed by the names of the entity sets involved in the relationship, 
and each list of connected entities occupies one row of the table. As we shall 
see, however, when we convert relationships to relations, the resulting relation 
is not the same as the relationship set.
E xam ple 4.3: An instance of the Stars-in relationship could be visualized as 
a table with pairs such as:
Movies Stars
Basic Instinct Sharon Stone
Total Recall Arnold Schwarzenegger
Total Recall Sharon Stone
The members of the relationship set are the rows of the table. For instance, 
(Basic Instinct, Sharon Stone) is a tuple in the relationship set for the current 
instance of relationship Stars-in. □
4.1.6 M ultiplicity of Binary E /R Relationships
In general, a binary relationship can connect any member of one of its entity 
sets to any number of members of the other entity set. However, it is common 
for there to be a restriction on the “multiplicity” of a relationship. Suppose R
is a relationship connecting entity sets E and F. Then:
• If each member of E can be connected by R to at most one member of F,
then we say that R is many-one from E to F. Note that in a many-one 
relationship from E to F, each entity in F can be connected to many 
members of E. Similarly, if instead a member of F can be connected by 
R to at most one member of E, then we say R is many-one from F to E
(or equivalently, one-many from E to F).
• If R is both many-one from E to F and many-one from F to E, then we 
say that R is one-one. In a one-one relationship an entity of either entity 
set can be connected to at most one entity of the other set.
130 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
• If R is neither many-one from E to F or from F to E, then we say R is 
many-many.
As we mentioned in Example 4.2, arrows can be used to indicate the multiplicity of a relationship in an E /R diagram. If a relationship is many-one from 
entity set E to entity set F, then we place an arrow entering F. The arrow 
indicates that each entity in set E is related to at most one entity in set F.
Unless there is also an arrow on the edge to E, an entity in F may be related 
to many entities in E.
E xam ple 4.4: A one-one relationship between entity sets E and F is represented by arrows pointing to both E and F. For instance, Fig. 4.3 shows two 
entity sets, Studios and Presidents, and the relationship Runs between them 
(attributes are omitted). We assume that a president can run only one studio 
and a studio has only one president, so this relationship is one-one, as indicated 
by the two arrows, one entering each entity set.
Remember that the arrow means “at most one”; it does not guarantee existence of an entity of the set pointed to. Thus, in Fig. 4.3, we would expect 
that a “president” is surely associated with some studio; how could they be a 
“president” otherwise? However, a studio might not have a president at some 
particular time, so the arrow from Runs to Presidents truly means “at most one” 
and not “exactly one.” We shall discuss the distinction further in Section 4.3.3.
□
4.1.7 Multiway Relationships
The E /R model makes it convenient to define relationships involving more than 
two entity sets. In practice, ternary (three-way) or higher-degree relationships 
are rare, but they occasionally are necessary to reflect the true state of affairs. 
A multiway relationship in an E /R diagram is represented by lines from the 
relationship diamond to each of the involved entity sets.
E xam ple 4.5: In Fig. 4.4 is a relationship Contracts that involves a studio, 
a star, and a movie. This relationship represents that a studio has contracted 
with a particular star to act in a particular movie. In general, the value of 
an E /R relationship can be thought of as a relationship set of tuples whose 
components are the entities participating in the relationship, as we discussed in 
Section 4.1.5. Thus, relationship Contracts can be described by triples of the 
form (studio, star, movie).
Studios Presidents
Figure 4.3: A one-one relationship
4.1. THE ENTITY/RELATIO NSH IP MODEL 131
Figure 4.4: A three-way relationship
In multiway relationships, an arrow pointing to an entity set E means that if 
we select one entity from each of the other entity sets in the relationship, those 
entities are related to at most one entity in E. (Note that this rule generalizes 
the notation used for many-one, binary relationships.) Informally, we may think 
of a functional dependency with E on the right and all the other entity sets of 
the relationship on the left.
In Fig. 4.4 we have an arrow pointing to entity set Studios, indicating that 
for a particular star and movie, there is only one studio with which the star has 
contracted for that movie. However, there are no arrows pointing to entity sets 
Stars or Movies. A studio may contract with several stars for a movie, and a 
star may contract with one studio for more than one movie. □
4.1.8 Roles in Relationships
It is possible that one entity set appears two or more times in a single relationship. If so, we draw as many lines from the relationship to the entity set as the 
entity set appears in the relationship. Each line to the entity set represents a 
different role that the entity set plays in the relationship. We therefore label the 
edges between the entity set and relationship by names, which we call “roles.”
E xam ple 4.6: In Fig. 4.5 is a relationship Sequel-of between the entity set 
Movies and itself. Each relationship is between two movies, one of which is 
the sequel of the other. To differentiate the two movies in a relationship, one 
line is labeled by the role Original and one by the role Sequel, indicating the
132 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
Limits on Arrow Notation in Multiway Relationships
There are not enough choices of arrow or no-arrow on the lines attached to 
a relationship with three or more participants. Thus, we cannot describe 
every possible situation with arrows. For instance, in Fig. 4.4, the studio 
is really a function of the movie alone, not the star and movie jointly, 
since only one studio produces a movie. However, our notation does not 
distinguish this situation from the case of a three-way relationship where 
the entity set pointed to by the arrow is truly a function of both other 
entity sets. To handle all possible situations, we would have to give a set 
of functional dependencies involving the entity sets of the relationship.
Original
Figure 4.5: A relationship with roles
original movie and its sequel, respectively. We assume that a movie may have 
many sequels, but for each sequel there is only one original movie. Thus, the 
relationship is many-one from Sequel movies to Original movies, as indicated 
by the arrow in the E/R diagram of Fig. 4.5. □
E xam ple 4.7: As a final example that includes both a multiway relationship 
and an entity set with multiple roles, in Fig. 4.6 is a more complex version of 
the Contracts relationship introduced earlier in Example 4.5. Now, relationship 
Contracts involves two studios, a star, and a movie. The intent is that one 
studio, having a certain star under contract (in general, not for a particular 
movie), may further contract with a second studio to allow that star to act in 
a particular movie. Thus, the relationship is described by 4-tuples of the form 
(studiol, studio2, star, movie), meaning that studio2 contracts with studiol for 
the use of studiol’s star by studio2 for the movie.
We see in Fig. 4.6 arrows pointing to Studios in both of its roles, as “owner” 
of the star and as producer of the movie. However, there are not arrows pointing 
to Stars or Movies. The rationale is as follows. Given a star, a movie, and a 
studio producing the movie, there can be only one studio that “owns” the 
star. (We assume a star is under contract to exactly one studio.) Similarly, 
only one studio produces a given movie, so given a star, a movie, and the 
star’s studio, we can determine a unique producing studio. Note that in both
4.1. THE ENTITY/RELATIO NSH IP MODEL 133
Figure 4.6: A four-way relationship
cases we actually needed only one of the other entities to determine the unique 
entity—for example, we need only know the movie to determine the unique 
producing studio—but this fact does not change the multiplicity specification 
for the multiway relationship.
There are no arrows pointing to Stars or Movies. Given a star, the star’s 
studio, and a producing studio, there could be several different contracts allowing the star to act in several movies. Thus, the other three components in a 
relationship 4-tuple do not necessarily determine a unique movie. Similarly, a 
producing studio might contract with some other studio to use more than one 
of their stars in one movie. Thus, a star is not determined by the three other 
components of the relationship. □
Figure 4.7: A relationship with an attribute
134 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
4.1.9 Attributes on Relationships
Sometimes it is convenient, or even essential, to associate attributes with a 
relationship, rather than with any one of the entity sets that the relationship 
connects. For example, consider the relationship of Fig. 4.4, which represents 
contracts between a star and studio for a movie.1 We might wish to record the 
salary associated with this contract. However, we cannot associate it with the 
star; a star might get different salaries for different movies. Similarly, it does 
not make sense to associate the salary with a studio (they may pay different 
salaries to different stars) or with a movie (different stars in a movie may receive 
different salaries).
However, we can associate a unique salary with the (star, movie, studio) 
triple in the relationship set for the Contracts relationship. In Fig. 4.7 we see 
Fig. 4.4 fleshed out with attributes. The relationship has attribute salary, while 
the entity sets have the same attributes that we showed for them in Fig. 4.2.
In general, we may place one or more attributes on any relationship. The 
values of these attributes are functionally determined by the entire tuple in the 
relationship set for that relation. In some cases, the attributes can be determined by a subset of the entity sets involved in the relation, but presumably 
not by any single entity set (or it would make more sense to place the attribute 
on that entity set). For instance, in Fig. 4.7, the salary is really determined by 
the movie and star entities, since the studio entity is itself determined by the 
movie entity.
It is never necessary to place attributes on relationships. We can instead 
invent a new entity set, whose entities have the attributes ascribed to the relationship. If we then include this entity set in the relationship, we can omit the 
attributes on the relationship itself. However, attributes on a relationship are 
a useful convention, which we shall continue to use where appropriate.
Exam ple 4.8: Let us revise the E /R diagram of Fig. 4.7, which has the 
salary attribute on the Contracts relationship. Instead, we create an entity 
set Salaries, with attribute salary. Salaries becomes the fourth entity set of 
relationship Contracts. The whole diagram is shown in Fig. 4.8.
Notice that there is an arrow into the Salaries entity set in Fig. 4.8. That 
arrow is appropriate, since we know that the salary is determined by all the other 
entity sets involved in the relationship. In general, when we do a conversion 
from attributes on a relationship to an additional entity set, we place an arrow 
into that entity set. □
4.1.10 Converting Multiway Relationships to Binary
There are some data models, such as UML (Section 4.7) and ODL (Section 4.9), 
that limit relationships to be binary. Thus, while the E /R model does not
1H ere, we have reverted to th e earlier notion of three-w ay contracts in E xam ple 4.5, not 
th e four-w ay relationship of E xam ple 4.7.
4.1. THE ENTITY/RELATIO NSH IP MODEL 135
Figure 4.8: Moving the attribute to an entity set
require binary relationships, it is useful to observe that any relationship connecting more than two entity sets can be converted to a collection of binary, 
many-one relationships. To do so, introduce a new entity set whose entities we 
may think of as tuples of the relationship set for the multiway relationship. We 
call this entity set a connecting entity set. We then introduce many-one relationships from the connecting entity set to each of the entity sets that provide 
components of tuples in the original, multiway relationship. If an entity set 
plays more than one role, then it is the target of one relationship for each role.
E xam ple 4.9: The four-way Contracts relationship in Fig. 4.6 can be replaced 
by an entity set that we may also call Contracts. As seen in Fig. 4.9, it participates in four relationships. If the relationship set for the relationship Contracts
has a 4-tuple (studiol, studio2, star, movie) then the entity set Contracts has 
an entity e. This entity is linked by relationship Star-of to the entity star in 
entity set Stars. It is linked by relationship Movie-of to the entity movie in 
Movies. It is linked to entities studiol and studioB of Studios by relationships 
Studio-of-star and Producing-studio, respectively.
Note that we have assumed there are no attributes of entity set Contracts,
although the other entity sets in Fig. 4.9 have unseen attributes. However, it is 
possible to add attributes, such as the date of signing, to entity set Contracts.
□
4.1.11 Subclasses in the E /R Model
Often, an entity set contains certain entities that have special properties not 
associated with all members of the set. If so, we find it useful to define certain
136 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
Figure 4.9: Replacing a multiway relationship by an entity set and binary 
relationships
special-case entity sets, or subclasses, each with its own special attributes and/or 
relationships. We connect an entity set to its subclasses using a relationship 
called isa (i.e., “an A is a B ” expresses an “isa” relationship from entity set A
to entity set B).
An isa relationship is a special kind of relationship, and to emphasize that 
it is unlike other relationships, we use a special notation: a triangle. One side 
of the triangle is attached to the subclass, and the opposite point is connected 
to the superclass. Every isa relationship is one-one, although we shall not draw 
the two arrows that are associated with other one-one relationships.
Exam ple 4.10: Among the special kinds of movies we might store in our 
example database are cartoons and murder mysteries. For each of these special 
movie types, we could define a subclass of the entity set Movies. For instance, let 
us postulate two subclasses: Cartoons and Murder-Mysteries. A cartoon has, in 
addition to the attributes and relationships of Movies, an additional relationship 
called Voices that gives us a set of stars who speak, but do not appear in the 
movie. Movies that are not cartoons do not have such stars. Murder-mysteries 
have an additional attribute weapon. The connections among the three entity 
sets Movies, Cartoons, and Murder-Mysteries is shown in Fig. 4.10. □
While, in principle, a collection of entity sets connected by isa relationships 
could have any structure, we shall limit isa-structures to trees, in which there
4.1. THE ENTITY/RELATIONSHIP MODEL 137
Figure 4.10: Isa relationships in an E /R diagram
is one root entity set (e.g., Movies in Fig. 4.10) that is the most general, with 
progressively more specialized entity sets extending below the root in a tree.
Suppose we have a tree of entity sets, connected by isa relationships. A 
single entity consists of components from one or more of these entity sets, as 
long as those components are in a subtree including the root. That is, if an 
entity e has a component c in entity set E, and the parent of E in the tree is 
F, then entity e also has a component d in F. Further, c and d must be paired 
in the relationship set for the isa relationship from E to F. The entity e has 
whatever attributes any of its components has, and it participates in whatever 
relationships any of its components participate in.
E xam ple 4.11: The typical movie, being neither a cartoon nor a murdermystery, will have a component only in the root entity set Movies in Fig. 4.10. 
These entities have only the four attributes of Movies (and the two relationships
138 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
The E /R View of Subclasses
There is a significant resemblance between “isa” in the E /R model and 
subclasses in object-oriented languages. In a sense, “isa” relates a subclass 
to its superclass. However, there is also a fundamental difference between 
the conventional E /R view and the object-oriented approach: entities are 
allowed to have representatives in a tree of entity sets, while objects are 
assumed to exist in exactly one class or subclass.
The difference becomes apparent when we consider how the movie 
Roger Rabbit was handled in Example 4.11. In an object-oriented approach, we would need for this movie a fourth entity set, “cartoon-murdermystery,” which inherited all the attributes and relationships of Movies,
Cartoons, and Murder-Mysteries. However, in the E /R model, the effect 
of this fourth subclass is obtained by putting components of the movie 
Roger Rabbit in both the Cartoons and Murder-Mysteries entity sets.
of Movies — Stars-in and Owns — that are not shown in Fig. 4.10).
A cartoon that is not a murder-mystery will have two components, one in 
Movies and one in Cartoons. Its entity will therefore have not only the four 
attributes of Movies, but the relationship Voices. Likewise, a murder-mystery 
will have two components for its entity, one in Movies and one in MurderMysteries and thus will have five attributes, including weapon.
Finally, a movie like Roger Rabbit, which is both a cartoon and a murdermystery, will have components in all three of the entity sets Movies, Cartoons,
and Murder-Mysteries. The three components are connected into one entity by 
the isa relationships. Together, these components give the Roger Rabbit entity 
all four attributes of Movies plus the attribute weapon of entity set MurderMysteries and the relationship Voices of entity set Cartoons. □
4.1.12 Exercises for Section 4.1
Exercise 4.1.1: Design a database for a bank, including information about 
customers and their accounts. Information about a customer includes their 
name, address, phone, and Social Security number. Accounts have numbers, 
types (e.g., savings, checking) and balances. Also record the customer(s) who 
own an account. Draw the E /R diagram for this database. Be sure to include 
arrows where appropriate, to indicate the multiplicity of a relationship.
Exercise 4.1.2: Modify your solution to Exercise 4.1.1 as follows:
a) Change your diagram so an account can have only one customer.
b) Further change your diagram so a customer can have only one account.
4.1. THE ENTITY/RELATIO NSH IP MODEL 139
! c) Change your original diagram of Exercise 4.1.1 so that a customer can 
have a set of addresses (which are street-city-state triples) and a set of 
phones. Remember that we do not allow attributes to have nonprimitive 
types, such as sets, in the E /R model.
! d) Further modify your diagram so that customers can have a set of addresses, and at each address there is a set of phones.
Exercise 4.1.3: Give an E /R diagram for a database recording information 
about teams, players, and their fans, including:
1. For each team, its name, its players, its team captain (one of its players), 
and the colors of its uniform.
2. For each player, his/her name.
3. For each fan, his/her name, favorite teams, favorite players, and favorite 
color.
Remember that a set of colors is not a suitable attribute type for teams. How 
can you get around this restriction?
Exercise 4.1.4: Suppose we wish to add to the schema of Exercise 4.1.3 a 
relationship Led-by among two players and a team. The intention is that this 
relationship set consists of triples (playerl, player2, team) such that player 1 
played on the team at a time when some other player 2 was the team captain.
a) Draw the modification to the E /R diagram.
b) Replace your ternary relationship with a new entity set and binary relationships.
! c) Are your new binary relationships the same as any of the previously existing relationships? Note that we assume the two players are different,
i.e., the team captain is not self-led.
Exercise 4.1.5: Modify Exercise 4.1.3 to record for each player the history of 
teams on which they have played, including the start date and ending date (if 
they were traded) for each such team.
! E xercise 4.1.6: Design a genealogy database with one entity set: People. The 
information to record about persons includes their name (an attribute), their 
mother, father, and children.
! E xercise 4.1.7: Modify your “people” database design of Exercise 4.1.6 to 
include the following special types of people:
1. Females.
140 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
2. Males.
3. People who are parents.
You may wish to distinguish certain other kinds of people as well, so relationships connect appropriate subclasses of people.
Exercise 4.1.8: An alternative way to represent the information of Exercise 4.1.6 is to have a ternary relationship Family with the intent that in the 
relationship set for Family, triple (person, mother, father) is a person, their 
mother, and their father; all three are in the People entity set, of course.
a) Draw this diagram, placing arrows on edges where appropriate.
b) Replace the ternary relationship Family by an entity set and binary relationships. Again place arrows to indicate the multiplicity of relationships.
Exercise 4.1.9: Design a database suitable for a university registrar. This 
database should include information about students, departments, professors, 
courses, which students are enrolled in which courses, which professors are 
teaching which courses, student grades, TA’s for a course (TA’s are students), 
which courses a department offers, and any other information you deem appropriate. Note that this question is more free-form than the questions above, and 
you need to make some decisions about multiplicities of relationships, appropriate types, and even what information needs to be represented.
! Exercise 4.1.10: Informally, we can say that two E /R diagrams “have the 
same information” if, given a real-world situation, the instances of these two diagrams that reflect this situation can be computed from one another. Consider 
the E /R diagram of Fig. 4.6. This four-way relationship can be decomposed 
into a three-way relationship and a binary relationship by taking advantage 
of the fact that for each movie, there is a unique studio that produces that 
movie. Give an E /R diagram without a four-way relationship that has the 
same information as Fig. 4.6.
4.2 Design Principles
We have yet to learn many of the details of the E /R model, but we have enough 
to begin study of the crucial issue of what constitutes a good design and what 
should be avoided. In this section, we offer some useful design principles.
4.2.1 Faithfulness
First and foremost, the design should be faithful to the specifications of the 
application. That is, entity sets and their attributes should reflect reality. You 
can’t attach an attribute number-of-cylinders to Stars, although that attribute
4.2. DESIGN PRINCIPLES 141
would make sense for an entity set Automobiles. Whatever relationships are 
asserted should make sense given what we know about the part of the real 
world being modeled.
E xam ple 4.12: If we define a relationship Stars-in between Stars and Movies,
it should be a many-many relationship. The reason is that an observation of the 
real world tells us that stars can appear in more than one movie, and movies 
can have more than one star. It is incorrect to declare the relationship Stars-in
to be many-one in either direction or to be one-one. □
E xam ple 4.13: On the other hand, sometimes it is less obvious what the 
real world requires us to do in our E /R design. Consider, for instance, entity 
sets Courses and Instructors, with a relationship Teaches between them. Is 
Teaches many-one from Courses to Instructors? The answer lies in the policy 
and intentions of the organization creating the database. It is possible that 
the school has a policy that there can be only one instructor for any course. 
Even if several instructors may “team-teach” a course, the school may require 
that exactly one of them be listed in the database as the instructor responsible 
for the course. In either of these cases, we would make Teaches a many-one 
relationship from Courses to Instructors.
Alternatively, the school may use teams of instructors regularly and wish 
its database to allow several instructors to be associated with a course. Or, 
the intent of the Teaches relationship may not be to reflect the current teacher 
of a course, but rather those who have ever taught the course, or those who 
are capable of teaching the course; we cannot tell simply from the name of the 
relationship. In either of these cases, it would be proper to make Teaches be 
many-many. □
4.2.2 Avoiding Redundancy
We should be careful to say everything once only. The problems we discussed 
in Section 3.3 regarding redundancy and anomalies are typical of problems that 
can arise in E /R designs. However, in the E /R model, there are several new 
mechanisms whereby redundancy and other anomalies can arise.
For instance, we have used a relationship Owns between movies and studios. 
We might also choose to have an attribute studioName of entity set Movies.
While there is nothing illegal about doing so, it is dangerous for several reasons.
1. Doing so leads to repetition of a fact, with the result that extra space 
is required to represent the data, once we convert the E /R design to a 
relational (or other type of) concrete implementation.
2. There is an update-anomaly potential, since we might change the relationship but not the attribute, or vice-versa.
We shall say more about avoiding anomalies in Sections 4.2.4 and 4.2.5.
142 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
4.2.3 Simplicity Counts
Avoid introducing more elements into your design than is absolutely necessary.
Exam ple 4.14: Suppose that instead of a relationship between Movies and 
Studios we postulated the existence of “movie-holdings,” the ownership of a 
single movie. We might then create another entity set Holdings. A one-one 
relationship Represents could be established between each movie and the unique 
holding that represents the movie. A many-one relationship from Holdings to 
Studios completes the picture shown in Fig. 4.11.
Figure 4.11: A poor design with an unnecessary entity set
Technically, the structure of Fig. 4.11 truly represents the real world, since 
it is possible to go from a movie to its unique owning studio via Holdings.
However, Holdings serves no useful purpose, and we axe better off without it. 
It makes programs that use the movie-studio relationship more complicated, 
wastes space, and encourages errors. □
4.2.4 Choosing the Right Relationships
Entity sets can be connected in various ways by relationships. However, adding 
to our design every possible relationship is not often a good idea. Doing so 
can lead to redundancy, update anomalies, and deletion anomalies, where the 
connected pairs or sets of entities for one relationship can be deduced from 
one or more other relationships. We shall illustrate the problem and what 
to do about it with two examples. In the first example, several relationships 
could represent the same information; in the second, one relationship could be 
deduced from several others.
Exam ple 4.15: Let us review Fig. 4.7, where we connected movies, stars, 
and studios with a three-way relationship Contracts. We omitted from that 
figure the two binary relationships Stars-in and Owns from Fig. 4.2. Do we 
also need these relationships, between Movies and Stars, and between Movies
and Studios, respectively? The answer is: “we don’t know; it depends on our 
assumptions regarding the three relationships in question.”
It might be possible to deduce the relationship Stars-in from Contracts. If 
a star can appear in a movie only if there is a contract involving that star, that 
movie, and the owning studio for the movie, then there truly is no need for 
relationship Stars-in. We could figure out all the star-movie pairs by looking 
at the star-movie-studio triples in the relationship set for Contracts and taking 
only the star and movie components, i.e., projecting Contracts onto Stars-in.
4.2. DESIGN PRINCIPLES 143
However, if a star can work on a movie without there being a contract — or 
what is more likely, without there being a contract that we know about in our 
database — then there could be star-movie pairs in Stars-in that axe not part 
of star-movie-studio triples in Contracts. In that case, we need to retain the 
Stars-in relationship.
A similar observation applies to relationship Owns. If for every movie, there 
is at least one contract involving that movie, its owning studio, and some star for 
that movie, then we can dispense with Owns. However, if there is the possibility 
that a studio owns a movie, yet has no stars under contract for that movie, or 
no such contract is known to our database, then we must retain Owns.
In summary, we cannot tell you whether a given relationship will be redundant. You must find out from those who wish the database implemented what 
to expect. Only then can you make a rational decision about whether or not to 
include relationships such as Stars-in or Owns. □
E xam ple 4.16: Now, consider Fig. 4.2 again. In this diagram, there is no 
relationship between stars and studios. Yet we can use the two relationships 
Stars-in and Owns to build a connection by the process of composing those 
two relationships. That is, a star is connected to some movies by Stars-in, and 
those movies are connected to studios by Owns. Thus, we could say that a star 
is connected to the studios that own movies in which the star has appeared.
Would it make sense to have a relationship Works-for, as suggested in 
Fig. 4.12, between Stars and Studios too? Again, we cannot tell without knowing more. First, what would the meaning of this relationship be? If it is to 
mean “the star appeared in at least one movie of this studio,” then probably 
there is no good reason to include it in the diagram. We could deduce this 
information from Stars-in and Owns instead.
Figure 4.12: Adding a relationship between Stars and Studios
However, perhaps we have other information about stars working for studios that is not implied by the connection through a movie. In that case, a
144 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
relationship connecting stars directly to studios might be useful and would not 
be redundant. Alternatively, we might use a relationship between stars and 
studios to mean something entirely different. For example, it might represent 
the fact that the star is under contract to the studio, in a manner unrelated 
to any movie. As we suggested in Example 4.7, it is possible for a star to be 
under contract to one studio and yet work on a movie owned by another studio. In this case, the information found in the new Works-for relation would 
be independent of the Stars-in and Owns relationships, and would surely be 
nonredundant. □
4.2.5 Picking the Right Kind of Element
Sometimes we have options regarding the type of design element used to represent a real-world concept. Many of these choices are between using attributes 
and using entity set/relationship combinations. In general, an attribute is simpler to implement than either an entity set or a relationship. However, making 
everything an attribute will usually get us into trouble.
Exam ple 4.17: Let us consider a specific problem. In Fig. 4.2, were we wise 
to make studios an entity set? Should we instead have made the name and 
address of the studio be attributes of movies and eliminated the Studio entity 
set? One problem with doing so is that we repeat the address of the studio for 
each movie. We can also have an update anomaly if we change the address for 
one movie but not another with the same studio, and we can have a deletion 
anomaly if we delete the last movie owned by a given studio.
On the other hand, if we did not record addresses of studios, then there 
is no harm in making the studio name an attribute of movies. We have no 
anomalies in this case. Saying the name of a studio for each movie is not true 
redundancy, since we must represent the owner of each movie somehow, and 
saying the name of the studio is a reasonable way to do so. □
We can abstract what we have observed in Example 4.17 to give the conditions under which we prefer to use an attribute instead of an entity set. 
Suppose E is an entity set. Here are conditions that E must obey in order for 
us to replace E by an attribute or attributes of several other entity sets.
1. All relationships in which E is involved must have arrows entering E.
That is, E must be the “one” in many-one relationships, or its generalization for the case of multiway relationships.
2. If E has more than one attribute, then no attribute depends on the other 
attributes, the way address depends on name for Studios. That is, the 
only key for E is all its attributes.
3. No relationship involves E more than once.
If these conditions are met, then we can replace entity set E as follows:
4.2. DESIGN PRINCIPLES 145
a) If there is a many-one relationship R from some entity set F to E, then remove R and make the attributes of E be attributes of F, suitably renamed 
if they conflict with attribute names for F. In effect, each F-entity takes, 
as attributes, the name of the unique, related identity.2 For instance, 
Movies entities could take their studio name as an attribute, should we 
dispense with studio addresses.
b) If there is a multiway relationship R with an arrow to E, make the attributes of E be attributes of R and delete the arc from R to E. An 
example of this transformation is replacing Fig. 4.8, where there is an 
entity set Salaries with a number as its lone attribute, by its original 
diagram in Fig. 4.7.
E xam ple 4.18: Let us consider a point where there is a tradeoff between using 
a multiway relationship and using a connecting entity set with several binary 
relationships. We saw a four-way relationship Contracts among a star, a movie, 
and two studios in Fig. 4.6. In Fig. 4.9, we mechanically converted it to an 
entity set Contracts. Does it matter which we choose?
As the problem was stated, either is appropriate. However, should we change 
the problem just slightly, then we are almost forced to choose a connecting entity 
set. Let us suppose that contracts involve one star, one movie, but any set of 
studios. This situation is more complex than the one in Fig. 4.6, where we 
had two studios playing two roles. In this case, we can have any number of 
studios involved, perhaps one to do production, one for special effects, one for 
distribution, and so on. Thus, we cannot assign roles for studios.
It appears that a relationship set for the relationship Contracts must contain 
triples of the form (star, movie, set-of-studios), and the relationship Contracts
itself involves not only the usual Stars and Movies entity sets, but a new entity 
set whose entities are sets of studios. While this approach is possible, it seems 
unnatural to think of sets of studios as basic entities, and we do not recommend 
it.
A better approach is to think of contracts as an entity set. As in Fig. 4.9, 
a contract entity connects a star, a movie and a set of studios, but now there 
must be no limit on the number of studios. Thus, the relationship between 
contracts and studios is many-many, rather than many-one as it would be if 
contracts were a true “connecting” entity set. Figure 4.13 sketches the E /R 
diagram. Note that a contract is related to a single star and to a single movie, 
but to any number of studios. □
4.2.6 Exercises for Section 4.2
E xercise 4.2.1: In Fig. 4.14 is an E /R diagram for a bank database involving customers and accounts. Since customers may have several accounts, and
2 In a situ a tio n w here an F -e n tity is n o t related to any i?-entity, th e new a ttrib u te s of F
would be given special “null” values to indicate th e absence of a related .E-entity. A sim ilar 
arrangem ent w ould be used for th e new a ttrib u te s of i t in case (b).
146 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
\ S t a r - o f y K M ovie—o f y
Stars Contracts M ovies
Studios-oi
Studios
Figure 4.13: Contracts connecting a star, a movie, and a set of studios
accounts may be held jointly by several customers, we associate with each customer an “account set,” and accounts are members of one or more account sets. 
Assuming the meaning of the various relationships and attributes are as expected given their names, criticize the design. What design rules are violated? 
Why? What modifications would you suggest?
Figure 4.14: A poor design for a bank database
Exercise 4.2.2: Under what circumstances (regarding the unseen attributes 
of Studios and Presidents) would you recommend combining the two entity sets 
and relationship in Fig. 4.3 into a single entity set and attributes?
Exercise 4.2.3: Suppose we delete the attribute address from Studios in 
Fig. 4.7. Show how we could then replace an entity set by an attribute. Where
4.2. DESIGN PRINCIPLES 147
would that attribute appear?
E xercise 4.2.4: Give choices of attributes for the following entity sets in 
Fig. 4.13 that will allow the entity set to be replaced by an attribute:
a) Stars.
b) Movies.
! c) Studios.
!! E xercise 4.2.5: In this and following exercises we shall consider two design 
options in the E /R model for describing births. At a birth, there is one baby 
(twins would be represented by two births), one mother, any number of nurses, 
and any number of doctors. Suppose, therefore, that we have entity sets Babies,
Mothers, Nurses, and Doctors. Suppose we also use a relationship Births, which 
connects these four entity sets, as suggested in Fig. 4.15. Note that a tuple of 
the relationship set for Births has the form (baby, mother, nurse, doctor). If 
there is more than one nurse and/or doctor attending a birth, then there will 
be several tuples with the same baby and mother, one for each combination of 
nurse and doctor.
Figure 4.15: Representing births by a multiway relationship
There are certain assumptions that we might wish to incorporate into our 
design. For each, tell how to add arrows or other elements to the E /R diagram 
in order to express the assumption.
a) For every baby, there is a unique mother.
b) For every combination of a baby, nurse, and doctor, there is a unique 
mother.
c) For every combination of a baby and a mother there is a unique doctor.
! E xercise 4.2.6: Another approach to the problem of Exercise 4.2.5 is to connect the four entity sets Babies, Mothers, Nurses, and Doctors by an entity set
148 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
Figure 4.16: Representing births by an entity set
Births, with four relationships, one between Births and each of the other entity 
sets, as suggested in Fig. 4.16. Use arrows (indicating that certain of these 
relationships are many-one) to represent the following conditions:
a) Every baby is the result of a unique birth, and every birth is of a unique 
baby.
b) In addition to (a), every baby has a unique mother.
c) In addition to (a) and (b), for every birth there is a unique doctor.
In each case, what design flaws do you see?
!! Exercise 4.2.7: Suppose we change our viewpoint to allow a birth to involve 
more than one baby born to one mother. How would you represent the fact 
that every baby still has a unique mother using the approaches of Exercises 
4.2.5 and 4.2.6?
4.3 Constraints in the E /R Model
The E /R model has several ways to express the common kinds of constraints 
on the data that will populate the database being designed. Like the relational 
model, there is a way to express the idea that an attribute or attributes are a key 
for an entity set. We have already seen how an arrow connecting a relationship 
to an entity set serves as a “functional dependency.” There is also a way to 
express a referential-integrity constraint, where an entity in one set is required 
to have an entity in another set to which it is related.
4.3.1 Keys in the E /R Model
A key for an entity set E is a set K of one or more attributes such that, given 
any two distinct entities ei and e2 in E, e\ and e2 cannot have identical values 
for each of the attributes in the key K . If K consists of more than one attribute, 
then it is possible for e\ and e2 to agree in some of these attributes, but never 
in all attributes. Some important points to remember are:
4.3. CONSTRAINTS IN THE E /R MODEL 149
• Every entity set must have a key, although in some cases — isa-hierarchies 
and “weak” entity sets (see Section 4.4), the key actually belongs to another entity set.
• There can be more than one possible key for an entity set. However, it 
is customary to pick one key as the “primary key,” and to act as if that 
were the only key.
• When an entity set is involved in an isa-hierarchy, we require that the root 
entity set have all the attributes needed for a key, and that the key for 
each entity is found from its component in the root entity set, regardless 
of how many entity sets in the hierarchy have components for the entity.
In our running movies example, we have used title and year as the key for 
Movies, counting on the observation that it is unlikely that two movies with 
the same title would be released in one year. We also decided that it was safe 
to use name as a key for MovieStar, believing that no real star would ever want 
to use the name of another star.
4.3.2 Representing Keys in the E /R Model
In our E/R-diagram notation, we underline the attributes belonging to a key for 
an entity set. For example, Fig. 4.17 reproduces our E /R diagram for movies, 
stars, and studios from Fig. 4.2, but with key attributes underlined. Attribute 
name is the key for Stars. Likewise, Studios has a key consisting of only its own 
attribute name.
Figure 4.17: E /R diagram; keys are indicated by underlines
150 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
The attributes title and year together form the key for Movies. Note that 
when several attributes are underlined, as in Fig. 4.17, then they are each 
members of the key. There is no notation for representing the situation where 
there are several keys for an entity set; we underline only the primary key. You 
should also be aware that in some unusual situations, the attributes forming 
the key for an entity set do not all belong to the entity set itself. We shall defer 
this matter, called “weak entity sets,” until Section 4.4.
4.3.3 Referential Integrity
Recall our discussion of referential-integrity constraints in Section 2.5.2. These 
constraints say that a value appearing in one context must also appear in 
another. For example, let us consider the many-one relationship Owns from 
Movies to Studios in Fig. 4.2. The many-one requirement simply says that no 
movie can be owned by more than one studio. It does not say that a movie 
must surely be owned by a studio, or that the owning studio must be present 
in the Studios entity set, as stored in our database. An appropriate referential 
integrity constraint on relationship Owns is that for each movie, the owning 
studio (the entity “referenced” by the relationship for this movie) must exist in 
our database.
The arrow notation in E /R diagrams is able to indicate whether a relationship is expected to support referential integrity in one or more directions. 
Suppose R is a relationship from entity set E to entity set F. A rounded arrowhead pointing to F indicates not only that the relationship is many-one from E
to F, but that the entity of set F related to a given entity of set E is required 
to exist. The same idea applies when R is a relationship among more than two 
entity sets.
Exam ple 4.19: Figure 4.18 shows some appropriate referential integrity constraints among the entity sets Movies, Studios, and Presidents. These entity sets 
and relationships were first introduced in Figs. 4.2 and 4.3. We see a rounded 
arrow entering Studios from relationship Owns. That arrow expresses the referential integrity constraint that every movie must be owned by one studio, and 
this studio is present in the Studios entity set.
M ovies
Figure 4.18: E /R diagram showing referential integrity constraints
Similarly, we see a rounded arrow entering Studios from Runs. That arrow 
expresses the referential integrity constraint that every president runs a studio 
that exists in the Studios entity set.
Note that the arrow to Presidents from Runs remains a pointed arrow. That 
choice reflects a reasonable assumption about the relationship between studios
4.3. CONSTRAINTS IN THE E /R MODEL 151
and their presidents. If a studio ceases to exist, its president can no longer be 
called a president, so we would expect the president of the studio to be deleted 
from the entity set Presidents. Hence there is a rounded arrow to Studios. On 
the other hand, if a president were fired or resigned, the studio would continue 
to exist. Thus, we place an ordinary, pointed arrow to Presidents, indicating 
that each studio has at most one president, but might have no president at 
some time. □
4.3.4 Degree Constraints
In the E /R model, we can attach a bounding number to the edges that connect 
a relationship to an entity set, indicating limits on the number of entities that 
can be connected to any one entity of the related entity set. For example, we 
could choose to place a constraint on the degree of a relationship, such as that 
a movie entity cannot be connected by relationship Stars-in to more than 10 
star entities.
Figure 4.19: Representing a constraint on the number of stars per movie
Figure 4.19 shows how we can represent this constraint. As another example, 
we can think of the arrow as a synonym for the constraint “< 1,” and we can 
think of the rounded arrow of Fig. 4.18 as standing for the constraint “= 1.”
4.3.5 Exercises for Section 4.3
E xercise 4.3.1: For your E /R diagrams of:
a) Exercise 4.1.1.
b) Exercise 4.1.3.
c) Exercise 4.1.6.
(i) Select and specify keys, and (ii) Indicate appropriate referential integrity 
constraints.
E xercise 4.3.2: We may think of relationships in the E /R model as having 
keys, just as entity sets do. Let R be a relationship among the entity sets 
E i, E2 , ... ,E n. Then a key for R is a set K of attributes chosen from the 
attributes of E i,E 2,... , E n such that if (ei,e2)... ,en) and ( / i , / 2, - - - ,fn )
are two different tuples in the relationship set for R, then it is not possible that 
these tuples agree in all the attributes of K . Now, suppose n = 2; that is, R
is a binary relationship. Also, for each i, let Ki be a set of attributes that is a 
key for entity set Ei. In terms of Ei and E2, give a smallest possible key for R
under the assumption that:
152 CHAPTER 4. HIGH-LEVEL DATABASE MODELS
a) R is many-many.
b) R is many-one from Ei to E2.
c) R is many-one from E2 to E \.
d) R is one-one.
!! Exercise 4.3.3: Consider again the problem of Exercise 4.3.2, but with n 
allowed to be any number, not just 2. Using only the information about which 
arcs from R to the E l’s have arrows, show how to find a smallest possible key 
K for R in terms of the K i s.
4.4 Weak Entity Sets
It is possible for an entity set’s key to be composed of attributes, some or all 
of which belong to another entity set. Such an entity set is called a weak entity
set.
4.4.1 Causes of Weak Entity Sets
There are two principal reasons we need weak entity sets. First, sometimes 
